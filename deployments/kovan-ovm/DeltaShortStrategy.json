{
  "address": "0x9b75fa0c8baa2A05F0bA700D8D742CdABD5e2781",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract LyraVault",
          "name": "_vault",
          "type": "address"
        },
        {
          "internalType": "enum LyraAdapter.OptionType",
          "name": "_optionType",
          "type": "uint8"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "thrower",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "baseExpected",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "baseReceived",
          "type": "uint256"
        }
      ],
      "name": "ExchangerBaseReceivedTooLow",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "thrower",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "quoteExpected",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "quoteReceived",
          "type": "uint256"
        }
      ],
      "name": "ExchangerQuoteReceivedTooLow",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "expiry",
          "type": "uint256"
        }
      ],
      "name": "_isValidExpiry",
      "outputs": [
        {
          "internalType": "bool",
          "name": "isValid",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "strikeId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "secondsAgo",
          "type": "uint256"
        }
      ],
      "name": "_optionPriceGWAV",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "callPrice",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "putPrice",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "activeExpiry",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "activeStrikeIds",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "baseAsset",
      "outputs": [
        {
          "internalType": "contract IERC20",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "collateralAsset",
      "outputs": [
        {
          "internalType": "contract IERC20",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "curveSwap",
      "outputs": [
        {
          "internalType": "contract ICurve",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "strikeId",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "lyraRewardRecipient",
          "type": "address"
        }
      ],
      "name": "doTrade",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "positionId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "premiumReceived",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "collateralToAdd",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "lyraRewardRecipient",
          "type": "address"
        }
      ],
      "name": "emergencyCloseAll",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "feeCounter",
      "outputs": [
        {
          "internalType": "contract BasicFeeCounter",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "positionId",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "strikeId",
              "type": "uint256"
            },
            {
              "internalType": "enum LyraAdapter.OptionType",
              "name": "optionType",
              "type": "uint8"
            },
            {
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "collateral",
              "type": "uint256"
            },
            {
              "internalType": "enum LyraAdapter.PositionState",
              "name": "state",
              "type": "uint8"
            }
          ],
          "internalType": "struct LyraAdapter.OptionPosition",
          "name": "position",
          "type": "tuple"
        },
        {
          "internalType": "uint256",
          "name": "strikePrice",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "strikeExpiry",
          "type": "uint256"
        }
      ],
      "name": "getAllowedCloseAmount",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "closeAmount",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "id",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "expiry",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "strikePrice",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "skew",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "boardIv",
              "type": "uint256"
            }
          ],
          "internalType": "struct LyraAdapter.Strike",
          "name": "strike",
          "type": "tuple"
        }
      ],
      "name": "getRequiredCollateral",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "collateralToAdd",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "setCollateralTo",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "greekCache",
      "outputs": [
        {
          "internalType": "contract OptionGreekCache",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "gwavOracle",
      "outputs": [
        {
          "internalType": "contract GWAVOracle",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_lyraRegistry",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_optionMarket",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_curveSwap",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_feeCounter",
          "type": "address"
        }
      ],
      "name": "initAdapter",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "id",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "expiry",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "strikePrice",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "skew",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "boardIv",
              "type": "uint256"
            }
          ],
          "internalType": "struct LyraAdapter.Strike",
          "name": "strike",
          "type": "tuple"
        }
      ],
      "name": "isValidStrike",
      "outputs": [
        {
          "internalType": "bool",
          "name": "isValid",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "lastTradeTimestamp",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "liquidityPool",
      "outputs": [
        {
          "internalType": "contract LiquidityPool",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "lyraRegistry",
      "outputs": [
        {
          "internalType": "contract LyraRegistry",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "optionMarket",
      "outputs": [
        {
          "internalType": "contract OptionMarket",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "optionPricer",
      "outputs": [
        {
          "internalType": "contract OptionMarketPricer",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "optionToken",
      "outputs": [
        {
          "internalType": "contract OptionToken",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "optionType",
      "outputs": [
        {
          "internalType": "enum LyraAdapter.OptionType",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "quoteAsset",
      "outputs": [
        {
          "internalType": "contract IERC20",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "positionId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "closeAmount",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "lyraRewardRecipient",
          "type": "address"
        }
      ],
      "name": "reducePosition",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "returnFundsAndClearStrikes",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "boardId",
          "type": "uint256"
        }
      ],
      "name": "setBoard",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_lyraRegistry",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_optionMarket",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_curveSwap",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_feeCounter",
          "type": "address"
        }
      ],
      "name": "setLyraAddresses",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "minTimeToExpiry",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maxTimeToExpiry",
              "type": "uint256"
            },
            {
              "internalType": "int256",
              "name": "targetDelta",
              "type": "int256"
            },
            {
              "internalType": "uint256",
              "name": "maxDeltaGap",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "minVol",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maxVol",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "size",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "minTradeInterval",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maxVolVariance",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "gwavPeriod",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "collatBuffer",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "collatPercent",
              "type": "uint256"
            }
          ],
          "internalType": "struct DeltaShortStrategy.DeltaShortStrategyDetail",
          "name": "_deltaStrategy",
          "type": "tuple"
        }
      ],
      "name": "setStrategyDetail",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "shortCollateral",
      "outputs": [
        {
          "internalType": "contract ShortCollateral",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "strategyDetail",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "minTimeToExpiry",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "maxTimeToExpiry",
          "type": "uint256"
        },
        {
          "internalType": "int256",
          "name": "targetDelta",
          "type": "int256"
        },
        {
          "internalType": "uint256",
          "name": "maxDeltaGap",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "minVol",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "maxVol",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "size",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "minTradeInterval",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "maxVolVariance",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "gwavPeriod",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "collatBuffer",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "collatPercent",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "strikeToPositionId",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "updateDelegateApproval",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "vault",
      "outputs": [
        {
          "internalType": "contract LyraVault",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xf36393ec69350e5003ffa22fc1a6abbc7e484d4119c6e70fe6b4ad6ef15b4ed7",
  "receipt": {
    "to": null,
    "from": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
    "contractAddress": "0x9b75fa0c8baa2A05F0bA700D8D742CdABD5e2781",
    "transactionIndex": 0,
    "gasUsed": "4178162",
    "logsBloom": "0x00000000000000000200000000000080000000000000000000800000000000000004000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000020000000000000100000800000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000002000000000000000000020000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xd69c2e1cb3f817345ff73ac923afe0337970f8f2f6950a93d76f4af480ded6a4",
    "transactionHash": "0xf36393ec69350e5003ffa22fc1a6abbc7e484d4119c6e70fe6b4ad6ef15b4ed7",
    "logs": [
      {
        "transactionIndex": 0,
        "blockNumber": 4232009,
        "transactionHash": "0xf36393ec69350e5003ffa22fc1a6abbc7e484d4119c6e70fe6b4ad6ef15b4ed7",
        "address": "0x9b75fa0c8baa2A05F0bA700D8D742CdABD5e2781",
        "topics": [
          "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266"
        ],
        "data": "0x",
        "logIndex": 0,
        "blockHash": "0xd69c2e1cb3f817345ff73ac923afe0337970f8f2f6950a93d76f4af480ded6a4"
      }
    ],
    "blockNumber": 4232009,
    "cumulativeGasUsed": "4178162",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0xF7D044D582666634A03EC7083d7a4EE439FBcef7",
    4
  ],
  "numDeployments": 1,
  "solcInputHash": "80ed7d4eac10dd586e35c921f701831d",
  "metadata": "{\"compiler\":{\"version\":\"0.8.9+commit.e5eed63a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract LyraVault\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"enum LyraAdapter.OptionType\",\"name\":\"_optionType\",\"type\":\"uint8\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"thrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"baseExpected\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseReceived\",\"type\":\"uint256\"}],\"name\":\"ExchangerBaseReceivedTooLow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"thrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"quoteExpected\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quoteReceived\",\"type\":\"uint256\"}],\"name\":\"ExchangerQuoteReceivedTooLow\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"}],\"name\":\"_isValidExpiry\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isValid\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"strikeId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"secondsAgo\",\"type\":\"uint256\"}],\"name\":\"_optionPriceGWAV\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"callPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"putPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"activeExpiry\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"activeStrikeIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseAsset\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collateralAsset\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"curveSwap\",\"outputs\":[{\"internalType\":\"contract ICurve\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"strikeId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"lyraRewardRecipient\",\"type\":\"address\"}],\"name\":\"doTrade\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"premiumReceived\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralToAdd\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lyraRewardRecipient\",\"type\":\"address\"}],\"name\":\"emergencyCloseAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeCounter\",\"outputs\":[{\"internalType\":\"contract BasicFeeCounter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"strikeId\",\"type\":\"uint256\"},{\"internalType\":\"enum LyraAdapter.OptionType\",\"name\":\"optionType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateral\",\"type\":\"uint256\"},{\"internalType\":\"enum LyraAdapter.PositionState\",\"name\":\"state\",\"type\":\"uint8\"}],\"internalType\":\"struct LyraAdapter.OptionPosition\",\"name\":\"position\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"strikePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"strikeExpiry\",\"type\":\"uint256\"}],\"name\":\"getAllowedCloseAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"closeAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"strikePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"skew\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"boardIv\",\"type\":\"uint256\"}],\"internalType\":\"struct LyraAdapter.Strike\",\"name\":\"strike\",\"type\":\"tuple\"}],\"name\":\"getRequiredCollateral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"collateralToAdd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"setCollateralTo\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"greekCache\",\"outputs\":[{\"internalType\":\"contract OptionGreekCache\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gwavOracle\",\"outputs\":[{\"internalType\":\"contract GWAVOracle\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lyraRegistry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_optionMarket\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_curveSwap\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_feeCounter\",\"type\":\"address\"}],\"name\":\"initAdapter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"strikePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"skew\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"boardIv\",\"type\":\"uint256\"}],\"internalType\":\"struct LyraAdapter.Strike\",\"name\":\"strike\",\"type\":\"tuple\"}],\"name\":\"isValidStrike\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isValid\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lastTradeTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityPool\",\"outputs\":[{\"internalType\":\"contract LiquidityPool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lyraRegistry\",\"outputs\":[{\"internalType\":\"contract LyraRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"optionMarket\",\"outputs\":[{\"internalType\":\"contract OptionMarket\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"optionPricer\",\"outputs\":[{\"internalType\":\"contract OptionMarketPricer\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"optionToken\",\"outputs\":[{\"internalType\":\"contract OptionToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"optionType\",\"outputs\":[{\"internalType\":\"enum LyraAdapter.OptionType\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"quoteAsset\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"closeAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"lyraRewardRecipient\",\"type\":\"address\"}],\"name\":\"reducePosition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"returnFundsAndClearStrikes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"boardId\",\"type\":\"uint256\"}],\"name\":\"setBoard\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lyraRegistry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_optionMarket\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_curveSwap\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_feeCounter\",\"type\":\"address\"}],\"name\":\"setLyraAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"minTimeToExpiry\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTimeToExpiry\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"targetDelta\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"maxDeltaGap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minVol\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxVol\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minTradeInterval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxVolVariance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gwavPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collatBuffer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collatPercent\",\"type\":\"uint256\"}],\"internalType\":\"struct DeltaShortStrategy.DeltaShortStrategyDetail\",\"name\":\"_deltaStrategy\",\"type\":\"tuple\"}],\"name\":\"setStrategyDetail\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"shortCollateral\",\"outputs\":[{\"internalType\":\"contract ShortCollateral\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"strategyDetail\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"minTimeToExpiry\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTimeToExpiry\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"targetDelta\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"maxDeltaGap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minVol\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxVol\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minTradeInterval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxVolVariance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gwavPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collatBuffer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collatPercent\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"strikeToPositionId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateDelegateApproval\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"internalType\":\"contract LyraVault\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"_isValidExpiry(uint256)\":{\"details\":\"check if the expiry of the board is valid according to the strategy\"},\"doTrade(uint256,address)\":{\"details\":\"the vault should pass in a strike id, and the strategy would verify if the strike is valid on-chain.\",\"params\":{\"lyraRewardRecipient\":\"address to receive trading reward. This need to be whitelisted\",\"strikeId\":\"lyra strikeId to trade\"},\"returns\":{\"positionId\":\"positionId\",\"premiumReceived\":\"premiumReceived\"}},\"emergencyCloseAll(address)\":{\"details\":\"close all outstanding positions regardless of collat and send funds back to vault\"},\"getAllowedCloseAmount((uint256,uint256,uint8,uint256,uint256,uint8),uint256,uint256)\":{\"details\":\"calculates the position amount required to stay above the buffer collateral\"},\"getRequiredCollateral((uint256,uint256,uint256,uint256,uint256))\":{\"details\":\"calculate required collateral to add in the next trade. sell size is fixed as strategyDetail.size only add collateral if the additional sell will make the position out of buffer range never remove collateral from an existing position\"},\"isValidStrike((uint256,uint256,uint256,uint256,uint256))\":{\"details\":\"verify if the strike is valid for the strategy\",\"returns\":{\"isValid\":\"true if vol is withint [minVol, maxVol] and delta is within targetDelta +- maxDeltaGap\"}},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"reducePosition(uint256,uint256,address)\":{\"details\":\"use premium in strategy to reduce position size if collateral ratio is out of range\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.\"},\"returnFundsAndClearStrikes()\":{\"details\":\"convert premium in quote asset into collateral asset and send it back to the vault.\"},\"setBoard(uint256)\":{\"details\":\"set the board id that will be traded for the next round\",\"params\":{\"boardId\":\"lyra board Id.\"}},\"setLyraAddresses(address,address,address,address)\":{\"details\":\"Assigns all lyra contracts\",\"params\":{\"_curveSwap\":\"Curve pool address for swapping sUSD and other stables via `exchange_with_best_rate`\",\"_feeCounter\":\"Fee counter addressu used to determine Lyra trading rewards\",\"_lyraRegistry\":\"LyraRegistry address which holds latest market and global addressess\",\"_optionMarket\":\"OptionMarket address\"}},\"setStrategyDetail((uint256,uint256,int256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256))\":{\"details\":\"update the strategy detail for the new round.\"},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"_optionPriceGWAV(uint256,uint256)\":{\"notice\":\"the option price GWAV for a given `strikeId` with GWAV interval `secondsAgo`\"},\"doTrade(uint256,address)\":{\"notice\":\"sell a fix aomunt of options and collect premium\"},\"updateDelegateApproval()\":{\"notice\":\"In case of an update to the synthetix contract that revokes the approval\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/strategies/DeltaShortStrategy.sol\":\"DeltaShortStrategy\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1},\"remappings\":[]},\"sources\":{\"@lyrafinance/protocol/contracts/LiquidityPool.sol\":{\"content\":\"//SPDX-License-Identifier: ISC\\n\\npragma solidity 0.8.9;\\n\\n// Libraries\\nimport \\\"./synthetix/DecimalMath.sol\\\";\\n\\n// Inherited\\nimport \\\"./synthetix/Owned.sol\\\";\\nimport \\\"./libraries/SimpleInitializeable.sol\\\";\\nimport \\\"openzeppelin-contracts-4.4.1/security/ReentrancyGuard.sol\\\";\\n\\n// Interfaces\\nimport \\\"openzeppelin-contracts-4.4.1/token/ERC20/ERC20.sol\\\";\\nimport \\\"./LiquidityToken.sol\\\";\\nimport \\\"./OptionGreekCache.sol\\\";\\nimport \\\"./OptionMarket.sol\\\";\\nimport \\\"./libraries/PoolHedger.sol\\\";\\n\\n/**\\n * @title LiquidityPool\\n * @author Lyra\\n * @dev Holds funds from LPs, which are used for the following purposes:\\n * 1. Collateralizing options sold by the OptionMarket.\\n * 2. Buying options from users.\\n * 3. Delta hedging the LPs.\\n * 4. Storing funds for expired in the money options.\\n */\\ncontract LiquidityPool is Owned, SimpleInitializeable, ReentrancyGuard {\\n  using DecimalMath for uint;\\n\\n  struct Collateral {\\n    uint quote;\\n    uint base;\\n  }\\n\\n  /// These values are all in quoteAsset amounts.\\n  struct Liquidity {\\n    // Amount of liquidity available for option collateral and premiums\\n    uint freeLiquidity;\\n    // Amount of liquidity available for withdrawals - different to freeLiquidity\\n    uint burnableLiquidity;\\n    // Amount of liquidity reserved for long options sold to traders\\n    uint usedCollatLiquidity;\\n    // Portion of liquidity reserved for delta hedging (quote outstanding)\\n    uint pendingDeltaLiquidity;\\n    // Current value of delta hedge\\n    uint usedDeltaLiquidity;\\n    // Net asset value, including everything and netOptionValue\\n    uint NAV;\\n  }\\n\\n  struct QueuedDeposit {\\n    uint id;\\n    // Who will receive the LiquidityToken minted for this deposit after the wait time\\n    address beneficiary;\\n    // The amount of quoteAsset deposited to be converted to LiquidityToken after wait time\\n    uint amountLiquidity;\\n    // The amount of LiquidityToken minted. Will equal to 0 if not processed\\n    uint mintedTokens;\\n    uint depositInitiatedTime;\\n  }\\n\\n  struct QueuedWithdrawal {\\n    uint id;\\n    // Who will receive the quoteAsset returned after burning the LiquidityToken\\n    address beneficiary;\\n    // The amount of LiquidityToken being burnt after the wait time\\n    uint amountTokens;\\n    // The amount of quote transferred. Will equal to 0 if process not started\\n    uint quoteSent;\\n    uint withdrawInitiatedTime;\\n  }\\n\\n  struct LiquidityPoolParameters {\\n    // The minimum amount of quoteAsset for a deposit, or the amount of LiquidityToken for a withdrawal\\n    uint minDepositWithdraw;\\n    // Time between initiating a deposit and when it can be processed\\n    uint depositDelay;\\n    // Time between initiating a withdrawal and when it can be processed\\n    uint withdrawalDelay;\\n    // Fee charged on withdrawn funds\\n    uint withdrawalFee;\\n    // Percentage of NAV below which the liquidity CB fires\\n    uint liquidityCBThreshold;\\n    // Length of time after the liq. CB stops firing during which deposits/withdrawals are still blocked\\n    uint liquidityCBTimeout;\\n    // Difference between the spot and GWAV baseline IVs after which point the vol CB will fire\\n    uint ivVarianceCBThreshold;\\n    // Difference between the spot and GWAV skew ratios after which point the vol CB will fire\\n    uint skewVarianceCBThreshold;\\n    // Length of time after the (base) vol. CB stops firing during which deposits/withdrawals are still blocked\\n    uint ivVarianceCBTimeout;\\n    // Length of time after the (skew) vol. CB stops firing during which deposits/withdrawals are still blocked\\n    uint skewVarianceCBTimeout;\\n    // The address of the \\\"guardian\\\"\\n    address guardianMultisig;\\n    // Length of time a deposit/withdrawal since initiation for before a guardian can force process their transaction\\n    uint guardianDelay;\\n    // When a new board is listed, block deposits/withdrawals\\n    uint boardSettlementCBTimeout;\\n    // When exchanging, don't exchange if fee is above this value\\n    uint maxFeePaid;\\n  }\\n\\n  SynthetixAdapter internal synthetixAdapter;\\n  OptionMarket internal optionMarket;\\n  LiquidityToken internal liquidityToken;\\n  ShortCollateral internal shortCollateral;\\n  OptionGreekCache internal greekCache;\\n  PoolHedger public poolHedger;\\n  ERC20 internal quoteAsset;\\n  ERC20 internal baseAsset;\\n\\n  mapping(uint => QueuedDeposit) public queuedDeposits;\\n  /// @dev The total amount of quoteAsset pending deposit (that hasn't entered the pool)\\n  uint public totalQueuedDeposits = 0;\\n\\n  /// @dev The next queue item that needs to be processed\\n  uint public queuedDepositHead = 1;\\n  uint public nextQueuedDepositId = 1;\\n\\n  mapping(uint => QueuedWithdrawal) public queuedWithdrawals;\\n  uint public totalQueuedWithdrawals = 0;\\n\\n  /// @dev The next queue item that needs to be processed\\n  uint public queuedWithdrawalHead = 1;\\n  uint public nextQueuedWithdrawalId = 1;\\n\\n  /// @dev Parameters relating to depositing and withdrawing from the Lyra LP\\n  LiquidityPoolParameters public lpParams;\\n\\n  // timestamp for when deposits/withdrawals will be available to deposit/withdraw\\n  // This checks if liquidity is all used - adds 3 days to block.timestamp if it is\\n  // This also checks if vol variance is high - adds 12 hrs to block.timestamp if it is\\n  uint public CBTimestamp = 0;\\n\\n  ////\\n  // Other Variables\\n  ////\\n  /// @dev Amount of collateral locked for outstanding calls and puts sold to users\\n  Collateral public lockedCollateral;\\n  /// @dev Total amount of quoteAsset reserved for all settled options that have yet to be paid out\\n  uint public totalOutstandingSettlements;\\n\\n  /// @dev Total value not transferred to this contract for all shorts that didn't have enough collateral after expiry\\n  uint public insolventSettlementAmount;\\n  /// @dev Total value not transferred to this contract for all liquidations that didn't have enough collateral when liquidated\\n  uint public liquidationInsolventAmount;\\n\\n  ///////////\\n  // Setup //\\n  ///////////\\n\\n  constructor() Owned() {}\\n\\n  /// @dev Initialise important addresses for the contract\\n  function init(\\n    SynthetixAdapter _synthetixAdapter,\\n    OptionMarket _optionMarket,\\n    LiquidityToken _liquidityToken,\\n    OptionGreekCache _greekCache,\\n    PoolHedger _poolHedger,\\n    ShortCollateral _shortCollateral,\\n    ERC20 _quoteAsset,\\n    ERC20 _baseAsset\\n  ) external onlyOwner initializer {\\n    synthetixAdapter = _synthetixAdapter;\\n    optionMarket = _optionMarket;\\n    liquidityToken = _liquidityToken;\\n    greekCache = _greekCache;\\n    shortCollateral = _shortCollateral;\\n    poolHedger = _poolHedger;\\n    quoteAsset = _quoteAsset;\\n    baseAsset = _baseAsset;\\n    synthetixAdapter.delegateApprovals().approveExchangeOnBehalf(address(synthetixAdapter));\\n  }\\n\\n  ///////////\\n  // Admin //\\n  ///////////\\n\\n  /// @notice set `LiquidityPoolParameteres`\\n  function setLiquidityPoolParameters(LiquidityPoolParameters memory _lpParams) external onlyOwner {\\n    if (\\n      !(_lpParams.depositDelay < 365 days &&\\n        _lpParams.withdrawalDelay < 365 days &&\\n        _lpParams.withdrawalFee < 2e17 &&\\n        _lpParams.liquidityCBThreshold < 1e18 &&\\n        _lpParams.liquidityCBTimeout < 60 days &&\\n        _lpParams.ivVarianceCBTimeout < 60 days &&\\n        _lpParams.skewVarianceCBTimeout < 60 days &&\\n        _lpParams.guardianDelay < 365 days &&\\n        _lpParams.boardSettlementCBTimeout < 10 days)\\n    ) {\\n      revert InvalidLiquidityPoolParameters(address(this), _lpParams);\\n    }\\n\\n    lpParams = _lpParams;\\n\\n    emit LiquidityPoolParametersUpdated(lpParams);\\n  }\\n\\n  /// @dev Swap out current PoolHedger with a new contract\\n  function setPoolHedger(PoolHedger newPoolHedger) external onlyOwner {\\n    poolHedger = newPoolHedger;\\n    emit PoolHedgerUpdated(poolHedger);\\n  }\\n\\n  /// @dev In case of an update to the synthetix contract that revokes the approval\\n  function updateDelegateApproval() external onlyOwner {\\n    synthetixAdapter.delegateApprovals().approveExchangeOnBehalf(address(synthetixAdapter));\\n  }\\n\\n  //////////////////////////////\\n  // Deposits and Withdrawals //\\n  //////////////////////////////\\n\\n  /**\\n   * @notice LP will send sUSD into the contract in return for LiquidityToken (representative of their share of the entire pool)\\n   *         to be given either instantly (if no live boards) or after the delay period passes (including CBs).\\n   *         This action is not reversible.\\n   *\\n   * @param beneficiary will receive the LiquidityToken after the deposit is processed\\n   * @param amountQuote is the amount of sUSD the LP is depositing\\n   */\\n  function initiateDeposit(address beneficiary, uint amountQuote) external nonReentrant {\\n    if (beneficiary == address(0)) {\\n      revert InvalidBeneficiaryAddress(address(this), beneficiary);\\n    }\\n    if (amountQuote < lpParams.minDepositWithdraw) {\\n      revert MinimumDepositNotMet(address(this), amountQuote, lpParams.minDepositWithdraw);\\n    }\\n    if (optionMarket.getNumLiveBoards() == 0) {\\n      uint tokenPrice = getTokenPrice();\\n      uint amountTokens = amountQuote.divideDecimal(tokenPrice);\\n      liquidityToken.mint(beneficiary, amountTokens);\\n      emit DepositProcessed(msg.sender, beneficiary, 0, amountQuote, tokenPrice, amountTokens, block.timestamp);\\n    } else {\\n      QueuedDeposit storage newDeposit = queuedDeposits[nextQueuedDepositId];\\n\\n      newDeposit.id = nextQueuedDepositId++;\\n      newDeposit.beneficiary = beneficiary;\\n      newDeposit.amountLiquidity = amountQuote;\\n      newDeposit.depositInitiatedTime = block.timestamp;\\n\\n      totalQueuedDeposits += amountQuote;\\n\\n      emit DepositQueued(msg.sender, beneficiary, newDeposit.id, amountQuote, totalQueuedDeposits, block.timestamp);\\n    }\\n\\n    if (!quoteAsset.transferFrom(msg.sender, address(this), amountQuote)) {\\n      revert QuoteTransferFailed(address(this), msg.sender, address(this), amountQuote);\\n    }\\n  }\\n\\n  /**\\n   * @notice LP instantly burns LiquidityToken, signalling they wish to withdraw\\n   *         their share of the pool in exchange for quote, to be processed instantly (if no live boards)\\n   *         or after the delay period passes (including CBs).\\n   *         This action is not reversible.\\n   *\\n   *\\n   * @param beneficiary will receive sUSD after the withdrawal is processed\\n   * @param amountLiquidityToken: is the amount of LiquidityToken the LP is withdrawing\\n   */\\n  function initiateWithdraw(address beneficiary, uint amountLiquidityToken) external nonReentrant {\\n    if (beneficiary == address(0)) {\\n      revert InvalidBeneficiaryAddress(address(this), beneficiary);\\n    }\\n    if (amountLiquidityToken < lpParams.minDepositWithdraw) {\\n      revert MinimumWithdrawNotMet(address(this), amountLiquidityToken, lpParams.minDepositWithdraw);\\n    }\\n    if (optionMarket.getNumLiveBoards() == 0) {\\n      uint tokenPrice = getTokenPrice();\\n      uint quoteReceived = amountLiquidityToken.multiplyDecimal(tokenPrice);\\n      _transferQuote(beneficiary, quoteReceived);\\n      emit WithdrawProcessed(\\n        msg.sender,\\n        beneficiary,\\n        0,\\n        amountLiquidityToken,\\n        tokenPrice,\\n        quoteReceived,\\n        totalQueuedWithdrawals,\\n        block.timestamp\\n      );\\n    } else {\\n      QueuedWithdrawal storage newWithdrawal = queuedWithdrawals[nextQueuedWithdrawalId];\\n\\n      newWithdrawal.id = nextQueuedWithdrawalId++;\\n      newWithdrawal.beneficiary = beneficiary;\\n      newWithdrawal.amountTokens = amountLiquidityToken;\\n      newWithdrawal.withdrawInitiatedTime = block.timestamp;\\n\\n      totalQueuedWithdrawals += amountLiquidityToken;\\n\\n      emit WithdrawQueued(\\n        msg.sender,\\n        beneficiary,\\n        newWithdrawal.id,\\n        amountLiquidityToken,\\n        totalQueuedWithdrawals,\\n        block.timestamp\\n      );\\n    }\\n    liquidityToken.burn(msg.sender, amountLiquidityToken);\\n  }\\n\\n  /// @param limit number of deposit tickets to process in a single transaction to avoid gas limit soft-locks\\n  function processDepositQueue(uint limit) external nonReentrant {\\n    (uint tokenPrice, bool stale, ) = _getTokenPriceAndStale();\\n\\n    for (uint i = 0; i < limit; i++) {\\n      QueuedDeposit storage current = queuedDeposits[queuedDepositHead];\\n      if (!_canProcess(current.depositInitiatedTime, lpParams.depositDelay, stale, queuedDepositHead)) {\\n        return;\\n      }\\n\\n      uint amountTokens = current.amountLiquidity.divideDecimal(tokenPrice);\\n      liquidityToken.mint(current.beneficiary, amountTokens);\\n      current.mintedTokens = amountTokens;\\n      totalQueuedDeposits -= current.amountLiquidity;\\n\\n      emit DepositProcessed(\\n        msg.sender,\\n        current.beneficiary,\\n        queuedDepositHead,\\n        current.amountLiquidity,\\n        tokenPrice,\\n        amountTokens,\\n        block.timestamp\\n      );\\n      current.amountLiquidity = 0;\\n\\n      queuedDepositHead++;\\n    }\\n  }\\n\\n  /// @param limit number of withdrawal tickets to process in a single transaction to avoid gas limit soft-locks\\n  function processWithdrawalQueue(uint limit) external nonReentrant {\\n    for (uint i = 0; i < limit; i++) {\\n      (uint totalTokensBurnable, uint tokenPriceWithFee, bool stale) = _getTotalBurnableTokens();\\n\\n      QueuedWithdrawal storage current = queuedWithdrawals[queuedWithdrawalHead];\\n\\n      if (!_canProcess(current.withdrawInitiatedTime, lpParams.withdrawalDelay, stale, queuedWithdrawalHead)) {\\n        return;\\n      }\\n\\n      if (totalTokensBurnable == 0) {\\n        return;\\n      }\\n\\n      uint burnAmount = current.amountTokens;\\n      if (burnAmount > totalTokensBurnable) {\\n        burnAmount = totalTokensBurnable;\\n      }\\n\\n      current.amountTokens -= burnAmount;\\n      totalQueuedWithdrawals -= burnAmount;\\n\\n      uint quoteAmount = burnAmount.multiplyDecimal(tokenPriceWithFee);\\n      current.quoteSent += quoteAmount;\\n      _transferQuote(current.beneficiary, quoteAmount);\\n      if (current.amountTokens > 0) {\\n        emit WithdrawPartiallyProcessed(\\n          msg.sender,\\n          current.beneficiary,\\n          queuedWithdrawalHead,\\n          burnAmount,\\n          tokenPriceWithFee,\\n          quoteAmount,\\n          totalQueuedWithdrawals,\\n          block.timestamp\\n        );\\n        return;\\n      }\\n      emit WithdrawProcessed(\\n        msg.sender,\\n        current.beneficiary,\\n        queuedWithdrawalHead,\\n        burnAmount,\\n        tokenPriceWithFee,\\n        quoteAmount,\\n        totalQueuedWithdrawals,\\n        block.timestamp\\n      );\\n      queuedWithdrawalHead++;\\n    }\\n  }\\n\\n  /// @dev Checks if deposit/withdrawal ticket can be processed\\n  function _canProcess(\\n    uint initiatedTime,\\n    uint minimumDelay,\\n    bool isStale,\\n    uint entryId\\n  ) internal returns (bool) {\\n    bool validEntry = initiatedTime != 0;\\n    // bypass circuit breaker and stale checks if the guardian is calling and their delay has passed\\n    bool guardianBypass = msg.sender == lpParams.guardianMultisig &&\\n      initiatedTime + lpParams.guardianDelay < block.timestamp;\\n    // if minimum delay or circuit breaker timeout hasn't passed, we can't process\\n    bool delaysExpired = initiatedTime + minimumDelay < block.timestamp && CBTimestamp < block.timestamp;\\n\\n    emit CheckingCanProcess(entryId, !isStale, validEntry, guardianBypass, delaysExpired);\\n\\n    return validEntry && ((!isStale && delaysExpired) || guardianBypass);\\n  }\\n\\n  function _getTotalBurnableTokens()\\n    internal\\n    returns (\\n      uint tokensBurnable,\\n      uint tokenPriceWithFee,\\n      bool stale\\n    )\\n  {\\n    uint burnableLiquidity;\\n    uint tokenPrice;\\n    (tokenPrice, stale, burnableLiquidity) = _getTokenPriceAndStale();\\n\\n    if (optionMarket.getNumLiveBoards() != 0) {\\n      tokenPriceWithFee = tokenPrice.multiplyDecimal(DecimalMath.UNIT - lpParams.withdrawalFee);\\n    } else {\\n      tokenPriceWithFee = tokenPrice;\\n    }\\n\\n    return (burnableLiquidity.divideDecimal(tokenPriceWithFee), tokenPriceWithFee, stale);\\n  }\\n\\n  function _getTokenPriceAndStale()\\n    internal\\n    returns (\\n      uint tokenPrice,\\n      bool,\\n      uint burnableLiquidity\\n    )\\n  {\\n    uint spotPrice = synthetixAdapter.getSpotPriceForMarket(address(optionMarket));\\n\\n    OptionGreekCache.GlobalCache memory globalCache = greekCache.getGlobalCache();\\n    bool stale = greekCache.isGlobalCacheStale(spotPrice);\\n\\n    (uint pendingDelta, uint usedDelta) = _getPoolHedgerLiquidity(spotPrice);\\n\\n    uint totalPoolValue = _getTotalPoolValueQuote(spotPrice, usedDelta, globalCache.netGreeks.netOptionValue);\\n    uint totalTokenSupply = getTotalTokenSupply();\\n    tokenPrice = _getTokenPrice(totalPoolValue, totalTokenSupply);\\n\\n    uint queuedTokenValue = tokenPrice.multiplyDecimal(totalQueuedWithdrawals);\\n\\n    Liquidity memory liquidity = _getLiquidity(spotPrice, totalPoolValue, queuedTokenValue, usedDelta, pendingDelta);\\n\\n    _updateCBs(liquidity, globalCache.maxIvVariance, globalCache.maxSkewVariance, globalCache.netGreeks.netOptionValue);\\n\\n    return (tokenPrice, stale, liquidity.burnableLiquidity);\\n  }\\n\\n  //////////////////////\\n  // Circuit Breakers //\\n  //////////////////////\\n\\n  /// @notice Checks the ivVariance, skewVariance, and liquidity circuit breakers and triggers if necessary\\n  function updateCBs() external nonReentrant {\\n    uint spotPrice = synthetixAdapter.getSpotPriceForMarket(address(optionMarket));\\n    OptionGreekCache.GlobalCache memory globalCache = greekCache.getGlobalCache();\\n    Liquidity memory liquidity = getLiquidity(spotPrice);\\n    _updateCBs(liquidity, globalCache.maxIvVariance, globalCache.maxSkewVariance, globalCache.netGreeks.netOptionValue);\\n  }\\n\\n  function _updateCBs(\\n    Liquidity memory liquidity,\\n    uint maxIvVariance,\\n    uint maxSkewVariance,\\n    int optionValueDebt\\n  ) internal {\\n    // don't trigger CBs if pool has no open options\\n    if (liquidity.usedCollatLiquidity == 0 && optionValueDebt == 0) {\\n      return;\\n    }\\n\\n    uint timeToAdd = 0;\\n\\n    // if NAV == 0, openAmount will be zero too and _updateCB() won't be called.\\n    uint freeLiquidityPercent = liquidity.freeLiquidity.divideDecimal(liquidity.NAV);\\n\\n    bool ivVarianceThresholdCrossed = maxIvVariance > lpParams.ivVarianceCBThreshold;\\n    bool skewVarianceThresholdCrossed = maxSkewVariance > lpParams.skewVarianceCBThreshold;\\n    bool liquidityThresholdCrossed = freeLiquidityPercent < lpParams.liquidityCBThreshold;\\n\\n    if (ivVarianceThresholdCrossed) {\\n      timeToAdd = lpParams.ivVarianceCBTimeout;\\n    }\\n\\n    if (skewVarianceThresholdCrossed && lpParams.skewVarianceCBTimeout > timeToAdd) {\\n      timeToAdd = lpParams.skewVarianceCBTimeout;\\n    }\\n\\n    if (liquidityThresholdCrossed && lpParams.liquidityCBTimeout > timeToAdd) {\\n      timeToAdd = lpParams.liquidityCBTimeout;\\n    }\\n\\n    if (timeToAdd > 0 && CBTimestamp < block.timestamp + timeToAdd) {\\n      CBTimestamp = block.timestamp + timeToAdd;\\n      emit CircuitBreakerUpdated(\\n        CBTimestamp,\\n        ivVarianceThresholdCrossed,\\n        skewVarianceThresholdCrossed,\\n        liquidityThresholdCrossed\\n      );\\n    }\\n  }\\n\\n  ///////////////////////\\n  // Only OptionMarket //\\n  ///////////////////////\\n\\n  /**\\n   * @notice Locks quote as collateral when the AMM sells a put option.\\n   *\\n   * @param amount The amount of quote to lock.\\n   * @param freeLiquidity The amount of free collateral that can be locked.\\n   */\\n  function lockQuote(uint amount, uint freeLiquidity) external onlyOptionMarket {\\n    if (amount > freeLiquidity) {\\n      revert LockingMoreQuoteThanIsFree(address(this), amount, freeLiquidity, lockedCollateral);\\n    }\\n    lockedCollateral.quote += amount;\\n    emit QuoteLocked(amount, lockedCollateral.quote);\\n  }\\n\\n  /**\\n   * @notice Purchases and locks base as collateral when the AMM sells a call option.\\n   *\\n   * @param amount The amount of baseAsset to purchase and lock.\\n   * @param exchangeParams The exchangeParams.\\n   * @param freeLiquidity The amount of free collateral that can be locked.\\n   */\\n  function lockBase(\\n    uint amount,\\n    SynthetixAdapter.ExchangeParams memory exchangeParams,\\n    uint freeLiquidity\\n  ) external onlyOptionMarket {\\n    lockedCollateral.base += amount;\\n    _maybeExchangeBase(exchangeParams, freeLiquidity, true);\\n    emit BaseLocked(amount, lockedCollateral.base);\\n  }\\n\\n  /**\\n   * @notice Frees quote collateral when user closes a long put\\n   *         and sends them the option premium\\n   *\\n   * @param amountQuoteFreed The amount of quote to free.\\n   */\\n  function freeQuoteCollateralAndSendPremium(\\n    uint amountQuoteFreed,\\n    address recipient,\\n    uint totalCost,\\n    uint reservedFee\\n  ) external onlyOptionMarket {\\n    _freeQuoteCollateral(amountQuoteFreed);\\n    _sendPremium(recipient, totalCost, reservedFee);\\n  }\\n\\n  /**\\n   * @notice Frees/exchange base collateral when user closes a long call\\n   *         and sends the option premium to the user\\n   *\\n   * @param amountBase The amount of base to free and exchange.\\n   */\\n  function liquidateBaseAndSendPremium(\\n    uint amountBase,\\n    address recipient,\\n    uint totalCost,\\n    uint reservedFee\\n  ) external onlyOptionMarket {\\n    _freeBase(amountBase);\\n    exchangeBase();\\n    _sendPremium(recipient, totalCost, reservedFee);\\n  }\\n\\n  /**\\n   * @notice Sends premium user selling an option to the pool.\\n   * @dev The caller must be the OptionMarket.\\n   *\\n   * @param recipient The address of the recipient.\\n   * @param premium The amount to transfer to the user.\\n   * @param freeLiquidity The amount of free collateral liquidity.\\n   * @param reservedFee The amount collected by the OptionMarket.\\n   */\\n  function sendShortPremium(\\n    address recipient,\\n    uint premium,\\n    uint freeLiquidity,\\n    uint reservedFee\\n  ) external onlyOptionMarket {\\n    if (premium + reservedFee > freeLiquidity) {\\n      revert SendPremiumNotEnoughCollateral(address(this), premium, reservedFee, freeLiquidity);\\n    }\\n    _sendPremium(recipient, premium, reservedFee);\\n  }\\n\\n  /**\\n   * @notice Manages collateral at the time of board liquidation, also converting base received from shortCollateral.\\n   *\\n   * @param insolventSettlements amount of AMM profits not paid by shortCollateral due to user insolvencies.\\n   * @param amountQuoteFreed amount of AMM long put quote collateral that can be freed, including ITM profits.\\n   * @param amountQuoteReserved amount of AMM quote reserved for long call/put ITM profits.\\n   * @param amountBaseFreed amount of AMM long call base collateral that can be freed, including ITM profits.\\n   */\\n  function boardSettlement(\\n    uint insolventSettlements,\\n    uint amountQuoteFreed,\\n    uint amountQuoteReserved,\\n    uint amountBaseFreed\\n  ) external onlyOptionMarket {\\n    // Update circuit breaker whenever a board is settled, to pause deposits/withdrawals\\n    // This allows keepers some time to settle insolvent positions\\n    if (block.timestamp + lpParams.boardSettlementCBTimeout > CBTimestamp) {\\n      CBTimestamp = block.timestamp + lpParams.boardSettlementCBTimeout;\\n      emit BoardSettlementCircuitBreakerUpdated(CBTimestamp);\\n    }\\n\\n    insolventSettlementAmount += insolventSettlements;\\n\\n    _freeQuoteCollateral(amountQuoteFreed);\\n    _freeBase(amountBaseFreed);\\n\\n    totalOutstandingSettlements += amountQuoteReserved;\\n    emit BoardSettlement(insolventSettlementAmount, amountQuoteReserved, totalOutstandingSettlements);\\n\\n    if (address(poolHedger) != address(0)) {\\n      poolHedger.resetInteractionDelay();\\n    }\\n  }\\n\\n  /**\\n   * @notice Frees quote when the AMM buys back/settles a put from the user.\\n   * @param amountQuote The amount of quote to free.\\n   */\\n  function _freeQuoteCollateral(uint amountQuote) internal {\\n    // In case of rounding errors\\n    amountQuote = amountQuote > lockedCollateral.quote ? lockedCollateral.quote : amountQuote;\\n    lockedCollateral.quote -= amountQuote;\\n    emit QuoteFreed(amountQuote, lockedCollateral.quote);\\n  }\\n\\n  /**\\n   * @notice Frees base when the AMM buys back/settles a call from the user.\\n   * @param amountBase The amount of base to free.\\n   */\\n\\n  function _freeBase(uint amountBase) internal {\\n    // In case of rounding errors\\n    amountBase = amountBase > lockedCollateral.base ? lockedCollateral.base : amountBase;\\n    lockedCollateral.base -= amountBase;\\n    emit BaseFreed(amountBase, lockedCollateral.base);\\n  }\\n\\n  /**\\n   * @notice Sends the premium to a user who is closing a long or opening a short.\\n   * @dev The caller must be the OptionMarket.\\n   *\\n   * @param recipient The address of the recipient.\\n   * @param recipientAmount The amount to transfer to the recipient.\\n   * @param optionMarketPortion The fee to transfer to the optionMarket.\\n   */\\n  function _sendPremium(\\n    address recipient,\\n    uint recipientAmount,\\n    uint optionMarketPortion\\n  ) internal {\\n    _transferQuote(recipient, recipientAmount);\\n    _transferQuote(address(optionMarket), optionMarketPortion);\\n\\n    emit PremiumTransferred(recipient, recipientAmount, optionMarketPortion);\\n  }\\n\\n  //////////////////////////\\n  // Only ShortCollateral //\\n  //////////////////////////\\n\\n  /**\\n   * @notice Transfers long option settlement profits to `user`.\\n   * @dev The caller must be the ShortCollateral.\\n   *\\n   * @param user The address of the user to send the quote.\\n   * @param amount The amount of quote to send.\\n   */\\n  function sendSettlementValue(address user, uint amount) external onlyShortCollateral {\\n    // To prevent any potential rounding errors\\n    if (amount > totalOutstandingSettlements) {\\n      amount = totalOutstandingSettlements;\\n    }\\n    totalOutstandingSettlements -= amount;\\n    _transferQuote(user, amount);\\n\\n    emit OutstandingSettlementSent(user, amount, totalOutstandingSettlements);\\n  }\\n\\n  /**\\n   * @notice Claims AMM profits that were not paid during boardSettlement() due to\\n   * total quote insolvencies > total solvent quote collateral.\\n   * @dev The caller must be ShortCollateral.\\n   *\\n   * @param spotPrice The current spot price of the base asset.\\n   * @param amountQuote The amount of quote to send to the LiquidityPool.\\n   */\\n  function reclaimInsolventQuote(uint spotPrice, uint amountQuote) external onlyShortCollateral {\\n    Liquidity memory liquidity = getLiquidity(spotPrice);\\n    if (amountQuote > liquidity.freeLiquidity) {\\n      revert NotEnoughFreeToReclaimInsolvency(address(this), amountQuote, liquidity);\\n    }\\n    _transferQuote(address(shortCollateral), amountQuote);\\n\\n    insolventSettlementAmount += amountQuote;\\n\\n    emit InsolventSettlementAmountUpdated(amountQuote, insolventSettlementAmount);\\n  }\\n\\n  /**\\n   * @notice Claims AMM profits that were not paid during boardSettlement() due to\\n   * total base insolvencies > total solvent base collateral.\\n   * @dev The caller must be ShortCollateral.\\n   *\\n   * @param exchangeParams synthetix exchange parameters.\\n   * @param amountBase The amount of base to send to the LiquidityPool.\\n   */\\n\\n  function reclaimInsolventBase(SynthetixAdapter.ExchangeParams memory exchangeParams, uint amountBase)\\n    external\\n    onlyShortCollateral\\n  {\\n    Liquidity memory liquidity = getLiquidity(exchangeParams.spotPrice);\\n    (uint quoteSpent, ) = synthetixAdapter.exchangeToExactBaseWithLimit(\\n      exchangeParams,\\n      address(optionMarket),\\n      amountBase,\\n      liquidity.freeLiquidity\\n    );\\n    insolventSettlementAmount += quoteSpent;\\n    // It is better for the contract to revert if there is not enough here (due to rounding) to keep accounting in\\n    // ShortCollateral correct. baseAsset can be donated (sent) to this contract to allow this to pass.\\n    if (!baseAsset.transfer(address(shortCollateral), amountBase)) {\\n      revert BaseTransferFailed(address(this), address(this), address(shortCollateral), amountBase);\\n    }\\n\\n    emit InsolventSettlementAmountUpdated(quoteSpent, insolventSettlementAmount);\\n  }\\n\\n  //////////////////////////////\\n  // Getting Pool Token Value //\\n  //////////////////////////////\\n\\n  /// @dev Get total number of oustanding LiquidityToken\\n  function getTotalTokenSupply() public view returns (uint) {\\n    return liquidityToken.totalSupply() + totalQueuedWithdrawals;\\n  }\\n\\n  /// @dev Get current pool token price\\n  function getTokenPrice() public view returns (uint) {\\n    return _getTokenPrice(getTotalPoolValueQuote(), getTotalTokenSupply());\\n  }\\n\\n  function _getTokenPrice(uint totalPoolValue, uint totalTokenSupply) internal pure returns (uint) {\\n    if (totalTokenSupply == 0) {\\n      return 1e18;\\n    }\\n\\n    return totalPoolValue.divideDecimal(totalTokenSupply);\\n  }\\n\\n  ////////////////////////////\\n  // Getting Pool Liquidity //\\n  ////////////////////////////\\n\\n  /// @notice Returns the breakdown of current liquidity usage\\n  function getCurrentLiquidity() external view returns (Liquidity memory) {\\n    uint spotPrice = synthetixAdapter.getSpotPriceForMarket(address(optionMarket));\\n    return getLiquidity(spotPrice);\\n  }\\n\\n  /**\\n   * @notice Same return as `getCurrentLiquidity()` but with manual spot price\\n   */\\n  function getLiquidity(uint spotPrice) public view returns (Liquidity memory) {\\n    // if cache is stale, pendingDelta may be inaccurate\\n    (uint pendingDelta, uint usedDelta) = _getPoolHedgerLiquidity(spotPrice);\\n    int optionValueDebt = greekCache.getGlobalOptionValue();\\n    uint totalPoolValue = _getTotalPoolValueQuote(spotPrice, usedDelta, optionValueDebt);\\n    uint tokenPrice = _getTokenPrice(totalPoolValue, getTotalTokenSupply());\\n\\n    return\\n      _getLiquidity(\\n        spotPrice,\\n        totalPoolValue,\\n        tokenPrice.multiplyDecimal(totalQueuedWithdrawals),\\n        usedDelta,\\n        pendingDelta\\n      );\\n  }\\n\\n  /// @dev Gets the current NAV\\n  function getTotalPoolValueQuote() public view returns (uint) {\\n    uint spotPrice = synthetixAdapter.getSpotPriceForMarket(address(optionMarket));\\n    int optionValueDebt = greekCache.getGlobalOptionValue();\\n    (, uint usedDelta) = _getPoolHedgerLiquidity(spotPrice);\\n\\n    return _getTotalPoolValueQuote(spotPrice, usedDelta, optionValueDebt);\\n  }\\n\\n  function _getTotalPoolValueQuote(\\n    uint basePrice,\\n    uint usedDeltaLiquidity,\\n    int optionValueDebt\\n  ) internal view returns (uint) {\\n    int totalAssetValue = SafeCast.toInt256(\\n      quoteAsset.balanceOf(address(this)) +\\n        baseAsset.balanceOf(address(this)).multiplyDecimal(basePrice) +\\n        usedDeltaLiquidity -\\n        totalOutstandingSettlements -\\n        totalQueuedDeposits\\n    );\\n\\n    // Should not be possible due to being fully collateralised\\n    if (optionValueDebt > totalAssetValue) {\\n      revert OptionValueDebtExceedsTotalAssets(address(this), totalAssetValue, optionValueDebt);\\n    }\\n\\n    return uint(totalAssetValue - optionValueDebt);\\n  }\\n\\n  /**\\n   * @dev Calculates breakdown of LP liquidity usage.\\n   *      Accounts for quote needed to buy/lock base in cases where pool is not fully collateralized.\\n   *      PendingLiquidity never exceeds freeLiquidity (before pendingLiquidity is considered).\\n   */\\n  function _getLiquidity(\\n    uint basePrice,\\n    uint totalPoolValue,\\n    uint reservedTokenValue,\\n    uint usedDelta,\\n    uint pendingDelta\\n  ) internal view returns (Liquidity memory) {\\n    Liquidity memory liquidity;\\n    liquidity.NAV = totalPoolValue;\\n    liquidity.usedDeltaLiquidity = usedDelta;\\n    uint baseBalance = baseAsset.balanceOf(address(this));\\n\\n    liquidity.usedCollatLiquidity = lockedCollateral.quote;\\n    uint pendingBaseValue;\\n    if (baseBalance > lockedCollateral.base) {\\n      liquidity.usedCollatLiquidity += baseBalance.multiplyDecimal(basePrice);\\n    } else {\\n      liquidity.usedCollatLiquidity += lockedCollateral.base.multiplyDecimal(basePrice);\\n      pendingBaseValue = (lockedCollateral.base - baseBalance).multiplyDecimal(basePrice);\\n    }\\n\\n    uint usedQuote = totalOutstandingSettlements + totalQueuedDeposits + lockedCollateral.quote + pendingBaseValue;\\n    uint totalQuote = quoteAsset.balanceOf(address(this));\\n\\n    uint availableQuote = totalQuote > usedQuote ? totalQuote - usedQuote : 0;\\n\\n    liquidity.pendingDeltaLiquidity = availableQuote > pendingDelta ? pendingDelta : availableQuote;\\n\\n    liquidity.freeLiquidity = availableQuote > (pendingDelta + reservedTokenValue)\\n      ? availableQuote - (pendingDelta + reservedTokenValue)\\n      : 0;\\n\\n    liquidity.burnableLiquidity = availableQuote - liquidity.pendingDeltaLiquidity;\\n\\n    return liquidity;\\n  }\\n\\n  /////////////////////\\n  // Exchanging Base //\\n  /////////////////////\\n\\n  /// @notice Will buy/sell and lock/free base if pool is under or over collateralized\\n  function exchangeBase() public nonReentrant {\\n    SynthetixAdapter.ExchangeParams memory exchangeParams = synthetixAdapter.getExchangeParams(address(optionMarket));\\n    Liquidity memory liquidity = getLiquidity(exchangeParams.spotPrice);\\n    _maybeExchangeBase(exchangeParams, liquidity.freeLiquidity, false);\\n  }\\n\\n  /// @dev Will skip base purchase/locking if snx spot fees exceed `lpParams.maxFeePaid`.\\n  function _maybeExchangeBase(\\n    SynthetixAdapter.ExchangeParams memory exchangeParams,\\n    uint freeLiquidity,\\n    bool revertBuyOnInsufficientFunds\\n  ) internal {\\n    uint currentBaseBalance = baseAsset.balanceOf(address(this));\\n    if (currentBaseBalance > lockedCollateral.base) {\\n      // Sell base for quote\\n      if (exchangeParams.baseQuoteFeeRate > lpParams.maxFeePaid) {\\n        return;\\n      }\\n      uint amountBase = currentBaseBalance - lockedCollateral.base;\\n      uint quoteReceived = synthetixAdapter.exchangeFromExactBase(address(optionMarket), amountBase);\\n      emit BaseSold(amountBase, quoteReceived);\\n    } else if (currentBaseBalance < lockedCollateral.base) {\\n      // Buy base for quote\\n      uint amountBase = lockedCollateral.base - currentBaseBalance;\\n      if (exchangeParams.quoteBaseFeeRate > lpParams.maxFeePaid) {\\n        uint estimatedExchangeCost = synthetixAdapter.estimateExchangeToExactBase(exchangeParams, amountBase);\\n        if (revertBuyOnInsufficientFunds && estimatedExchangeCost > freeLiquidity) {\\n          revert InsufficientFreeLiquidityForBaseExchange(\\n            address(this),\\n            amountBase,\\n            estimatedExchangeCost,\\n            freeLiquidity\\n          );\\n        }\\n        return;\\n      }\\n      (uint quoteSpent, uint baseReceived) = synthetixAdapter.exchangeToExactBaseWithLimit(\\n        exchangeParams,\\n        address(optionMarket),\\n        amountBase,\\n        revertBuyOnInsufficientFunds ? freeLiquidity : type(uint).max\\n      );\\n      emit BasePurchased(quoteSpent, baseReceived);\\n    }\\n  }\\n\\n  //////////\\n  // Misc //\\n  //////////\\n\\n  /// @notice returns the LiquidityPoolParameters struct\\n  function getLpParams() external view returns (LiquidityPoolParameters memory) {\\n    return lpParams;\\n  }\\n\\n  /// @notice updates `liquidationInsolventAmount` if liquidated position is insolveny\\n  function updateLiquidationInsolvency(uint insolvencyAmountInQuote) external onlyOptionMarket {\\n    liquidationInsolventAmount += insolvencyAmountInQuote;\\n  }\\n\\n  /**\\n   * @dev get the total amount of quote used and pending for delta hedging\\n   *\\n   * @return pendingDeltaLiquidity The amount of liquidity reserved for delta hedging that hasn't occured yet\\n   * @return usedDeltaLiquidity The value of the current hedge position (long value OR collateral - short debt)\\n   */\\n  function _getPoolHedgerLiquidity(uint basePrice)\\n    internal\\n    view\\n    returns (uint pendingDeltaLiquidity, uint usedDeltaLiquidity)\\n  {\\n    if (address(poolHedger) != address(0)) {\\n      return poolHedger.getHedgingLiquidity(basePrice);\\n    }\\n    return (0, 0);\\n  }\\n\\n  /**\\n   * @notice Sends quote to the PoolHedger.\\n   * @dev Transfer amount up to `pendingLiquidity + freeLiquidity`.\\n   * The hedger must determine what to do with the amount received.\\n   *\\n   * @param spotPrice The spot price of the base asset.\\n   * @param amount The amount requested by the PoolHedger.\\n   */\\n  function transferQuoteToHedge(uint spotPrice, uint amount) external onlyPoolHedger returns (uint) {\\n    Liquidity memory liquidity = getLiquidity(spotPrice);\\n\\n    uint available = liquidity.pendingDeltaLiquidity + liquidity.freeLiquidity;\\n\\n    amount = amount > available ? available : amount;\\n\\n    _transferQuote(address(poolHedger), amount);\\n\\n    emit QuoteTransferredToPoolHedger(amount);\\n\\n    return amount;\\n  }\\n\\n  function _transferQuote(address to, uint amount) internal {\\n    if (amount > 0) {\\n      if (!quoteAsset.transfer(to, amount)) {\\n        revert QuoteTransferFailed(address(this), address(this), to, amount);\\n      }\\n    }\\n  }\\n\\n  ///////////////\\n  // Modifiers //\\n  ///////////////\\n\\n  modifier onlyPoolHedger() {\\n    if (msg.sender != address(poolHedger)) {\\n      revert OnlyPoolHedger(address(this), msg.sender, address(poolHedger));\\n    }\\n    _;\\n  }\\n\\n  modifier onlyOptionMarket() {\\n    if (msg.sender != address(optionMarket)) {\\n      revert OnlyOptionMarket(address(this), msg.sender, address(optionMarket));\\n    }\\n    _;\\n  }\\n\\n  modifier onlyShortCollateral() {\\n    if (msg.sender != address(shortCollateral)) {\\n      revert OnlyShortCollateral(address(this), msg.sender, address(shortCollateral));\\n    }\\n    _;\\n  }\\n\\n  ////////////\\n  // Events //\\n  ////////////\\n\\n  /// @dev Emitted whenever the pool paramters are updated\\n  event LiquidityPoolParametersUpdated(LiquidityPoolParameters lpParams);\\n\\n  /// @dev Emitted whenever the poolHedger address is modified\\n  event PoolHedgerUpdated(PoolHedger poolHedger);\\n\\n  /// @dev Emitted when quote is locked.\\n  event QuoteLocked(uint quoteLocked, uint lockedCollateralQuote);\\n\\n  /// @dev Emitted when quote is freed.\\n  event QuoteFreed(uint quoteFreed, uint lockedCollateralQuote);\\n\\n  /// @dev Emitted when base is locked.\\n  event BaseLocked(uint baseLocked, uint lockedCollateralBase);\\n\\n  /// @dev Emitted when base is freed.\\n  event BaseFreed(uint baseFreed, uint lockedCollateralBase);\\n\\n  /// @dev Emitted when a board is settled.\\n  event BoardSettlement(uint insolventSettlementAmount, uint amountQuoteReserved, uint totalOutstandingSettlements);\\n\\n  /// @dev Emitted when reserved quote is sent.\\n  event OutstandingSettlementSent(address indexed user, uint amount, uint totalOutstandingSettlements);\\n\\n  /// @dev Emitted whenever quote is exchanged for base\\n  event BasePurchased(uint quoteSpent, uint baseReceived);\\n\\n  /// @dev Emitted whenever base is exchanged for quote\\n  event BaseSold(uint amountBase, uint quoteReceived);\\n\\n  /// @dev Emitted whenever premium is sent to a trader closing their position\\n  event PremiumTransferred(address indexed recipient, uint recipientPortion, uint optionMarketPortion);\\n\\n  /// @dev Emitted whenever quote is sent to the PoolHedger\\n  event QuoteTransferredToPoolHedger(uint amountQuote);\\n\\n  /// @dev Emitted whenever the insolvent settlement amount is updated (settlement and excess)\\n  event InsolventSettlementAmountUpdated(uint amountQuoteAdded, uint totalInsolventSettlementAmount);\\n\\n  /// @dev Emitted whenever a user deposits and enters the queue.\\n  event DepositQueued(\\n    address indexed depositor,\\n    address indexed beneficiary,\\n    uint indexed depositQueueId,\\n    uint amountDeposited,\\n    uint totalQueuedDeposits,\\n    uint timestamp\\n  );\\n\\n  /// @dev Emitted whenever a deposit gets processed. Note, can be processed without being queued.\\n  ///  QueueId of 0 indicates it was not queued.\\n  event DepositProcessed(\\n    address indexed caller,\\n    address indexed beneficiary,\\n    uint indexed depositQueueId,\\n    uint amountDeposited,\\n    uint tokenPrice,\\n    uint tokensReceived,\\n    uint timestamp\\n  );\\n\\n  /// @dev Emitted whenever a deposit gets processed. Note, can be processed without being queued.\\n  ///  QueueId of 0 indicates it was not queued.\\n  event WithdrawProcessed(\\n    address indexed caller,\\n    address indexed beneficiary,\\n    uint indexed withdrawalQueueId,\\n    uint amountWithdrawn,\\n    uint tokenPrice,\\n    uint quoteReceived,\\n    uint totalQueuedWithdrawals,\\n    uint timestamp\\n  );\\n  event WithdrawPartiallyProcessed(\\n    address indexed caller,\\n    address indexed beneficiary,\\n    uint indexed withdrawalQueueId,\\n    uint amountWithdrawn,\\n    uint tokenPrice,\\n    uint quoteReceived,\\n    uint totalQueuedWithdrawals,\\n    uint timestamp\\n  );\\n  event WithdrawQueued(\\n    address indexed withdrawer,\\n    address indexed beneficiary,\\n    uint indexed withdrawalQueueId,\\n    uint amountWithdrawn,\\n    uint totalQueuedWithdrawals,\\n    uint timestamp\\n  );\\n\\n  /// @dev Emitted whenever the CB timestamp is updated\\n  event CircuitBreakerUpdated(\\n    uint newTimestamp,\\n    bool ivVarianceThresholdCrossed,\\n    bool skewVarianceThresholdCrossed,\\n    bool liquidityThresholdCrossed\\n  );\\n\\n  /// @dev Emitted whenever the CB timestamp is updated from a board settlement\\n  event BoardSettlementCircuitBreakerUpdated(uint newTimestamp);\\n\\n  /// @dev Emitted whenever a queue item is checked for the ability to be processed\\n  event CheckingCanProcess(uint entryId, bool boardNotStale, bool validEntry, bool guardianBypass, bool delaysExpired);\\n\\n  ////////////\\n  // Errors //\\n  ////////////\\n  // Admin\\n  error InvalidLiquidityPoolParameters(address thrower, LiquidityPoolParameters lpParams);\\n\\n  // Deposits and withdrawals\\n  error InvalidBeneficiaryAddress(address thrower, address beneficiary);\\n  error MinimumDepositNotMet(address thrower, uint amountQuote, uint minDeposit);\\n  error MinimumWithdrawNotMet(address thrower, uint amountLiquidityToken, uint minWithdraw);\\n\\n  // Liquidity and accounting\\n  error LockingMoreQuoteThanIsFree(address thrower, uint quoteToLock, uint freeLiquidity, Collateral lockedCollateral);\\n  error SendPremiumNotEnoughCollateral(address thrower, uint premium, uint reservedFee, uint freeLiquidity);\\n  error NotEnoughFreeToReclaimInsolvency(address thrower, uint amountQuote, Liquidity liquidity);\\n  error OptionValueDebtExceedsTotalAssets(address thrower, int totalAssetValue, int optionValueDebt);\\n  error InsufficientFreeLiquidityForBaseExchange(\\n    address thrower,\\n    uint pendingBase,\\n    uint estimatedExchangeCost,\\n    uint freeLiquidity\\n  );\\n\\n  // Access\\n  error OnlyPoolHedger(address thrower, address caller, address poolHedger);\\n  error OnlyOptionMarket(address thrower, address caller, address optionMarket);\\n  error OnlyShortCollateral(address thrower, address caller, address poolHedger);\\n\\n  // Token transfers\\n  error QuoteTransferFailed(address thrower, address from, address to, uint amount);\\n  error BaseTransferFailed(address thrower, address from, address to, uint amount);\\n}\\n\",\"keccak256\":\"0x9116bb4b1ecea2737f4b0e93fa78b631f85a07d02176cace8c6e9ba82c3e210c\",\"license\":\"ISC\"},\"@lyrafinance/protocol/contracts/LiquidityToken.sol\":{\"content\":\"//SPDX-License-Identifier: ISC\\npragma solidity 0.8.9;\\n\\n// Libraries\\nimport \\\"./synthetix/DecimalMath.sol\\\";\\n// Inherited\\nimport \\\"openzeppelin-contracts-4.4.1/token/ERC20/ERC20.sol\\\";\\nimport \\\"./synthetix/Owned.sol\\\";\\nimport \\\"./libraries/SimpleInitializeable.sol\\\";\\n\\n// Interfaces\\nimport \\\"./interfaces/ILiquidityTracker.sol\\\";\\n\\n/**\\n * @title LiquidityToken\\n * @author Lyra\\n * @dev An ERC20 token which represents a share of the LiquidityPool.\\n * It is minted when users deposit, and burned when users withdraw.\\n */\\ncontract LiquidityToken is ERC20, Owned, SimpleInitializeable {\\n  using DecimalMath for uint;\\n\\n  /// @dev The liquidityPool for which these tokens represent a share of\\n  address public liquidityPool;\\n  /// @dev Contract to call when liquidity gets updated. Basically a hook for future contracts to use.\\n  ILiquidityTracker public liquidityTracker;\\n\\n  ///////////\\n  // Setup //\\n  ///////////\\n\\n  /**\\n   * @param name_ Token collection name\\n   * @param symbol_ Token collection symbol\\n   */\\n  constructor(string memory name_, string memory symbol_) ERC20(name_, symbol_) Owned() {}\\n\\n  /**\\n   * @dev Initialize the contract.\\n   * @param _liquidityPool LiquidityPool address\\n   */\\n  function init(address _liquidityPool) external onlyOwner initializer {\\n    liquidityPool = _liquidityPool;\\n  }\\n\\n  ///////////\\n  // Admin //\\n  ///////////\\n\\n  function setLiquidityTracker(ILiquidityTracker _liquidityTracker) external onlyOwner {\\n    liquidityTracker = _liquidityTracker;\\n    emit LiquidityTrackerSet(liquidityTracker);\\n  }\\n\\n  ////////////////////////\\n  // Only LiquidityPool //\\n  ////////////////////////\\n\\n  /**\\n   * @dev Mints new tokens and transfers them to `owner`.\\n   */\\n  function mint(address account, uint tokenAmount) external onlyLiquidityPool {\\n    _mint(account, tokenAmount);\\n  }\\n\\n  /**\\n   * @dev Burn new tokens and transfers them to `owner`.\\n   */\\n  function burn(address account, uint tokenAmount) external onlyLiquidityPool {\\n    _burn(account, tokenAmount);\\n  }\\n\\n  //////////\\n  // Misc //\\n  //////////\\n  /**\\n   * @dev Override to track the liquidty of the token. Mint, address(0), burn - to, address(0)\\n   */\\n  function _afterTokenTransfer(\\n    address from,\\n    address to,\\n    uint amount\\n  ) internal override {\\n    if (address(liquidityTracker) != address(0)) {\\n      if (from != address(0)) {\\n        liquidityTracker.removeTokens(from, amount);\\n      }\\n      if (to != address(0)) {\\n        liquidityTracker.addTokens(to, amount);\\n      }\\n    }\\n  }\\n\\n  ///////////////\\n  // Modifiers //\\n  ///////////////\\n\\n  modifier onlyLiquidityPool() {\\n    if (msg.sender != liquidityPool) {\\n      revert OnlyLiquidityPool(address(this), msg.sender, liquidityPool);\\n    }\\n    _;\\n  }\\n\\n  ////////////\\n  // Events //\\n  ////////////\\n  event LiquidityTrackerSet(ILiquidityTracker liquidityTracker);\\n\\n  ////////////\\n  // Errors //\\n  ////////////\\n  // Access\\n  error OnlyLiquidityPool(address thrower, address caller, address liquidityPool);\\n}\\n\",\"keccak256\":\"0xf5f824d5aa0b5e12aaa23beb8584002841dfdb55de18597a339982bc9782c625\",\"license\":\"ISC\"},\"@lyrafinance/protocol/contracts/OptionGreekCache.sol\":{\"content\":\"//SPDX-License-Identifier: ISC\\npragma solidity 0.8.9;\\n\\n// Libraries\\nimport \\\"./synthetix/DecimalMath.sol\\\";\\nimport \\\"./synthetix/SignedDecimalMath.sol\\\";\\n\\n// Inherited\\nimport \\\"./synthetix/Owned.sol\\\";\\nimport \\\"./libraries/SimpleInitializeable.sol\\\";\\nimport \\\"openzeppelin-contracts-4.4.1/security/ReentrancyGuard.sol\\\";\\n\\n// Interfaces\\nimport \\\"openzeppelin-contracts-4.4.1/token/ERC20/ERC20.sol\\\";\\nimport \\\"./libraries/BlackScholes.sol\\\";\\nimport \\\"./SynthetixAdapter.sol\\\";\\nimport \\\"./OptionMarket.sol\\\";\\nimport \\\"./OptionMarketPricer.sol\\\";\\nimport \\\"./libraries/GWAV.sol\\\";\\n\\n/**\\n * @title OptionGreekCache\\n * @author Lyra\\n * @dev Aggregates the netDelta and netStdVega of the OptionMarket by iterating over current strikes, using gwav vols.\\n * Needs to be called by an external actor as it's not feasible to do all the computation during the trade flow and\\n * because delta/vega change over time and with movements in asset price and volatility.\\n * All stored values in this contract are the aggregate of the trader's perspective. So values need to be inverted\\n * to get the LP's perspective\\n * Also handles logic for figuring out minimal collateral requirements for shorts.\\n */\\ncontract OptionGreekCache is Owned, SimpleInitializeable, ReentrancyGuard {\\n  using DecimalMath for uint;\\n  using SignedDecimalMath for int;\\n  using GWAV for GWAV.Params;\\n  using BlackScholes for BlackScholes.BlackScholesInputs;\\n\\n  ////////////////\\n  // Parameters //\\n  ////////////////\\n\\n  struct GreekCacheParameters {\\n    // Cap the number of strikes per board to avoid hitting gasLimit constraints\\n    uint maxStrikesPerBoard;\\n    // How much spot price can move since last update before deposits/withdrawals are blocked\\n    uint acceptableSpotPricePercentMove;\\n    // How much time has passed since last update before deposits/withdrawals are blocked\\n    uint staleUpdateDuration;\\n    // Length of the GWAV for the baseline volatility used to fire the vol circuit breaker\\n    uint varianceIvGWAVPeriod;\\n    // Length of the GWAV for the skew ratios used to fire the vol circuit breaker\\n    uint varianceSkewGWAVPeriod;\\n    // Length of the GWAV for the baseline used to determine the NAV of the pool\\n    uint optionValueIvGWAVPeriod;\\n    // Length of the GWAV for the skews used to determine the NAV of the pool\\n    uint optionValueSkewGWAVPeriod;\\n    // Minimum skew that will be fed into the GWAV calculation\\n    // Prevents near 0 values being used to heavily manipulate the GWAV\\n    uint gwavSkewFloor;\\n    // Maximum skew that will be fed into the GWAV calculation\\n    uint gwavSkewCap;\\n    // Interest/risk free rate\\n    int rateAndCarry;\\n  }\\n\\n  struct ForceCloseParameters {\\n    // Length of the GWAV for the baseline vol used in ForceClose() and liquidations\\n    uint ivGWAVPeriod;\\n    // Length of the GWAV for the skew ratio used in ForceClose() and liquidations\\n    uint skewGWAVPeriod;\\n    // When a user buys back an option using ForceClose() we increase the GWAV vol to penalise the trader\\n    uint shortVolShock;\\n    // Increase the penalty when within the trading cutoff\\n    uint shortPostCutoffVolShock;\\n    // When a user sells back an option to the AMM using ForceClose(), we decrease the GWAV to penalise the seller\\n    uint longVolShock;\\n    // Increase the penalty when within the trading cutoff\\n    uint longPostCutoffVolShock;\\n    // Same justification as shortPostCutoffVolShock\\n    uint liquidateVolShock;\\n    // Increase the penalty when within the trading cutoff\\n    uint liquidatePostCutoffVolShock;\\n    // Minimum price the AMM will sell back an option at for force closes (as a % of current spot)\\n    uint shortSpotMin;\\n    // Minimum price the AMM will sell back an option at for liquidations (as a % of current spot)\\n    uint liquidateSpotMin;\\n  }\\n\\n  struct MinCollateralParameters {\\n    // Minimum collateral that must be posted for a short to be opened (denominated in quote)\\n    uint minStaticQuoteCollateral;\\n    // Minimum collateral that must be posted for a short to be opened (denominated in base)\\n    uint minStaticBaseCollateral;\\n    /* Shock Vol:\\n     * Vol used to compute the minimum collateral requirements for short positions.\\n     * This value is derived from the following chart, created by using the 4 values listed below.\\n     *\\n     *     vol\\n     *      |\\n     * volA |____\\n     *      |    \\\\\\n     * volB |     \\\\___\\n     *      |___________ time to expiry\\n     *         A   B\\n     */\\n    uint shockVolA;\\n    uint shockVolPointA;\\n    uint shockVolB;\\n    uint shockVolPointB;\\n    // Static percentage shock to the current spot price for calls\\n    uint callSpotPriceShock;\\n    // Static percentage shock to the current spot price for puts\\n    uint putSpotPriceShock;\\n  }\\n\\n  ///////////////////\\n  // Cache storage //\\n  ///////////////////\\n  struct GlobalCache {\\n    uint minUpdatedAt;\\n    uint minUpdatedAtPrice;\\n    uint maxUpdatedAtPrice;\\n    uint maxSkewVariance;\\n    uint maxIvVariance;\\n    NetGreeks netGreeks;\\n  }\\n\\n  struct OptionBoardCache {\\n    uint id;\\n    uint[] strikes;\\n    uint expiry;\\n    uint iv;\\n    NetGreeks netGreeks;\\n    uint updatedAt;\\n    uint updatedAtPrice;\\n    uint maxSkewVariance;\\n    uint ivVariance;\\n  }\\n\\n  struct StrikeCache {\\n    uint id;\\n    uint boardId;\\n    uint strikePrice;\\n    uint skew;\\n    StrikeGreeks greeks;\\n    int callExposure; // long - short\\n    int putExposure; // long - short\\n    uint skewVariance; // (GWAVSkew - skew)\\n  }\\n\\n  // These are based on GWAVed iv\\n  struct StrikeGreeks {\\n    int callDelta;\\n    int putDelta;\\n    uint stdVega;\\n    uint callPrice;\\n    uint putPrice;\\n  }\\n\\n  // These are based on GWAVed iv\\n  struct NetGreeks {\\n    int netDelta;\\n    int netStdVega;\\n    int netOptionValue;\\n  }\\n\\n  ///////////////\\n  // In-memory //\\n  ///////////////\\n  struct TradePricing {\\n    uint optionPrice;\\n    int preTradeAmmNetStdVega;\\n    int postTradeAmmNetStdVega;\\n    int callDelta;\\n    uint volTraded;\\n    uint ivVariance;\\n    uint vega;\\n  }\\n\\n  struct BoardGreeksView {\\n    NetGreeks boardGreeks;\\n    uint ivGWAV;\\n    StrikeGreeks[] strikeGreeks;\\n    uint[] skewGWAVs;\\n  }\\n\\n  ///////////////\\n  // Variables //\\n  ///////////////\\n  SynthetixAdapter internal synthetixAdapter;\\n  OptionMarket internal optionMarket;\\n  address internal optionMarketPricer;\\n\\n  GreekCacheParameters internal greekCacheParams;\\n  ForceCloseParameters internal forceCloseParams;\\n  MinCollateralParameters internal minCollatParams;\\n\\n  // Cached values and GWAVs\\n  /// @dev Should be a clone of OptionMarket.liveBoards\\n  uint[] internal liveBoards;\\n  GlobalCache internal globalCache;\\n\\n  mapping(uint => OptionBoardCache) internal boardCaches;\\n  mapping(uint => GWAV.Params) internal boardIVGWAV;\\n\\n  mapping(uint => StrikeCache) internal strikeCaches;\\n  mapping(uint => GWAV.Params) internal strikeSkewGWAV;\\n\\n  ///////////\\n  // Setup //\\n  ///////////\\n\\n  constructor() Owned() {}\\n\\n  /**\\n   * @dev Initialize the contract.\\n   *\\n   * @param _synthetixAdapter SynthetixAdapter address\\n   * @param _optionMarket OptionMarket address\\n   * @param _optionMarketPricer OptionMarketPricer address\\n   */\\n  function init(\\n    SynthetixAdapter _synthetixAdapter,\\n    OptionMarket _optionMarket,\\n    address _optionMarketPricer\\n  ) external onlyOwner initializer {\\n    synthetixAdapter = _synthetixAdapter;\\n    optionMarket = _optionMarket;\\n    optionMarketPricer = _optionMarketPricer;\\n  }\\n\\n  ///////////\\n  // Admin //\\n  ///////////\\n\\n  function setGreekCacheParameters(GreekCacheParameters memory _greekCacheParams) external onlyOwner {\\n    if (\\n      !(_greekCacheParams.acceptableSpotPricePercentMove <= 10e18 && //\\n        _greekCacheParams.staleUpdateDuration <= 30 days && //\\n        _greekCacheParams.varianceIvGWAVPeriod > 0 && //\\n        _greekCacheParams.varianceIvGWAVPeriod <= 60 days && //\\n        _greekCacheParams.varianceSkewGWAVPeriod > 0 &&\\n        _greekCacheParams.varianceSkewGWAVPeriod <= 60 days &&\\n        _greekCacheParams.optionValueIvGWAVPeriod > 0 &&\\n        _greekCacheParams.optionValueIvGWAVPeriod <= 60 days &&\\n        _greekCacheParams.optionValueSkewGWAVPeriod > 0 &&\\n        _greekCacheParams.optionValueSkewGWAVPeriod <= 60 days &&\\n        _greekCacheParams.gwavSkewFloor <= 1e18 &&\\n        _greekCacheParams.gwavSkewFloor > 0 &&\\n        _greekCacheParams.gwavSkewCap >= 1e18 &&\\n        _greekCacheParams.rateAndCarry >= -50e18 &&\\n        _greekCacheParams.rateAndCarry <= 50e18)\\n    ) {\\n      revert InvalidGreekCacheParameters(address(this), _greekCacheParams);\\n    }\\n\\n    greekCacheParams = _greekCacheParams;\\n    emit GreekCacheParametersSet(greekCacheParams);\\n  }\\n\\n  function setForceCloseParameters(ForceCloseParameters memory _forceCloseParams) external onlyOwner {\\n    if (\\n      !(_forceCloseParams.ivGWAVPeriod > 0 &&\\n        _forceCloseParams.ivGWAVPeriod <= 60 days &&\\n        _forceCloseParams.skewGWAVPeriod > 0 &&\\n        _forceCloseParams.skewGWAVPeriod <= 60 days &&\\n        _forceCloseParams.shortVolShock >= 1e18 &&\\n        _forceCloseParams.shortPostCutoffVolShock >= 1e18 &&\\n        _forceCloseParams.longVolShock > 0 &&\\n        _forceCloseParams.longVolShock <= 1e18 &&\\n        _forceCloseParams.longPostCutoffVolShock > 0 &&\\n        _forceCloseParams.longPostCutoffVolShock <= 1e18 &&\\n        _forceCloseParams.liquidateVolShock >= 1e18 &&\\n        _forceCloseParams.liquidatePostCutoffVolShock >= 1e18 &&\\n        _forceCloseParams.shortSpotMin <= 1e18 &&\\n        _forceCloseParams.liquidateSpotMin <= 1e18)\\n    ) {\\n      revert InvalidForceCloseParameters(address(this), _forceCloseParams);\\n    }\\n\\n    forceCloseParams = _forceCloseParams;\\n    emit ForceCloseParametersSet(forceCloseParams);\\n  }\\n\\n  function setMinCollateralParameters(MinCollateralParameters memory _minCollatParams) external onlyOwner {\\n    if (\\n      !(_minCollatParams.minStaticQuoteCollateral > 0 &&\\n        _minCollatParams.minStaticBaseCollateral > 0 &&\\n        _minCollatParams.shockVolA > 0 &&\\n        _minCollatParams.shockVolA >= _minCollatParams.shockVolB &&\\n        _minCollatParams.shockVolPointA <= _minCollatParams.shockVolPointB &&\\n        _minCollatParams.callSpotPriceShock >= 1e18 &&\\n        _minCollatParams.putSpotPriceShock > 0 &&\\n        _minCollatParams.putSpotPriceShock <= 1e18)\\n    ) {\\n      revert InvalidMinCollatParams(address(this), _minCollatParams);\\n    }\\n\\n    minCollatParams = _minCollatParams;\\n    emit MinCollateralParametersSet(minCollatParams);\\n  }\\n\\n  //////////////////////////////////////////////////////\\n  // Sync Boards with OptionMarket (onlyOptionMarket) //\\n  //////////////////////////////////////////////////////\\n\\n  /**\\n   * @notice Adds a new OptionBoardCache\\n   * @dev Called by the OptionMarket whenever a new OptionBoard is added\\n   *\\n   * @param board The new OptionBoard\\n   * @param strikes The new Strikes for the given board\\n   */\\n  function addBoard(OptionMarket.OptionBoard memory board, OptionMarket.Strike[] memory strikes)\\n    external\\n    onlyOptionMarket\\n  {\\n    if (strikes.length > greekCacheParams.maxStrikesPerBoard) {\\n      revert BoardStrikeLimitExceeded(address(this), board.id, strikes.length, greekCacheParams.maxStrikesPerBoard);\\n    }\\n\\n    OptionBoardCache storage boardCache = boardCaches[board.id];\\n    boardCache.id = board.id;\\n    boardCache.expiry = board.expiry;\\n    boardCache.iv = board.iv;\\n    boardCache.updatedAt = block.timestamp;\\n    emit BoardCacheUpdated(boardCache);\\n    boardIVGWAV[board.id]._initialize(board.iv, block.timestamp);\\n    emit BoardIvUpdated(boardCache.id, board.iv, globalCache.maxIvVariance);\\n\\n    liveBoards.push(board.id);\\n\\n    for (uint i = 0; i < strikes.length; i++) {\\n      _addNewStrikeToStrikeCache(boardCache, board.iv, strikes[i].id, strikes[i].strikePrice, strikes[i].skew);\\n    }\\n\\n    _updateGlobalLastUpdatedAt();\\n  }\\n\\n  /// @dev After board settlement, remove an OptionBoardCache. Called by OptionMarket\\n  function removeBoard(uint boardId) external onlyOptionMarket {\\n    // Remove board from cache, removing net positions from global count\\n    OptionBoardCache memory boardCache = boardCaches[boardId];\\n    globalCache.netGreeks.netDelta -= boardCache.netGreeks.netDelta;\\n    globalCache.netGreeks.netStdVega -= boardCache.netGreeks.netStdVega;\\n    globalCache.netGreeks.netOptionValue -= boardCache.netGreeks.netOptionValue;\\n\\n    // Clean up, cache isn't necessary for settle logic\\n    for (uint i = 0; i < boardCache.strikes.length; i++) {\\n      emit StrikeCacheRemoved(boardCache.strikes[i]);\\n      delete strikeCaches[boardCache.strikes[i]];\\n    }\\n    for (uint i = 0; i < liveBoards.length; i++) {\\n      if (liveBoards[i] == boardId) {\\n        liveBoards[i] = liveBoards[liveBoards.length - 1];\\n        liveBoards.pop();\\n        break;\\n      }\\n    }\\n    emit BoardCacheRemoved(boardId);\\n    emit GlobalCacheUpdated(globalCache);\\n    delete boardCaches[boardId];\\n  }\\n\\n  /// @dev Add a new strike to a given boardCache. Only callable by OptionMarket.\\n  function addStrikeToBoard(\\n    uint boardId,\\n    uint strikeId,\\n    uint strikePrice,\\n    uint skew\\n  ) external onlyOptionMarket {\\n    OptionBoardCache storage boardCache = boardCaches[boardId];\\n    if (boardCache.strikes.length == greekCacheParams.maxStrikesPerBoard) {\\n      revert BoardStrikeLimitExceeded(\\n        address(this),\\n        boardId,\\n        boardCache.strikes.length + 1,\\n        greekCacheParams.maxStrikesPerBoard\\n      );\\n    }\\n\\n    uint GWAVbaseIv = boardIVGWAV[boardId].getGWAVForPeriod(greekCacheParams.optionValueIvGWAVPeriod, 0);\\n    _addNewStrikeToStrikeCache(boardCache, GWAVbaseIv, strikeId, strikePrice, skew);\\n  }\\n\\n  /// @dev Updates an OptionBoard's baseIv. Only callable by OptionMarket.\\n  function setBoardIv(uint boardId, uint newBaseIv) external onlyOptionMarket {\\n    OptionBoardCache storage boardCache = boardCaches[boardId];\\n    _updateBoardIv(boardCache, newBaseIv);\\n    emit BoardIvUpdated(boardId, newBaseIv, globalCache.maxIvVariance);\\n  }\\n\\n  /**\\n   * @dev Updates a Strike's skew. Only callable by OptionMarket.\\n   *\\n   * @param strikeId The id of the Strike\\n   * @param newSkew The new skew of the given Strike\\n   */\\n  function setStrikeSkew(uint strikeId, uint newSkew) external onlyOptionMarket {\\n    StrikeCache storage strikeCache = strikeCaches[strikeId];\\n    OptionBoardCache storage boardCache = boardCaches[strikeCache.boardId];\\n    _updateStrikeSkew(boardCache, strikeCache, newSkew);\\n  }\\n\\n  /// @dev Adds a new strike to a given board, initialising the skew GWAV\\n  function _addNewStrikeToStrikeCache(\\n    OptionBoardCache storage boardCache,\\n    uint GWAVbaseIv,\\n    uint strikeId,\\n    uint strikePrice,\\n    uint skew\\n  ) internal {\\n    // This is only called when a new board or a new strike is added, so exposure values will be 0\\n    StrikeCache storage strikeCache = strikeCaches[strikeId];\\n    strikeCache.id = strikeId;\\n    strikeCache.strikePrice = strikePrice;\\n    strikeCache.skew = skew;\\n    strikeCache.boardId = boardCache.id;\\n\\n    emit StrikeCacheUpdated(strikeCache);\\n\\n    strikeSkewGWAV[strikeId]._initialize(\\n      _max(_min(skew, greekCacheParams.gwavSkewCap), greekCacheParams.gwavSkewFloor),\\n      block.timestamp\\n    );\\n\\n    // need to assign option prices/stdVega to properly update stdVega/NAV on opens/deposits\\n    _updateStrikeCachedGreeks(\\n      strikeCache,\\n      boardCache,\\n      synthetixAdapter.getSpotPriceForMarket(address(optionMarket)),\\n      GWAVbaseIv.multiplyDecimal(skew)\\n    );\\n\\n    emit StrikeSkewUpdated(strikeCache.id, skew, globalCache.maxSkewVariance);\\n\\n    boardCache.strikes.push(strikeId);\\n  }\\n\\n  //////////////////////////////////////////////\\n  // Updating exposure/getting option pricing //\\n  //////////////////////////////////////////////\\n\\n  /**\\n   * @notice During a trade, updates the exposure of the given strike, board and global state. Computes the cost of the\\n   * trade and returns it to the OptionMarketPricer.\\n   * @return pricing The final price of the option to be paid for by the user. This could use marketVol or shockVol,\\n   * depending on the trade executed.\\n   */\\n  function updateStrikeExposureAndGetPrice(\\n    OptionMarket.Strike memory strike,\\n    OptionMarket.TradeParameters memory trade,\\n    uint iv,\\n    uint skew,\\n    bool isPostCutoff\\n  ) external onlyOptionMarketPricer returns (TradePricing memory pricing) {\\n    StrikeCache storage strikeCache = strikeCaches[strike.id];\\n    OptionBoardCache storage boardCache = boardCaches[strikeCache.boardId];\\n\\n    _updateBoardIv(boardCache, iv);\\n    _updateStrikeSkew(boardCache, strikeCache, skew);\\n\\n    pricing = _updateStrikeExposureAndGetPrice(\\n      strikeCache,\\n      boardCache,\\n      trade,\\n      SafeCast.toInt256(strike.longCall) - SafeCast.toInt256(strike.shortCallBase + strike.shortCallQuote),\\n      SafeCast.toInt256(strike.longPut) - SafeCast.toInt256(strike.shortPut)\\n    );\\n\\n    pricing.ivVariance = boardCache.ivVariance;\\n\\n    // If this is a force close or liquidation, override the option price, delta and volTraded based on pricing for\\n    // force closes.\\n    if (trade.isForceClose) {\\n      (pricing.optionPrice, pricing.volTraded) = getPriceForForceClose(\\n        trade,\\n        strike,\\n        boardCache.expiry,\\n        iv.multiplyDecimal(skew),\\n        isPostCutoff\\n      );\\n    }\\n\\n    return pricing;\\n  }\\n\\n  /// @dev Updates the exposure of the strike and computes the market black scholes price\\n  function _updateStrikeExposureAndGetPrice(\\n    StrikeCache storage strikeCache,\\n    OptionBoardCache storage boardCache,\\n    OptionMarket.TradeParameters memory trade,\\n    int newCallExposure,\\n    int newPutExposure\\n  ) internal returns (TradePricing memory pricing) {\\n    BlackScholes.PricesDeltaStdVega memory pricesDeltaStdVega = BlackScholes\\n      .BlackScholesInputs({\\n        timeToExpirySec: _timeToMaturitySeconds(boardCache.expiry),\\n        volatilityDecimal: boardCache.iv.multiplyDecimal(strikeCache.skew),\\n        spotDecimal: trade.exchangeParams.spotPrice,\\n        strikePriceDecimal: strikeCache.strikePrice,\\n        rateDecimal: greekCacheParams.rateAndCarry\\n      })\\n      .pricesDeltaStdVega();\\n\\n    int strikeOptionValue = (newCallExposure - strikeCache.callExposure).multiplyDecimal(\\n      SafeCast.toInt256(strikeCache.greeks.callPrice)\\n    ) + (newPutExposure - strikeCache.putExposure).multiplyDecimal(SafeCast.toInt256(strikeCache.greeks.putPrice));\\n\\n    int netDeltaDiff = (newCallExposure - strikeCache.callExposure).multiplyDecimal(strikeCache.greeks.callDelta) +\\n      (newPutExposure - strikeCache.putExposure).multiplyDecimal(strikeCache.greeks.putDelta);\\n\\n    int netStdVegaDiff = (newCallExposure + newPutExposure - strikeCache.callExposure - strikeCache.putExposure)\\n      .multiplyDecimal(SafeCast.toInt256(strikeCache.greeks.stdVega));\\n\\n    strikeCache.callExposure = newCallExposure;\\n    strikeCache.putExposure = newPutExposure;\\n    boardCache.netGreeks.netOptionValue += strikeOptionValue;\\n    boardCache.netGreeks.netDelta += netDeltaDiff;\\n    boardCache.netGreeks.netStdVega += netStdVegaDiff;\\n\\n    // The AMM's net std vega is opposite to the global sum of user's std vega\\n    pricing.preTradeAmmNetStdVega = -globalCache.netGreeks.netStdVega;\\n\\n    globalCache.netGreeks.netOptionValue += strikeOptionValue;\\n    globalCache.netGreeks.netDelta += netDeltaDiff;\\n    globalCache.netGreeks.netStdVega += netStdVegaDiff;\\n\\n    pricing.optionPrice = (trade.optionType != OptionMarket.OptionType.LONG_PUT &&\\n      trade.optionType != OptionMarket.OptionType.SHORT_PUT_QUOTE)\\n      ? pricesDeltaStdVega.callPrice\\n      : pricesDeltaStdVega.putPrice;\\n    // AMM's net positions are the inverse of the user's net position\\n    pricing.postTradeAmmNetStdVega = -globalCache.netGreeks.netStdVega;\\n    pricing.callDelta = pricesDeltaStdVega.callDelta;\\n    pricing.volTraded = boardCache.iv.multiplyDecimal(strikeCache.skew);\\n    pricing.vega = pricesDeltaStdVega.vega;\\n\\n    emit StrikeCacheUpdated(strikeCache);\\n    emit BoardCacheUpdated(boardCache);\\n    emit GlobalCacheUpdated(globalCache);\\n\\n    return pricing;\\n  }\\n\\n  /////////////////////////////////////\\n  // Liquidation/Force Close pricing //\\n  /////////////////////////////////////\\n\\n  /**\\n   * @notice Calculate price paid by the user to forceClose an options position\\n   * \\n   * @param trade TradeParameter as defined in OptionMarket\\n   * @param strike strikes details (including total exposure)\\n   * @param expiry expiry of option\\n   * @param newVol volatility post slippage as determined in `OptionTokOptionMarketPriceren.ivImpactForTrade()`\\n   * @param isPostCutoff flag for whether order is closer to expiry than postCutoff param.\\n\\n   * @return optionPrice premium to charge for close order (excluding fees added in OptionMarketPricer)\\n   * @return forceCloseVol volatility used to calculate optionPrice\\n   */\\n  function getPriceForForceClose(\\n    OptionMarket.TradeParameters memory trade,\\n    OptionMarket.Strike memory strike,\\n    uint expiry,\\n    uint newVol,\\n    bool isPostCutoff\\n  ) public view returns (uint optionPrice, uint forceCloseVol) {\\n    forceCloseVol = _getGWAVVolWithOverride(\\n      strike.boardId,\\n      strike.id,\\n      forceCloseParams.ivGWAVPeriod,\\n      forceCloseParams.skewGWAVPeriod\\n    );\\n\\n    if (trade.tradeDirection == OptionMarket.TradeDirection.CLOSE) {\\n      // If the tradeDirection is a close, we know the user force closed.\\n      if (trade.isBuy) {\\n        // closing a short - maximise vol\\n        forceCloseVol = _max(forceCloseVol, newVol);\\n        forceCloseVol = isPostCutoff\\n          ? forceCloseVol.multiplyDecimal(forceCloseParams.shortPostCutoffVolShock)\\n          : forceCloseVol.multiplyDecimal(forceCloseParams.shortVolShock);\\n      } else {\\n        // closing a long - minimise vol\\n        forceCloseVol = _min(forceCloseVol, newVol);\\n        forceCloseVol = isPostCutoff\\n          ? forceCloseVol.multiplyDecimal(forceCloseParams.longPostCutoffVolShock)\\n          : forceCloseVol.multiplyDecimal(forceCloseParams.longVolShock);\\n      }\\n    } else {\\n      // Otherwise it can only be a liquidation\\n      forceCloseVol = isPostCutoff\\n        ? forceCloseVol.multiplyDecimal(forceCloseParams.liquidatePostCutoffVolShock)\\n        : forceCloseVol.multiplyDecimal(forceCloseParams.liquidateVolShock);\\n    }\\n\\n    (uint callPrice, uint putPrice) = BlackScholes\\n      .BlackScholesInputs({\\n        timeToExpirySec: _timeToMaturitySeconds(expiry),\\n        volatilityDecimal: forceCloseVol,\\n        spotDecimal: trade.exchangeParams.spotPrice,\\n        strikePriceDecimal: strike.strikePrice,\\n        rateDecimal: greekCacheParams.rateAndCarry\\n      })\\n      .optionPrices();\\n\\n    uint price = (trade.optionType == OptionMarket.OptionType.LONG_PUT ||\\n      trade.optionType == OptionMarket.OptionType.SHORT_PUT_QUOTE)\\n      ? putPrice\\n      : callPrice;\\n\\n    if (trade.isBuy) {\\n      // In the case a short is being closed, ensure the AMM doesn't overpay by charging parity + some excess\\n      uint parity = _getParity(strike.strikePrice, trade.exchangeParams.spotPrice, trade.optionType);\\n      uint minPrice = parity +\\n        trade.exchangeParams.spotPrice.multiplyDecimal(\\n          trade.tradeDirection == OptionMarket.TradeDirection.CLOSE\\n            ? forceCloseParams.shortSpotMin\\n            : forceCloseParams.liquidateSpotMin\\n        );\\n      price = _max(price, minPrice);\\n    }\\n\\n    return (price, forceCloseVol);\\n  }\\n\\n  function _getGWAVVolWithOverride(\\n    uint boardId,\\n    uint strikeId,\\n    uint overrideIvPeriod,\\n    uint overrideSkewPeriod\\n  ) internal view returns (uint gwavVol) {\\n    uint gwavIV = boardIVGWAV[boardId].getGWAVForPeriod(overrideIvPeriod, 0);\\n    uint strikeGWAVSkew = strikeSkewGWAV[strikeId].getGWAVForPeriod(overrideSkewPeriod, 0);\\n    return gwavIV.multiplyDecimal(strikeGWAVSkew);\\n  }\\n\\n  /**\\n   * @notice Gets minimum collateral requirement for the specified option\\n   *\\n   * @param optionType The option type\\n   * @param strikePrice The strike price of the option\\n   * @param expiry The expiry of the option\\n   * @param spotPrice The price of the underlying asset\\n   * @param amount The size of the option\\n   */\\n  function getMinCollateral(\\n    OptionMarket.OptionType optionType,\\n    uint strikePrice,\\n    uint expiry,\\n    uint spotPrice,\\n    uint amount\\n  ) external view returns (uint minCollateral) {\\n    if (amount == 0) {\\n      return 0;\\n    }\\n\\n    // If put, reduce spot by percentage. If call, increase.\\n    uint shockPrice = (optionType == OptionMarket.OptionType.SHORT_PUT_QUOTE)\\n      ? spotPrice.multiplyDecimal(minCollatParams.putSpotPriceShock)\\n      : spotPrice.multiplyDecimal(minCollatParams.callSpotPriceShock);\\n\\n    uint timeToMaturity = _timeToMaturitySeconds(expiry);\\n\\n    (uint callPrice, uint putPrice) = BlackScholes\\n      .BlackScholesInputs({\\n        timeToExpirySec: timeToMaturity,\\n        volatilityDecimal: getShockVol(timeToMaturity),\\n        spotDecimal: shockPrice,\\n        strikePriceDecimal: strikePrice,\\n        rateDecimal: greekCacheParams.rateAndCarry\\n      })\\n      .optionPrices();\\n\\n    uint fullCollat;\\n    uint volCollat;\\n    uint staticCollat = minCollatParams.minStaticQuoteCollateral;\\n    if (optionType == OptionMarket.OptionType.SHORT_CALL_BASE) {\\n      // Can be more lenient to SHORT_CALL_BASE traders\\n      volCollat = callPrice.multiplyDecimal(amount).divideDecimal(shockPrice);\\n      fullCollat = amount;\\n      staticCollat = minCollatParams.minStaticBaseCollateral;\\n    } else if (optionType == OptionMarket.OptionType.SHORT_CALL_QUOTE) {\\n      volCollat = callPrice.multiplyDecimal(amount);\\n      fullCollat = type(uint).max;\\n    } else {\\n      // optionType == OptionMarket.OptionType.SHORT_PUT_QUOTE\\n      volCollat = putPrice.multiplyDecimal(amount);\\n      fullCollat = amount.multiplyDecimal(strikePrice);\\n    }\\n\\n    return _min(_max(volCollat, staticCollat), fullCollat);\\n  }\\n\\n  /// @notice Gets shock vol (Vol used to compute the minimum collateral requirements for short positions)\\n  function getShockVol(uint timeToMaturity) public view returns (uint) {\\n    if (timeToMaturity <= minCollatParams.shockVolPointA) {\\n      return minCollatParams.shockVolA;\\n    }\\n    if (timeToMaturity >= minCollatParams.shockVolPointB) {\\n      return minCollatParams.shockVolB;\\n    }\\n\\n    // Flip a and b so we don't need to convert to int\\n    return\\n      minCollatParams.shockVolA -\\n      (((minCollatParams.shockVolA - minCollatParams.shockVolB) * (timeToMaturity - minCollatParams.shockVolPointA)) /\\n        (minCollatParams.shockVolPointB - minCollatParams.shockVolPointA));\\n  }\\n\\n  //////////////////////////////////////////\\n  // Update GWAV vol greeks and net greeks //\\n  //////////////////////////////////////////\\n\\n  /**\\n   * @notice Updates the cached greeks for an OptionBoardCache used to calculate:\\n   * - trading fees\\n   * - aggregate AMM option value\\n   * - net delta exposure for proper hedging\\n   *\\n   * @param boardId The id of the OptionBoardCache.\\n   */\\n  function updateBoardCachedGreeks(uint boardId) external nonReentrant {\\n    _updateBoardCachedGreeks(synthetixAdapter.getSpotPriceForMarket(address(optionMarket)), boardId);\\n  }\\n\\n  function _updateBoardCachedGreeks(uint spotPrice, uint boardId) internal {\\n    OptionBoardCache storage boardCache = boardCaches[boardId];\\n    if (boardCache.id == 0) {\\n      revert InvalidBoardId(address(this), boardCache.id);\\n    }\\n\\n    if (block.timestamp > boardCache.expiry) {\\n      revert CannotUpdateExpiredBoard(address(this), boardCache.id, boardCache.expiry, block.timestamp);\\n    }\\n\\n    // Zero out the board net greeks and recompute all strikes, adding to the totals\\n    globalCache.netGreeks.netOptionValue -= boardCache.netGreeks.netOptionValue;\\n    globalCache.netGreeks.netDelta -= boardCache.netGreeks.netDelta;\\n    globalCache.netGreeks.netStdVega -= boardCache.netGreeks.netStdVega;\\n\\n    boardCache.netGreeks.netOptionValue = 0;\\n    boardCache.netGreeks.netDelta = 0;\\n    boardCache.netGreeks.netStdVega = 0;\\n\\n    _updateBoardIvVariance(boardCache);\\n    uint navGWAVbaseIv = boardIVGWAV[boardId].getGWAVForPeriod(greekCacheParams.optionValueIvGWAVPeriod, 0);\\n\\n    for (uint i = 0; i < boardCache.strikes.length; i++) {\\n      StrikeCache storage strikeCache = strikeCaches[boardCache.strikes[i]];\\n      _updateStrikeSkewVariance(strikeCache);\\n\\n      // update variance for strike skew\\n      uint strikeNavGWAVSkew = strikeSkewGWAV[strikeCache.id].getGWAVForPeriod(\\n        greekCacheParams.optionValueSkewGWAVPeriod,\\n        0\\n      );\\n      uint navGWAVvol = navGWAVbaseIv.multiplyDecimal(strikeNavGWAVSkew);\\n\\n      _updateStrikeCachedGreeks(strikeCache, boardCache, spotPrice, navGWAVvol);\\n    }\\n\\n    _updateMaxSkewVariance(boardCache);\\n    _updateMaxIvVariance();\\n\\n    boardCache.updatedAt = block.timestamp;\\n    boardCache.updatedAtPrice = spotPrice;\\n\\n    _updateGlobalLastUpdatedAt();\\n\\n    emit BoardIvUpdated(boardCache.id, boardCache.iv, globalCache.maxIvVariance);\\n    emit BoardCacheUpdated(boardCache);\\n    emit GlobalCacheUpdated(globalCache);\\n  }\\n\\n  /**\\n   * @dev Updates an StrikeCache using TWAP.\\n   * Assumes board has been zeroed out before updating all strikes at once\\n   *\\n   * @param strikeCache The StrikeCache.\\n   * @param boardCache The OptionBoardCache.\\n   */\\n  function _updateStrikeCachedGreeks(\\n    StrikeCache storage strikeCache,\\n    OptionBoardCache storage boardCache,\\n    uint spotPrice,\\n    uint navGWAVvol\\n  ) internal {\\n    BlackScholes.PricesDeltaStdVega memory pricesDeltaStdVega = BlackScholes\\n      .BlackScholesInputs({\\n        timeToExpirySec: _timeToMaturitySeconds(boardCache.expiry),\\n        volatilityDecimal: navGWAVvol,\\n        spotDecimal: spotPrice,\\n        strikePriceDecimal: strikeCache.strikePrice,\\n        rateDecimal: greekCacheParams.rateAndCarry\\n      })\\n      .pricesDeltaStdVega();\\n\\n    strikeCache.greeks.callPrice = pricesDeltaStdVega.callPrice;\\n    strikeCache.greeks.putPrice = pricesDeltaStdVega.putPrice;\\n    strikeCache.greeks.callDelta = pricesDeltaStdVega.callDelta;\\n    strikeCache.greeks.putDelta = pricesDeltaStdVega.putDelta;\\n    strikeCache.greeks.stdVega = pricesDeltaStdVega.stdVega;\\n\\n    // only update board/global if exposure present\\n    if (strikeCache.callExposure != 0 || strikeCache.putExposure != 0) {\\n      int strikeOptionValue = (strikeCache.callExposure).multiplyDecimal(\\n        SafeCast.toInt256(strikeCache.greeks.callPrice)\\n      ) + (strikeCache.putExposure).multiplyDecimal(SafeCast.toInt256(strikeCache.greeks.putPrice));\\n\\n      int strikeNetDelta = strikeCache.callExposure.multiplyDecimal(strikeCache.greeks.callDelta) +\\n        strikeCache.putExposure.multiplyDecimal(strikeCache.greeks.putDelta);\\n\\n      int strikeNetStdVega = (strikeCache.callExposure + strikeCache.putExposure).multiplyDecimal(\\n        SafeCast.toInt256(strikeCache.greeks.stdVega)\\n      );\\n\\n      boardCache.netGreeks.netOptionValue += strikeOptionValue;\\n      boardCache.netGreeks.netDelta += strikeNetDelta;\\n      boardCache.netGreeks.netStdVega += strikeNetStdVega;\\n\\n      globalCache.netGreeks.netOptionValue += strikeOptionValue;\\n      globalCache.netGreeks.netDelta += strikeNetDelta;\\n      globalCache.netGreeks.netStdVega += strikeNetStdVega;\\n    }\\n\\n    emit StrikeCacheUpdated(strikeCache);\\n    emit StrikeSkewUpdated(strikeCache.id, strikeCache.skew, globalCache.maxSkewVariance);\\n  }\\n\\n  /// @dev Updates global `lastUpdatedAt`.\\n  function _updateGlobalLastUpdatedAt() internal {\\n    OptionBoardCache storage boardCache = boardCaches[liveBoards[0]];\\n    uint minUpdatedAt = boardCache.updatedAt;\\n    uint minUpdatedAtPrice = boardCache.updatedAtPrice;\\n    uint maxUpdatedAtPrice = boardCache.updatedAtPrice;\\n    uint maxSkewVariance = boardCache.maxSkewVariance;\\n    uint maxIvVariance = boardCache.ivVariance;\\n\\n    for (uint i = 1; i < liveBoards.length; i++) {\\n      boardCache = boardCaches[liveBoards[i]];\\n      if (boardCache.updatedAt < minUpdatedAt) {\\n        minUpdatedAt = boardCache.updatedAt;\\n      }\\n      if (boardCache.updatedAtPrice < minUpdatedAtPrice) {\\n        minUpdatedAtPrice = boardCache.updatedAtPrice;\\n      }\\n      if (boardCache.updatedAtPrice > maxUpdatedAtPrice) {\\n        maxUpdatedAtPrice = boardCache.updatedAtPrice;\\n      }\\n      if (boardCache.maxSkewVariance > maxSkewVariance) {\\n        maxSkewVariance = boardCache.maxSkewVariance;\\n      }\\n      if (boardCache.ivVariance > maxIvVariance) {\\n        maxIvVariance = boardCache.ivVariance;\\n      }\\n    }\\n\\n    globalCache.minUpdatedAt = minUpdatedAt;\\n    globalCache.minUpdatedAtPrice = minUpdatedAtPrice;\\n    globalCache.maxUpdatedAtPrice = maxUpdatedAtPrice;\\n    globalCache.maxSkewVariance = maxSkewVariance;\\n    globalCache.maxIvVariance = maxIvVariance;\\n  }\\n\\n  /////////////////////////\\n  // Updating GWAV values //\\n  /////////////////////////\\n\\n  /// @dev updates baseIv for a given board, updating the baseIv gwav\\n  function _updateBoardIv(OptionBoardCache storage boardCache, uint newIv) internal {\\n    boardCache.iv = newIv;\\n    boardIVGWAV[boardCache.id]._write(newIv, block.timestamp);\\n    _updateBoardIvVariance(boardCache);\\n    _updateMaxIvVariance();\\n\\n    emit BoardIvUpdated(boardCache.id, newIv, globalCache.maxIvVariance);\\n  }\\n\\n  /// @dev updates skew for a given strike, updating the skew gwav\\n  function _updateStrikeSkew(\\n    OptionBoardCache storage boardCache,\\n    StrikeCache storage strikeCache,\\n    uint newSkew\\n  ) internal {\\n    strikeCache.skew = newSkew;\\n\\n    strikeSkewGWAV[strikeCache.id]._write(\\n      _max(_min(newSkew, greekCacheParams.gwavSkewCap), greekCacheParams.gwavSkewFloor),\\n      block.timestamp\\n    );\\n    // Update variance\\n    _updateStrikeSkewVariance(strikeCache);\\n    _updateMaxSkewVariance(boardCache);\\n\\n    emit StrikeSkewUpdated(strikeCache.id, newSkew, globalCache.maxSkewVariance);\\n  }\\n\\n  /// @dev updates maxIvVariance across all boards\\n  function _updateMaxIvVariance() internal {\\n    uint maxIvVariance = boardCaches[liveBoards[0]].ivVariance;\\n    for (uint i = 1; i < liveBoards.length; i++) {\\n      if (boardCaches[liveBoards[i]].ivVariance > maxIvVariance) {\\n        maxIvVariance = boardCaches[liveBoards[i]].ivVariance;\\n      }\\n    }\\n    globalCache.maxIvVariance = maxIvVariance;\\n  }\\n\\n  /// @dev updates skewVariance for strike, used to trigger CBs and charge varianceFees\\n  function _updateStrikeSkewVariance(StrikeCache storage strikeCache) internal {\\n    uint strikeVarianceGWAVSkew = strikeSkewGWAV[strikeCache.id].getGWAVForPeriod(\\n      greekCacheParams.varianceSkewGWAVPeriod,\\n      0\\n    );\\n\\n    if (strikeVarianceGWAVSkew >= strikeCache.skew) {\\n      strikeCache.skewVariance = strikeVarianceGWAVSkew - strikeCache.skew;\\n    } else {\\n      strikeCache.skewVariance = strikeCache.skew - strikeVarianceGWAVSkew;\\n    }\\n  }\\n\\n  /// @dev updates ivVariance for board, used to trigger CBs and charge varianceFees\\n  function _updateBoardIvVariance(OptionBoardCache storage boardCache) internal {\\n    uint boardVarianceGWAVIv = boardIVGWAV[boardCache.id].getGWAVForPeriod(greekCacheParams.varianceIvGWAVPeriod, 0);\\n\\n    if (boardVarianceGWAVIv >= boardCache.iv) {\\n      boardCache.ivVariance = boardVarianceGWAVIv - boardCache.iv;\\n    } else {\\n      boardCache.ivVariance = boardCache.iv - boardVarianceGWAVIv;\\n    }\\n  }\\n\\n  /// @dev updates maxSkewVariance for the board and across all strikes\\n  function _updateMaxSkewVariance(OptionBoardCache storage boardCache) internal {\\n    uint maxBoardSkewVariance = strikeCaches[boardCache.strikes[0]].skewVariance;\\n\\n    for (uint i = 1; i < boardCache.strikes.length; i++) {\\n      if (strikeCaches[boardCache.strikes[i]].skewVariance > maxBoardSkewVariance) {\\n        maxBoardSkewVariance = strikeCaches[boardCache.strikes[i]].skewVariance;\\n      }\\n    }\\n    boardCache.maxSkewVariance = maxBoardSkewVariance;\\n\\n    uint maxSkewVariance = boardCaches[liveBoards[0]].maxSkewVariance;\\n\\n    for (uint i = 1; i < liveBoards.length; i++) {\\n      if (boardCaches[liveBoards[i]].maxSkewVariance > maxSkewVariance) {\\n        maxSkewVariance = boardCaches[liveBoards[i]].maxSkewVariance;\\n      }\\n    }\\n    globalCache.maxSkewVariance = maxSkewVariance;\\n  }\\n\\n  //////////////////////////\\n  // Stale cache checking //\\n  //////////////////////////\\n\\n  /**\\n   * @notice returns `true` if even one board not updated within `staleUpdateDuration` or\\n   *         if spot price moves up/down beyond `acceptablePriceMovement`\\n   */\\n\\n  function isGlobalCacheStale(uint spotPrice) external view returns (bool) {\\n    if (liveBoards.length == 0) {\\n      return false;\\n    } else {\\n      return (_isUpdatedAtTimeStale(globalCache.minUpdatedAt) ||\\n        !_isPriceMoveAcceptable(globalCache.minUpdatedAtPrice, spotPrice) ||\\n        !_isPriceMoveAcceptable(globalCache.maxUpdatedAtPrice, spotPrice));\\n    }\\n  }\\n\\n  /**\\n   * @notice returns `true` if board not updated within `staleUpdateDuration` or\\n   *         if spot price moves up/down beyond `acceptablePriceMovement`\\n   */\\n  function isBoardCacheStale(uint boardId) external view returns (bool) {\\n    uint spotPrice = synthetixAdapter.getSpotPriceForMarket(address(optionMarket));\\n    OptionBoardCache memory boardCache = boardCaches[boardId];\\n    if (boardCache.id == 0) {\\n      revert InvalidBoardId(address(this), boardCache.id);\\n    }\\n    return (_isUpdatedAtTimeStale(boardCache.updatedAt) ||\\n      !_isPriceMoveAcceptable(boardCache.updatedAtPrice, spotPrice));\\n  }\\n\\n  /**\\n   * @notice Check if the price move of base asset renders the cache stale.\\n   *\\n   * @param pastPrice The previous price.\\n   * @param currentPrice The current price.\\n   */\\n  function _isPriceMoveAcceptable(uint pastPrice, uint currentPrice) internal view returns (bool) {\\n    uint acceptablePriceMovement = pastPrice.multiplyDecimal(greekCacheParams.acceptableSpotPricePercentMove);\\n    if (currentPrice > pastPrice) {\\n      return (currentPrice - pastPrice) < acceptablePriceMovement;\\n    } else {\\n      return (pastPrice - currentPrice) < acceptablePriceMovement;\\n    }\\n  }\\n\\n  /**\\n   * @notice Checks if board updated within `staleUpdateDuration`.\\n   *\\n   * @param updatedAt The time of the last update.\\n   */\\n  function _isUpdatedAtTimeStale(uint updatedAt) internal view returns (bool) {\\n    // This can be more complex than just checking the item wasn't updated in the last two hours\\n    return _getSecondsTo(updatedAt, block.timestamp) > greekCacheParams.staleUpdateDuration;\\n  }\\n\\n  /////////////////////////////\\n  // External View functions //\\n  /////////////////////////////\\n\\n  /// @notice Get the current cached global netDelta exposure.\\n  function getGlobalNetDelta() external view returns (int) {\\n    return globalCache.netGreeks.netDelta;\\n  }\\n\\n  /// @notice Get the current global net option value\\n  function getGlobalOptionValue() external view returns (int) {\\n    return globalCache.netGreeks.netOptionValue;\\n  }\\n\\n  /// @notice Returns the BoardGreeksView struct given a specific boardId\\n  function getBoardGreeksView(uint boardId) external view returns (BoardGreeksView memory) {\\n    StrikeGreeks[] memory strikeGreeks = new StrikeGreeks[](boardCaches[boardId].strikes.length);\\n    uint[] memory skewGWAVs = new uint[](boardCaches[boardId].strikes.length);\\n\\n    for (uint i = 0; i < boardCaches[boardId].strikes.length; i++) {\\n      strikeGreeks[i] = strikeCaches[boardCaches[boardId].strikes[i]].greeks;\\n      skewGWAVs[i] = strikeSkewGWAV[boardCaches[boardId].strikes[i]].getGWAVForPeriod(\\n        forceCloseParams.skewGWAVPeriod,\\n        0\\n      );\\n    }\\n    return\\n      BoardGreeksView({\\n        boardGreeks: boardCaches[boardId].netGreeks,\\n        ivGWAV: boardIVGWAV[boardId].getGWAVForPeriod(forceCloseParams.ivGWAVPeriod, 0),\\n        strikeGreeks: strikeGreeks,\\n        skewGWAVs: skewGWAVs\\n      });\\n  }\\n\\n  /// @notice Get StrikeCache given a specific strikeId\\n  function getStrikeCache(uint strikeId) external view returns (StrikeCache memory) {\\n    return (strikeCaches[strikeId]);\\n  }\\n\\n  /// @notice Get OptionBoardCache given a specific boardId\\n  function getOptionBoardCache(uint boardId) external view returns (OptionBoardCache memory) {\\n    return (boardCaches[boardId]);\\n  }\\n\\n  /// @notice Get the global cache\\n  function getGlobalCache() external view returns (GlobalCache memory) {\\n    return globalCache;\\n  }\\n\\n  /// @notice Returns ivGWAV for a given boardId and GWAV time interval\\n  function getIvGWAV(uint boardId, uint secondsAgo) external view returns (uint ivGWAV) {\\n    return boardIVGWAV[boardId].getGWAVForPeriod(secondsAgo, 0);\\n  }\\n\\n  /// @notice Returns skewGWAV for a given strikeId and GWAV time interval\\n  function getSkewGWAV(uint strikeId, uint secondsAgo) external view returns (uint skewGWAV) {\\n    return strikeSkewGWAV[strikeId].getGWAVForPeriod(secondsAgo, 0);\\n  }\\n\\n  /// @notice Get the GreekCacheParameters\\n  function getGreekCacheParams() external view returns (GreekCacheParameters memory) {\\n    return greekCacheParams;\\n  }\\n\\n  /// @notice Get the ForceCloseParamters\\n  function getForceCloseParams() external view returns (ForceCloseParameters memory) {\\n    return forceCloseParams;\\n  }\\n\\n  /// @notice Get the MinCollateralParamters\\n  function getMinCollatParams() external view returns (MinCollateralParameters memory) {\\n    return minCollatParams;\\n  }\\n\\n  ////////////////////////////\\n  // Utility/Math functions //\\n  ////////////////////////////\\n\\n  /// @dev Calculate option payout on expiry given a strikePrice, spot on expiry and optionType.\\n  function _getParity(\\n    uint strikePrice,\\n    uint spot,\\n    OptionMarket.OptionType optionType\\n  ) internal pure returns (uint parity) {\\n    int diff = (optionType == OptionMarket.OptionType.LONG_PUT || optionType == OptionMarket.OptionType.SHORT_PUT_QUOTE)\\n      ? SafeCast.toInt256(strikePrice) - SafeCast.toInt256(spot)\\n      : SafeCast.toInt256(spot) - SafeCast.toInt256(strikePrice);\\n\\n    parity = diff > 0 ? uint(diff) : 0;\\n  }\\n\\n  /// @dev Returns time to maturity for a given expiry.\\n  function _timeToMaturitySeconds(uint expiry) internal view returns (uint) {\\n    return _getSecondsTo(block.timestamp, expiry);\\n  }\\n\\n  /// @dev Returns the difference in seconds between two dates.\\n  function _getSecondsTo(uint fromTime, uint toTime) internal pure returns (uint) {\\n    if (toTime > fromTime) {\\n      return toTime - fromTime;\\n    }\\n    return 0;\\n  }\\n\\n  function _min(uint x, uint y) internal pure returns (uint) {\\n    return (x < y) ? x : y;\\n  }\\n\\n  function _max(uint x, uint y) internal pure returns (uint) {\\n    return (x > y) ? x : y;\\n  }\\n\\n  ///////////////\\n  // Modifiers //\\n  ///////////////\\n  modifier onlyOptionMarket() {\\n    if (msg.sender != address(optionMarket)) {\\n      revert OnlyOptionMarket(address(this), msg.sender, address(optionMarket));\\n    }\\n    _;\\n  }\\n\\n  modifier onlyOptionMarketPricer() {\\n    if (msg.sender != address(optionMarketPricer)) {\\n      revert OnlyOptionMarketPricer(address(this), msg.sender, address(optionMarketPricer));\\n    }\\n    _;\\n  }\\n\\n  ////////////\\n  // Events //\\n  ////////////\\n  event GreekCacheParametersSet(GreekCacheParameters params);\\n  event ForceCloseParametersSet(ForceCloseParameters params);\\n  event MinCollateralParametersSet(MinCollateralParameters params);\\n\\n  event StrikeCacheUpdated(StrikeCache strikeCache);\\n  event BoardCacheUpdated(OptionBoardCache boardCache);\\n  event GlobalCacheUpdated(GlobalCache globalCache);\\n\\n  event BoardCacheRemoved(uint boardId);\\n  event StrikeCacheRemoved(uint strikeId);\\n  event BoardIvUpdated(uint boardId, uint newIv, uint globalMaxIvVariance);\\n  event StrikeSkewUpdated(uint strikeId, uint newSkew, uint globalMaxSkewVariance);\\n\\n  ////////////\\n  // Errors //\\n  ////////////\\n  // Admin\\n  error InvalidGreekCacheParameters(address thrower, GreekCacheParameters greekCacheParams);\\n  error InvalidForceCloseParameters(address thrower, ForceCloseParameters forceCloseParams);\\n  error InvalidMinCollatParams(address thrower, MinCollateralParameters minCollatParams);\\n\\n  // Board related\\n  error BoardStrikeLimitExceeded(address thrower, uint boardId, uint newStrikesLength, uint maxStrikesPerBoard);\\n  error InvalidBoardId(address thrower, uint boardId);\\n  error CannotUpdateExpiredBoard(address thrower, uint boardId, uint expiry, uint currentTimestamp);\\n\\n  // Access\\n  error OnlyOptionMarket(address thrower, address caller, address optionMarket);\\n  error OnlyOptionMarketPricer(address thrower, address caller, address optionMarketPricer);\\n}\\n\",\"keccak256\":\"0xee65c24cc82e5572ac95e6753f6944fd860e06cd67505dad48450ef9cae0692d\",\"license\":\"ISC\"},\"@lyrafinance/protocol/contracts/OptionMarket.sol\":{\"content\":\"//SPDX-License-Identifier: ISC\\npragma solidity 0.8.9;\\n\\n// Libraries\\nimport \\\"./synthetix/DecimalMath.sol\\\";\\nimport \\\"openzeppelin-contracts-4.4.1/utils/math/SafeCast.sol\\\";\\n\\n// Inherited\\nimport \\\"./synthetix/Owned.sol\\\";\\nimport \\\"./libraries/SimpleInitializeable.sol\\\";\\nimport \\\"openzeppelin-contracts-4.4.1/security/ReentrancyGuard.sol\\\";\\n\\n// Interfaces\\nimport \\\"openzeppelin-contracts-4.4.1/token/ERC20/IERC20.sol\\\";\\nimport \\\"./SynthetixAdapter.sol\\\";\\nimport \\\"./LiquidityPool.sol\\\";\\nimport \\\"./OptionToken.sol\\\";\\nimport \\\"./OptionGreekCache.sol\\\";\\nimport \\\"./SynthetixAdapter.sol\\\";\\nimport \\\"./ShortCollateral.sol\\\";\\nimport \\\"./OptionMarketPricer.sol\\\";\\n\\n/**\\n * @title OptionMarket\\n * @author Lyra\\n * @dev An AMM which allows users to trade options. Supports both buying and selling options. Also handles liquidating\\n * short positions.\\n */\\ncontract OptionMarket is Owned, SimpleInitializeable, ReentrancyGuard {\\n  using DecimalMath for uint;\\n\\n  enum TradeDirection {\\n    OPEN,\\n    CLOSE,\\n    LIQUIDATE\\n  }\\n\\n  enum OptionType {\\n    LONG_CALL,\\n    LONG_PUT,\\n    SHORT_CALL_BASE,\\n    SHORT_CALL_QUOTE,\\n    SHORT_PUT_QUOTE\\n  }\\n\\n  /// @notice For returning more specific errors\\n  enum NonZeroValues {\\n    BASE_IV,\\n    SKEW,\\n    STRIKE_PRICE,\\n    ITERATIONS,\\n    STRIKE_ID\\n  }\\n\\n  ///////////////////\\n  // Internal Data //\\n  ///////////////////\\n\\n  struct Strike {\\n    // strike listing identifier\\n    uint id;\\n    // strike price\\n    uint strikePrice;\\n    // volatility component specific to the strike listing (boardIv * skew = vol of strike)\\n    uint skew;\\n    // total user long call exposure\\n    uint longCall;\\n    // total user short call (base collateral) exposure\\n    uint shortCallBase;\\n    // total user short call (quote collateral) exposure\\n    uint shortCallQuote;\\n    // total user long put exposure\\n    uint longPut;\\n    // total user short put (quote collateral) exposure\\n    uint shortPut;\\n    // id of board to which strike belongs\\n    uint boardId;\\n  }\\n\\n  struct OptionBoard {\\n    // board identifier\\n    uint id;\\n    // expiry of all strikes belonging to board\\n    uint expiry;\\n    // volatility component specific to board (boardIv * skew = vol of strike)\\n    uint iv;\\n    // admin settable flag blocking all trading on this board\\n    bool frozen;\\n    // list of all strikes belonging to this board\\n    uint[] strikeIds;\\n  }\\n\\n  ///////////////\\n  // In-memory //\\n  ///////////////\\n\\n  struct OptionMarketParameters {\\n    // max allowable expiry of added boards\\n    uint maxBoardExpiry;\\n    // security module address\\n    address securityModule;\\n    // fee portion reserved for Lyra DAO\\n    uint feePortionReserved;\\n    // expected fee charged to LPs, used for pricing short_call_base settlement\\n    uint staticBaseSettlementFee;\\n  }\\n\\n  struct TradeInputParameters {\\n    // id of strike\\n    uint strikeId;\\n    // OptionToken ERC721 id for position (set to 0 for new positions)\\n    uint positionId;\\n    // number of sub-orders to break order into (reduces slippage)\\n    uint iterations;\\n    // type of option to trade\\n    OptionType optionType;\\n    // number of contracts to trade\\n    uint amount;\\n    // final amount of collateral to leave in OptionToken position\\n    uint setCollateralTo;\\n    // revert trade if totalCost is below this value\\n    uint minTotalCost;\\n    // revert trade if totalCost is above this value\\n    uint maxTotalCost;\\n  }\\n\\n  struct TradeParameters {\\n    bool isBuy;\\n    bool isForceClose;\\n    TradeDirection tradeDirection;\\n    OptionType optionType;\\n    uint amount;\\n    uint expiry;\\n    uint strikePrice;\\n    LiquidityPool.Liquidity liquidity;\\n    SynthetixAdapter.ExchangeParams exchangeParams;\\n  }\\n\\n  struct TradeEventData {\\n    uint expiry;\\n    uint strikePrice;\\n    OptionType optionType;\\n    TradeDirection tradeDirection;\\n    uint amount;\\n    uint setCollateralTo;\\n    bool isForceClose;\\n    uint spotPrice;\\n    uint reservedFee;\\n    uint totalCost;\\n  }\\n\\n  struct LiquidationEventData {\\n    address rewardBeneficiary;\\n    address caller;\\n    uint returnCollateral; // quote || base\\n    uint lpPremiums; // quote || base\\n    uint lpFee; // quote || base\\n    uint liquidatorFee; // quote || base\\n    uint smFee; // quote || base\\n    uint insolventAmount; // quote\\n  }\\n\\n  struct Result {\\n    uint positionId;\\n    uint totalCost;\\n    uint totalFee;\\n  }\\n\\n  ///////////////\\n  // Variables //\\n  ///////////////\\n\\n  SynthetixAdapter internal synthetixAdapter;\\n  LiquidityPool internal liquidityPool;\\n  OptionMarketPricer internal optionPricer;\\n  OptionGreekCache internal greekCache;\\n  ShortCollateral internal shortCollateral;\\n  OptionToken internal optionToken;\\n  IERC20 internal quoteAsset;\\n  IERC20 internal baseAsset;\\n\\n  uint internal nextStrikeId = 1;\\n  uint internal nextBoardId = 1;\\n  uint[] internal liveBoards;\\n\\n  OptionMarketParameters internal optionMarketParams;\\n\\n  mapping(uint => OptionBoard) internal optionBoards;\\n  mapping(uint => Strike) internal strikes;\\n  mapping(uint => uint) public boardToPriceAtExpiry;\\n  mapping(uint => uint) internal strikeToBaseReturnedRatio;\\n\\n  constructor() Owned() {}\\n\\n  /**\\n   * @dev Initialize the contract.\\n   */\\n  function init(\\n    SynthetixAdapter _synthetixAdapter,\\n    LiquidityPool _liquidityPool,\\n    OptionMarketPricer _optionPricer,\\n    OptionGreekCache _greekCache,\\n    ShortCollateral _shortCollateral,\\n    OptionToken _optionToken,\\n    IERC20 _quoteAsset,\\n    IERC20 _baseAsset\\n  ) external onlyOwner initializer {\\n    synthetixAdapter = _synthetixAdapter;\\n    liquidityPool = _liquidityPool;\\n    optionPricer = _optionPricer;\\n    greekCache = _greekCache;\\n    shortCollateral = _shortCollateral;\\n    optionToken = _optionToken;\\n    quoteAsset = _quoteAsset;\\n    baseAsset = _baseAsset;\\n  }\\n\\n  /////////////////////\\n  // Admin functions //\\n  /////////////////////\\n\\n  /**\\n   * @notice Creates a new OptionBoard with defined strikePrices and initial skews.\\n   *\\n   * @param expiry The timestamp when the board expires.\\n   * @param baseIV The initial value for baseIv (baseIv * skew = strike volatility).\\n   * @param strikePrices The array of strikePrices offered for this expiry.\\n   * @param skews The array of initial skews for each strikePrice.\\n   * @param frozen Whether the board is frozen or not at creation.\\n   */\\n  function createOptionBoard(\\n    uint expiry,\\n    uint baseIV,\\n    uint[] memory strikePrices,\\n    uint[] memory skews,\\n    bool frozen\\n  ) external onlyOwner returns (uint boardId) {\\n    // strikePrice and skew length must match and must have at least 1\\n    if (strikePrices.length != skews.length || strikePrices.length == 0) {\\n      revert StrikeSkewLengthMismatch(address(this), strikePrices.length, skews.length);\\n    }\\n\\n    if (expiry <= block.timestamp || expiry > block.timestamp + optionMarketParams.maxBoardExpiry) {\\n      revert InvalidExpiryTimestamp(address(this), block.timestamp, expiry, optionMarketParams.maxBoardExpiry);\\n    }\\n\\n    if (baseIV == 0) {\\n      revert ExpectedNonZeroValue(address(this), NonZeroValues.BASE_IV);\\n    }\\n\\n    boardId = nextBoardId++;\\n    OptionBoard storage board = optionBoards[boardId];\\n    board.id = boardId;\\n    board.expiry = expiry;\\n    board.iv = baseIV;\\n    board.frozen = frozen;\\n\\n    liveBoards.push(boardId);\\n\\n    emit BoardCreated(boardId, expiry, baseIV, frozen);\\n\\n    Strike[] memory newStrikes = new Strike[](strikePrices.length);\\n    for (uint i = 0; i < strikePrices.length; i++) {\\n      newStrikes[i] = _addStrikeToBoard(board, strikePrices[i], skews[i]);\\n    }\\n\\n    greekCache.addBoard(board, newStrikes);\\n\\n    return boardId;\\n  }\\n\\n  /**\\n   * @notice Sets the frozen state of an OptionBoard, preventing or allowing all trading on board.\\n   * @param boardId The id of the OptionBoard.\\n   * @param frozen Whether the board will be frozen or not.\\n   */\\n  function setBoardFrozen(uint boardId, bool frozen) external onlyOwner {\\n    OptionBoard storage board = optionBoards[boardId];\\n    if (board.id != boardId || board.id == 0) {\\n      revert InvalidBoardId(address(this), boardId);\\n    }\\n    optionBoards[boardId].frozen = frozen;\\n    emit BoardFrozen(boardId, frozen);\\n  }\\n\\n  /**\\n   * @notice Sets the baseIv of a frozen OptionBoard.\\n   *\\n   * @param boardId The id of the OptionBoard.\\n   * @param baseIv The new baseIv value.\\n   */\\n  function setBoardBaseIv(uint boardId, uint baseIv) external onlyOwner {\\n    OptionBoard storage board = optionBoards[boardId];\\n    if (board.id != boardId || board.id == 0) {\\n      revert InvalidBoardId(address(this), boardId);\\n    }\\n    if (baseIv == 0) {\\n      revert ExpectedNonZeroValue(address(this), NonZeroValues.BASE_IV);\\n    }\\n    if (!board.frozen) {\\n      revert BoardNotFrozen(address(this), boardId);\\n    }\\n\\n    board.iv = baseIv;\\n    greekCache.setBoardIv(boardId, baseIv);\\n    emit BoardBaseIvSet(boardId, baseIv);\\n  }\\n\\n  /**\\n   * @notice Sets the skew of a Strike of a frozen OptionBoard.\\n   *\\n   * @param strikeId The id of the strike being modified.\\n   * @param skew The new skew value.\\n   */\\n  function setStrikeSkew(uint strikeId, uint skew) external onlyOwner {\\n    Strike storage strike = strikes[strikeId];\\n    if (strike.id != strikeId) {\\n      revert InvalidStrikeId(address(this), strikeId);\\n    }\\n    if (skew == 0) {\\n      revert ExpectedNonZeroValue(address(this), NonZeroValues.SKEW);\\n    }\\n\\n    OptionBoard memory board = optionBoards[strike.boardId];\\n    if (!board.frozen) {\\n      revert BoardNotFrozen(address(this), board.id);\\n    }\\n\\n    strike.skew = skew;\\n    greekCache.setStrikeSkew(strikeId, skew);\\n    emit StrikeSkewSet(strikeId, skew);\\n  }\\n\\n  /**\\n   * @notice Add a strike to an existing board in the OptionMarket.\\n   *\\n   * @param boardId The id of the board which the strike will be added\\n   * @param strikePrice The strike price of the strike being added\\n   * @param skew Skew of the Strike\\n   */\\n  function addStrikeToBoard(\\n    uint boardId,\\n    uint strikePrice,\\n    uint skew\\n  ) external onlyOwner {\\n    OptionBoard storage board = optionBoards[boardId];\\n    if (board.id != boardId || board.id == 0) {\\n      revert InvalidBoardId(address(this), boardId);\\n    }\\n    Strike memory strike = _addStrikeToBoard(board, strikePrice, skew);\\n    greekCache.addStrikeToBoard(boardId, strike.id, strikePrice, skew);\\n  }\\n\\n  /// @dev Add a strike to an existing board.\\n  function _addStrikeToBoard(\\n    OptionBoard storage board,\\n    uint strikePrice,\\n    uint skew\\n  ) internal returns (Strike memory) {\\n    if (strikePrice == 0) {\\n      revert ExpectedNonZeroValue(address(this), NonZeroValues.STRIKE_PRICE);\\n    }\\n    if (skew == 0) {\\n      revert ExpectedNonZeroValue(address(this), NonZeroValues.SKEW);\\n    }\\n\\n    uint strikeId = nextStrikeId++;\\n    strikes[strikeId] = Strike(strikeId, strikePrice, skew, 0, 0, 0, 0, 0, board.id);\\n    board.strikeIds.push(strikeId);\\n    emit StrikeAdded(board.id, strikeId, strikePrice, skew);\\n    return strikes[strikeId];\\n  }\\n\\n  /**\\n   * @notice Force settle all open options before expiry.\\n   * @dev Only used during emergency situations.\\n   *\\n   * @param boardId The id of the board to settle\\n   */\\n  function forceSettleBoard(uint boardId) external onlyOwner {\\n    OptionBoard memory board = optionBoards[boardId];\\n    if (board.id != boardId || board.id == 0) {\\n      revert InvalidBoardId(address(this), boardId);\\n    }\\n    if (!board.frozen) {\\n      revert BoardNotFrozen(address(this), boardId);\\n    }\\n    _clearAndSettleBoard(board);\\n  }\\n\\n  /// @notice set OptionMarketParams\\n  function setOptionMarketParams(OptionMarketParameters memory _optionMarketParams) external onlyOwner {\\n    if (_optionMarketParams.feePortionReserved > DecimalMath.UNIT) {\\n      revert InvalidOptionMarketParams(address(this), _optionMarketParams);\\n    }\\n    optionMarketParams = _optionMarketParams;\\n    emit OptionMarketParamsSet(optionMarketParams);\\n  }\\n\\n  /// @notice claim all reserved option fees\\n  function smClaim() external notGlobalPaused {\\n    if (msg.sender != optionMarketParams.securityModule) {\\n      revert OnlySecurityModule(address(this), msg.sender, optionMarketParams.securityModule);\\n    }\\n    uint quoteBal = quoteAsset.balanceOf(address(this));\\n    if (quoteBal > 0 && !quoteAsset.transfer(msg.sender, quoteBal)) {\\n      revert QuoteTransferFailed(address(this), address(this), msg.sender, quoteBal);\\n    }\\n    // While fees cannot accrue in base, this can help reclaim any accidental transfers into this contract\\n    uint baseBal = baseAsset.balanceOf(address(this));\\n    if (baseBal > 0 && !baseAsset.transfer(msg.sender, baseBal)) {\\n      revert BaseTransferFailed(address(this), address(this), msg.sender, baseBal);\\n    }\\n    emit SMClaimed(msg.sender, quoteBal, baseBal);\\n  }\\n\\n  ///////////\\n  // Views //\\n  ///////////\\n\\n  function getOptionMarketParams() external view returns (OptionMarketParameters memory) {\\n    return optionMarketParams;\\n  }\\n\\n  /**\\n   * @notice Returns the list of live board ids.\\n   */\\n  function getLiveBoards() external view returns (uint[] memory _liveBoards) {\\n    _liveBoards = new uint[](liveBoards.length);\\n    for (uint i = 0; i < liveBoards.length; i++) {\\n      _liveBoards[i] = liveBoards[i];\\n    }\\n    return _liveBoards;\\n  }\\n\\n  /// @notice Returns the number of current live boards\\n  function getNumLiveBoards() external view returns (uint numLiveBoards) {\\n    return liveBoards.length;\\n  }\\n\\n  /// @notice Returns the strike and expiry for a given strikeId\\n  function getStrikeAndExpiry(uint strikeId) external view returns (uint strikePrice, uint expiry) {\\n    return (strikes[strikeId].strikePrice, optionBoards[strikes[strikeId].boardId].expiry);\\n  }\\n\\n  /**\\n   * @notice Returns the strike ids for a given `boardId`.\\n   *\\n   * @param boardId The id of the relevant OptionBoard.\\n   */\\n  function getBoardStrikes(uint boardId) external view returns (uint[] memory strikeIds) {\\n    strikeIds = new uint[](optionBoards[boardId].strikeIds.length);\\n    for (uint i = 0; i < optionBoards[boardId].strikeIds.length; i++) {\\n      strikeIds[i] = optionBoards[boardId].strikeIds[i];\\n    }\\n    return strikeIds;\\n  }\\n\\n  /// @notice Returns the Strike struct for a given strikeId\\n  function getStrike(uint strikeId) external view returns (Strike memory) {\\n    return strikes[strikeId];\\n  }\\n\\n  /// @notice Returns the OptionBoard struct for a given boardId\\n  function getOptionBoard(uint boardId) external view returns (OptionBoard memory) {\\n    return optionBoards[boardId];\\n  }\\n\\n  /// @notice Returns the Strike and OptionBoard structs for a given strikeId\\n  function getStrikeAndBoard(uint strikeId) external view returns (Strike memory, OptionBoard memory) {\\n    Strike memory strike = strikes[strikeId];\\n    return (strike, optionBoards[strike.boardId]);\\n  }\\n\\n  /**\\n   * @notice Returns board and strike details given a boardId\\n   *\\n   * @return OptionBoard the OptionBoard struct\\n   * @return Strike[] the list of board strikes\\n   * @return uint[] the list of strike to base returned ratios\\n   * @return uint the board to price at expiry\\n   */\\n  function getBoardAndStrikeDetails(uint boardId)\\n    external\\n    view\\n    returns (\\n      OptionBoard memory,\\n      Strike[] memory,\\n      uint[] memory,\\n      uint\\n    )\\n  {\\n    OptionBoard memory board = optionBoards[boardId];\\n    Strike[] memory boardStrikes = new Strike[](board.strikeIds.length);\\n    uint[] memory strikeToBaseReturnedRatios = new uint[](board.strikeIds.length);\\n    for (uint i = 0; i < board.strikeIds.length; i++) {\\n      boardStrikes[i] = strikes[board.strikeIds[i]];\\n      strikeToBaseReturnedRatios[i] = strikeToBaseReturnedRatio[board.strikeIds[i]];\\n    }\\n    return (board, boardStrikes, strikeToBaseReturnedRatios, boardToPriceAtExpiry[boardId]);\\n  }\\n\\n  ////////////////////\\n  // User functions //\\n  ////////////////////\\n\\n  /**\\n   * @notice Attempts to open positions within cost bounds.\\n   * @dev If a positionId is specified that position is adjusted accordingly\\n   *\\n   * @param params The parameters for the requested trade\\n   */\\n  function openPosition(TradeInputParameters memory params) external nonReentrant returns (Result memory result) {\\n    result = _openPosition(params);\\n    _checkCostInBounds(result.totalCost, params.minTotalCost, params.maxTotalCost);\\n  }\\n\\n  /**\\n   * @notice Attempts to reduce or fully close position within cost bounds.\\n   *\\n   * @param params The parameters for the requested trade\\n   */\\n  function closePosition(TradeInputParameters memory params) external nonReentrant returns (Result memory result) {\\n    result = _closePosition(params, false);\\n    _checkCostInBounds(result.totalCost, params.minTotalCost, params.maxTotalCost);\\n  }\\n\\n  /**\\n   * @notice Attempts to reduce or fully close position within cost bounds while ignoring delta trading cutoffs.\\n   *\\n   * @param params The parameters for the requested trade\\n   */\\n  function forceClosePosition(TradeInputParameters memory params) external nonReentrant returns (Result memory result) {\\n    result = _closePosition(params, true);\\n    _checkCostInBounds(result.totalCost, params.minTotalCost, params.maxTotalCost);\\n  }\\n\\n  /**\\n   * @notice Add collateral of size amountCollateral onto a short position (long or call) specified by positionId;\\n   *         this transfers tokens (which may be denominated in the quote or the base asset). This allows you to\\n   *         further collateralise a short position in order to, say, prevent imminent liquidation.\\n   *\\n   * @param positionId id of OptionToken to add collateral to\\n   * @param amountCollateral the amount of collateral to be added\\n   */\\n  function addCollateral(uint positionId, uint amountCollateral) external nonReentrant notGlobalPaused {\\n    int pendingCollateral = SafeCast.toInt256(amountCollateral);\\n    OptionType optionType = optionToken.addCollateral(positionId, amountCollateral);\\n    _routeUserCollateral(optionType, pendingCollateral);\\n  }\\n\\n  function _checkCostInBounds(\\n    uint totalCost,\\n    uint minCost,\\n    uint maxCost\\n  ) internal view {\\n    if (totalCost < minCost || totalCost > maxCost) {\\n      revert TotalCostOutsideOfSpecifiedBounds(address(this), totalCost, minCost, maxCost);\\n    }\\n  }\\n\\n  /////////////////////////\\n  // Opening and Closing //\\n  /////////////////////////\\n\\n  /**\\n   * @dev Opens a position, which may be long call, long put, short call or short put.\\n   */\\n  function _openPosition(TradeInputParameters memory params) internal returns (Result memory result) {\\n    (TradeParameters memory trade, Strike storage strike, OptionBoard storage board) = _composeTrade(\\n      params.strikeId,\\n      params.optionType,\\n      params.amount,\\n      TradeDirection.OPEN,\\n      params.iterations,\\n      false\\n    );\\n    OptionMarketPricer.TradeResult[] memory tradeResults;\\n    (trade.amount, result.totalCost, result.totalFee, tradeResults) = _doTrade(\\n      strike,\\n      board,\\n      trade,\\n      params.iterations,\\n      params.amount\\n    );\\n\\n    int pendingCollateral;\\n    // collateral logic happens within optionToken\\n    (result.positionId, pendingCollateral) = optionToken.adjustPosition(\\n      trade,\\n      params.strikeId,\\n      msg.sender,\\n      params.positionId,\\n      result.totalCost,\\n      params.setCollateralTo,\\n      true\\n    );\\n\\n    uint reservedFee = result.totalFee.multiplyDecimal(optionMarketParams.feePortionReserved);\\n\\n    _routeLPFundsOnOpen(trade, result.totalCost, reservedFee);\\n    _routeUserCollateral(trade.optionType, pendingCollateral);\\n    liquidityPool.updateCBs();\\n\\n    emit Trade(\\n      msg.sender,\\n      params.strikeId,\\n      result.positionId,\\n      TradeEventData({\\n        expiry: trade.expiry,\\n        strikePrice: trade.strikePrice,\\n        optionType: params.optionType,\\n        tradeDirection: TradeDirection.OPEN,\\n        amount: trade.amount,\\n        setCollateralTo: params.setCollateralTo,\\n        isForceClose: false,\\n        spotPrice: trade.exchangeParams.spotPrice,\\n        reservedFee: reservedFee,\\n        totalCost: result.totalCost\\n      }),\\n      tradeResults,\\n      LiquidationEventData(address(0), address(0), 0, 0, 0, 0, 0, 0),\\n      block.timestamp\\n    );\\n  }\\n\\n  /**\\n   * @dev Closes some amount of an open position. The user does not have to close the whole position.\\n   *\\n   */\\n  function _closePosition(TradeInputParameters memory params, bool forceClose) internal returns (Result memory result) {\\n    (TradeParameters memory trade, Strike storage strike, OptionBoard storage board) = _composeTrade(\\n      params.strikeId,\\n      params.optionType,\\n      params.amount,\\n      TradeDirection.CLOSE,\\n      params.iterations,\\n      forceClose\\n    );\\n\\n    OptionMarketPricer.TradeResult[] memory tradeResults;\\n    (trade.amount, result.totalCost, result.totalFee, tradeResults) = _doTrade(\\n      strike,\\n      board,\\n      trade,\\n      params.iterations,\\n      params.amount\\n    );\\n\\n    int pendingCollateral;\\n    // collateral logic happens within optionToken\\n    (result.positionId, pendingCollateral) = optionToken.adjustPosition(\\n      trade,\\n      params.strikeId,\\n      msg.sender,\\n      params.positionId,\\n      result.totalCost,\\n      params.setCollateralTo,\\n      false\\n    );\\n\\n    uint reservedFee = result.totalFee.multiplyDecimal(optionMarketParams.feePortionReserved);\\n\\n    _routeUserCollateral(trade.optionType, pendingCollateral);\\n    _routeLPFundsOnClose(trade, result.totalCost, reservedFee);\\n    liquidityPool.updateCBs();\\n\\n    emit Trade(\\n      msg.sender,\\n      params.strikeId,\\n      result.positionId,\\n      TradeEventData({\\n        expiry: trade.expiry,\\n        strikePrice: trade.strikePrice,\\n        optionType: params.optionType,\\n        tradeDirection: TradeDirection.CLOSE,\\n        amount: params.amount,\\n        setCollateralTo: params.setCollateralTo,\\n        isForceClose: forceClose,\\n        reservedFee: reservedFee,\\n        spotPrice: trade.exchangeParams.spotPrice,\\n        totalCost: result.totalCost\\n      }),\\n      tradeResults,\\n      LiquidationEventData(address(0), address(0), 0, 0, 0, 0, 0, 0),\\n      block.timestamp\\n    );\\n  }\\n\\n  /**\\n   * @dev Compile all trade related details\\n   */\\n  function _composeTrade(\\n    uint strikeId,\\n    OptionType optionType,\\n    uint amount,\\n    TradeDirection _tradeDirection,\\n    uint iterations,\\n    bool isForceClose\\n  )\\n    internal\\n    view\\n    returns (\\n      TradeParameters memory trade,\\n      Strike storage strike,\\n      OptionBoard storage board\\n    )\\n  {\\n    if (strikeId == 0) {\\n      revert ExpectedNonZeroValue(address(this), NonZeroValues.STRIKE_ID);\\n    }\\n    if (iterations == 0) {\\n      revert ExpectedNonZeroValue(address(this), NonZeroValues.ITERATIONS);\\n    }\\n\\n    strike = strikes[strikeId];\\n    if (strike.id != strikeId) {\\n      revert InvalidStrikeId(address(this), strikeId);\\n    }\\n    board = optionBoards[strike.boardId];\\n\\n    if (boardToPriceAtExpiry[board.id] != 0) {\\n      revert BoardAlreadySettled(address(this), board.id);\\n    }\\n\\n    bool isBuy = (_tradeDirection == TradeDirection.OPEN) ? _isLong(optionType) : !_isLong(optionType);\\n\\n    SynthetixAdapter.ExchangeParams memory exchangeParams = synthetixAdapter.getExchangeParams(address(this));\\n\\n    trade = TradeParameters({\\n      isBuy: isBuy,\\n      isForceClose: isForceClose,\\n      tradeDirection: _tradeDirection,\\n      optionType: optionType,\\n      amount: amount / iterations,\\n      expiry: board.expiry,\\n      strikePrice: strike.strikePrice,\\n      exchangeParams: exchangeParams,\\n      liquidity: liquidityPool.getLiquidity(exchangeParams.spotPrice)\\n    });\\n  }\\n\\n  function _isLong(OptionType optionType) internal pure returns (bool) {\\n    return (optionType == OptionType.LONG_CALL || optionType == OptionType.LONG_PUT);\\n  }\\n\\n  /**\\n   * @dev Determine the cost of the trade and update the system's iv/skew/exposure parameters.\\n   *\\n   * @param strike The currently traded Strike.\\n   * @param board The currently traded OptionBoard.\\n   * @param trade The trade parameters struct, informing the trade the caller wants to make.\\n   */\\n  function _doTrade(\\n    Strike storage strike,\\n    OptionBoard storage board,\\n    TradeParameters memory trade,\\n    uint iterations,\\n    uint expectedAmount\\n  )\\n    internal\\n    returns (\\n      uint totalAmount,\\n      uint totalCost,\\n      uint totalFee,\\n      OptionMarketPricer.TradeResult[] memory tradeResults\\n    )\\n  {\\n    // don't engage AMM if only collateral is added/removed\\n    if (trade.amount == 0) {\\n      if (expectedAmount != 0) {\\n        revert TradeIterationsHasRemainder(address(this), iterations, expectedAmount, 0, 0);\\n      }\\n      return (0, 0, 0, new OptionMarketPricer.TradeResult[](0));\\n    }\\n\\n    if (board.frozen) {\\n      revert BoardIsFrozen(address(this), board.id);\\n    }\\n    if (block.timestamp >= board.expiry) {\\n      revert BoardExpired(address(this), board.id, board.expiry, block.timestamp);\\n    }\\n\\n    tradeResults = new OptionMarketPricer.TradeResult[](iterations);\\n\\n    for (uint i = 0; i < iterations; i++) {\\n      if (i == iterations - 1) {\\n        trade.amount = expectedAmount - totalAmount;\\n      }\\n      _updateExposure(trade.amount, trade.optionType, strike, trade.tradeDirection == TradeDirection.OPEN);\\n\\n      OptionMarketPricer.TradeResult memory tradeResult = optionPricer.updateCacheAndGetTradeResult(\\n        strike,\\n        trade,\\n        board.iv,\\n        board.expiry\\n      );\\n\\n      board.iv = tradeResult.newBaseIv;\\n      strike.skew = tradeResult.newSkew;\\n\\n      totalCost += tradeResult.totalCost;\\n      totalFee += tradeResult.totalFee;\\n      totalAmount += trade.amount;\\n\\n      tradeResults[i] = tradeResult;\\n    }\\n\\n    return (totalAmount, totalCost, totalFee, tradeResults);\\n  }\\n\\n  /////////////////\\n  // Liquidation //\\n  /////////////////\\n\\n  /**\\n   * @dev Allows anyone to liquidate an underwater position\\n   *\\n   * @param positionId the position to be liquidated\\n   * @param rewardBeneficiary the address to receive the liquidator fee in either quote or base\\n   */\\n  function liquidatePosition(uint positionId, address rewardBeneficiary) external nonReentrant {\\n    OptionToken.PositionWithOwner memory position = optionToken.getPositionWithOwner(positionId);\\n\\n    (TradeParameters memory trade, Strike storage strike, OptionBoard storage board) = _composeTrade(\\n      position.strikeId,\\n      position.optionType,\\n      position.amount,\\n      TradeDirection.LIQUIDATE,\\n      1,\\n      true\\n    );\\n\\n    // updating AMM but disregarding the spotCost\\n    (, uint totalCost, , OptionMarketPricer.TradeResult[] memory tradeResults) = _doTrade(\\n      strike,\\n      board,\\n      trade,\\n      1,\\n      position.amount\\n    );\\n\\n    OptionToken.LiquidationFees memory liquidationFees = optionToken.liquidate(positionId, trade, totalCost);\\n\\n    if (liquidationFees.insolventAmount > 0) {\\n      liquidityPool.updateLiquidationInsolvency(liquidationFees.insolventAmount);\\n    }\\n\\n    shortCollateral.routeLiquidationFunds(position.owner, rewardBeneficiary, position.optionType, liquidationFees);\\n    liquidityPool.updateCBs();\\n\\n    emit Trade(\\n      position.owner,\\n      position.strikeId,\\n      positionId,\\n      TradeEventData({\\n        expiry: trade.expiry,\\n        strikePrice: trade.strikePrice,\\n        optionType: position.optionType,\\n        tradeDirection: TradeDirection.LIQUIDATE,\\n        amount: position.amount,\\n        setCollateralTo: 0,\\n        isForceClose: true,\\n        spotPrice: trade.exchangeParams.spotPrice,\\n        reservedFee: 0,\\n        totalCost: totalCost\\n      }),\\n      tradeResults,\\n      LiquidationEventData({\\n        caller: msg.sender,\\n        rewardBeneficiary: rewardBeneficiary,\\n        returnCollateral: liquidationFees.returnCollateral,\\n        lpPremiums: liquidationFees.lpPremiums,\\n        lpFee: liquidationFees.lpFee,\\n        liquidatorFee: liquidationFees.liquidatorFee,\\n        smFee: liquidationFees.smFee,\\n        insolventAmount: liquidationFees.insolventAmount\\n      }),\\n      block.timestamp\\n    );\\n  }\\n\\n  //////////////////\\n  // Fund routing //\\n  //////////////////\\n\\n  /// @dev send/receive quote or base to/from LiquidityPool on position open\\n  function _routeLPFundsOnOpen(\\n    TradeParameters memory trade,\\n    uint totalCost,\\n    uint feePortion\\n  ) internal {\\n    if (trade.amount == 0) {\\n      return;\\n    }\\n\\n    if (trade.optionType == OptionType.LONG_CALL) {\\n      liquidityPool.lockBase(trade.amount, trade.exchangeParams, trade.liquidity.freeLiquidity);\\n      _transferFromQuote(msg.sender, address(liquidityPool), totalCost - feePortion);\\n      _transferFromQuote(msg.sender, address(this), feePortion);\\n    } else if (trade.optionType == OptionType.LONG_PUT) {\\n      liquidityPool.lockQuote(trade.amount.multiplyDecimal(trade.strikePrice), trade.liquidity.freeLiquidity);\\n      _transferFromQuote(msg.sender, address(liquidityPool), totalCost - feePortion);\\n      _transferFromQuote(msg.sender, address(this), feePortion);\\n    } else if (trade.optionType == OptionType.SHORT_CALL_BASE) {\\n      liquidityPool.sendShortPremium(msg.sender, totalCost, trade.liquidity.freeLiquidity, feePortion);\\n    } else {\\n      // OptionType.SHORT_CALL_QUOTE || OptionType.SHORT_PUT_QUOTE\\n      liquidityPool.sendShortPremium(address(shortCollateral), totalCost, trade.liquidity.freeLiquidity, feePortion);\\n    }\\n  }\\n\\n  /// @dev send/receive quote or base to/from LiquidityPool on position close\\n  function _routeLPFundsOnClose(\\n    TradeParameters memory trade,\\n    uint totalCost,\\n    uint reservedFee\\n  ) internal {\\n    if (trade.amount == 0) {\\n      return;\\n    }\\n\\n    if (trade.optionType == OptionType.LONG_CALL) {\\n      liquidityPool.liquidateBaseAndSendPremium(trade.amount, msg.sender, totalCost, reservedFee);\\n    } else if (trade.optionType == OptionType.LONG_PUT) {\\n      liquidityPool.freeQuoteCollateralAndSendPremium(\\n        trade.amount.multiplyDecimal(trade.strikePrice),\\n        msg.sender,\\n        totalCost,\\n        reservedFee\\n      );\\n    } else if (trade.optionType == OptionType.SHORT_CALL_BASE) {\\n      _transferFromQuote(msg.sender, address(liquidityPool), totalCost - reservedFee);\\n      _transferFromQuote(msg.sender, address(this), reservedFee);\\n    } else {\\n      // OptionType.SHORT_CALL_QUOTE || OptionType.SHORT_PUT_QUOTE\\n      shortCollateral.sendQuoteCollateral(address(liquidityPool), totalCost - reservedFee);\\n      shortCollateral.sendQuoteCollateral(address(this), reservedFee);\\n    }\\n  }\\n\\n  /// @dev route collateral to/from msg.sender when short positions are adjusted\\n  function _routeUserCollateral(OptionType optionType, int pendingCollateral) internal {\\n    if (pendingCollateral == 0) {\\n      return;\\n    }\\n\\n    if (optionType == OptionType.SHORT_CALL_BASE) {\\n      if (pendingCollateral > 0) {\\n        if (!baseAsset.transferFrom(msg.sender, address(shortCollateral), uint(pendingCollateral))) {\\n          revert BaseTransferFailed(address(this), msg.sender, address(shortCollateral), uint(pendingCollateral));\\n        }\\n      } else {\\n        shortCollateral.sendBaseCollateral(msg.sender, uint(-pendingCollateral));\\n      }\\n    } else {\\n      // quote collateral\\n      if (pendingCollateral > 0) {\\n        _transferFromQuote(msg.sender, address(shortCollateral), uint(pendingCollateral));\\n      } else {\\n        shortCollateral.sendQuoteCollateral(msg.sender, uint(-pendingCollateral));\\n      }\\n    }\\n  }\\n\\n  /// @dev update all exposures per strike and optionType\\n  function _updateExposure(\\n    uint amount,\\n    OptionType optionType,\\n    Strike storage strike,\\n    bool isOpen\\n  ) internal {\\n    int exposure = isOpen ? SafeCast.toInt256(amount) : -SafeCast.toInt256(amount);\\n\\n    if (optionType == OptionType.LONG_CALL) {\\n      exposure += SafeCast.toInt256(strike.longCall);\\n      strike.longCall = SafeCast.toUint256(exposure);\\n    } else if (optionType == OptionType.LONG_PUT) {\\n      exposure += SafeCast.toInt256(strike.longPut);\\n      strike.longPut = SafeCast.toUint256(exposure);\\n    } else if (optionType == OptionType.SHORT_CALL_BASE) {\\n      exposure += SafeCast.toInt256(strike.shortCallBase);\\n      strike.shortCallBase = SafeCast.toUint256(exposure);\\n    } else if (optionType == OptionType.SHORT_CALL_QUOTE) {\\n      exposure += SafeCast.toInt256(strike.shortCallQuote);\\n      strike.shortCallQuote = SafeCast.toUint256(exposure);\\n    } else {\\n      // OptionType.SHORT_PUT_QUOTE\\n      exposure += SafeCast.toInt256(strike.shortPut);\\n      strike.shortPut = SafeCast.toUint256(exposure);\\n    }\\n  }\\n\\n  /////////////////////////////////\\n  // Board Expiry and settlement //\\n  /////////////////////////////////\\n\\n  /**\\n   * @notice Settles an expired board.\\n   * - Transfers all AMM profits for user shorts from ShortCollateral to LiquidityPool.\\n   * - Reserves all user profits for user longs in LiquidityPool.\\n   * - Records any profits that AMM did not receive due to user insolvencies\\n   *\\n   * @param boardId The relevant OptionBoard.\\n   */\\n  function settleExpiredBoard(uint boardId) external nonReentrant {\\n    OptionBoard memory board = optionBoards[boardId];\\n    if (board.id != boardId || board.id == 0) {\\n      revert InvalidBoardId(address(this), boardId);\\n    }\\n    if (block.timestamp < board.expiry) {\\n      revert BoardNotExpired(address(this), boardId);\\n    }\\n    _clearAndSettleBoard(board);\\n  }\\n\\n  function _clearAndSettleBoard(OptionBoard memory board) internal {\\n    bool popped = false;\\n    // Find and remove the board from the list of live boards\\n    for (uint i = 0; i < liveBoards.length; i++) {\\n      if (liveBoards[i] == board.id) {\\n        liveBoards[i] = liveBoards[liveBoards.length - 1];\\n        liveBoards.pop();\\n        popped = true;\\n        break;\\n      }\\n    }\\n    // prevent old boards being liquidated\\n    if (!popped) {\\n      revert BoardAlreadySettled(address(this), board.id);\\n    }\\n\\n    _settleExpiredBoard(board);\\n    greekCache.removeBoard(board.id);\\n  }\\n\\n  function _settleExpiredBoard(OptionBoard memory board) internal {\\n    uint spotPrice = synthetixAdapter.getSpotPriceForMarket(address(this));\\n\\n    uint totalUserLongProfitQuote;\\n    uint totalBoardLongCallCollateral;\\n    uint totalBoardLongPutCollateral;\\n    uint totalAMMShortCallProfitBase;\\n    uint totalAMMShortCallProfitQuote;\\n    uint totalAMMShortPutProfitQuote;\\n\\n    // Store the price now for when users come to settle their options\\n    boardToPriceAtExpiry[board.id] = spotPrice;\\n\\n    for (uint i = 0; i < board.strikeIds.length; i++) {\\n      Strike memory strike = strikes[board.strikeIds[i]];\\n\\n      totalBoardLongCallCollateral += strike.longCall;\\n      totalBoardLongPutCollateral += strike.longPut.multiplyDecimal(strike.strikePrice);\\n\\n      if (spotPrice > strike.strikePrice) {\\n        // For long calls\\n        totalUserLongProfitQuote += strike.longCall.multiplyDecimal(spotPrice - strike.strikePrice);\\n\\n        // Per unit of shortCalls\\n        uint baseReturnedRatio = (spotPrice - strike.strikePrice).divideDecimal(spotPrice).divideDecimal(\\n          DecimalMath.UNIT - optionMarketParams.staticBaseSettlementFee\\n        );\\n\\n        // This is impossible unless the baseAsset price has gone up ~900%+\\n        baseReturnedRatio = baseReturnedRatio > DecimalMath.UNIT ? DecimalMath.UNIT : baseReturnedRatio;\\n\\n        totalAMMShortCallProfitBase += baseReturnedRatio.multiplyDecimal(strike.shortCallBase);\\n        totalAMMShortCallProfitQuote += (spotPrice - strike.strikePrice).multiplyDecimal(strike.shortCallQuote);\\n        strikeToBaseReturnedRatio[strike.id] = baseReturnedRatio;\\n      } else if (spotPrice < strike.strikePrice) {\\n        // if amount > 0 can be skipped as it will be multiplied by 0\\n        totalUserLongProfitQuote += strike.longPut.multiplyDecimal(strike.strikePrice - spotPrice);\\n        totalAMMShortPutProfitQuote += (strike.strikePrice - spotPrice).multiplyDecimal(strike.shortPut);\\n      }\\n    }\\n\\n    (uint lpBaseInsolvency, uint lpQuoteInsolvency) = shortCollateral.boardSettlement(\\n      totalAMMShortCallProfitBase,\\n      totalAMMShortPutProfitQuote + totalAMMShortCallProfitQuote\\n    );\\n\\n    // This will batch all base we want to convert to quote and sell it in one transaction\\n    liquidityPool.boardSettlement(\\n      lpQuoteInsolvency + lpBaseInsolvency.multiplyDecimal(spotPrice),\\n      totalBoardLongPutCollateral,\\n      totalUserLongProfitQuote,\\n      totalBoardLongCallCollateral\\n    );\\n\\n    emit BoardSettled(\\n      board.id,\\n      spotPrice,\\n      totalUserLongProfitQuote,\\n      totalBoardLongCallCollateral,\\n      totalBoardLongPutCollateral,\\n      totalAMMShortCallProfitBase,\\n      totalAMMShortCallProfitQuote,\\n      totalAMMShortPutProfitQuote\\n    );\\n  }\\n\\n  /// @dev Returns the strike price, price at expiry, and profit ratio for user shorts post expiry\\n  function getSettlementParameters(uint strikeId)\\n    external\\n    view\\n    returns (\\n      uint strikePrice,\\n      uint priceAtExpiry,\\n      uint strikeToBaseReturned\\n    )\\n  {\\n    return (\\n      strikes[strikeId].strikePrice,\\n      boardToPriceAtExpiry[strikes[strikeId].boardId],\\n      strikeToBaseReturnedRatio[strikeId]\\n    );\\n  }\\n\\n  //////////\\n  // Misc //\\n  //////////\\n\\n  function _transferFromQuote(\\n    address from,\\n    address to,\\n    uint amount\\n  ) internal {\\n    if (!quoteAsset.transferFrom(from, to, amount)) {\\n      revert QuoteTransferFailed(address(this), from, to, amount);\\n    }\\n  }\\n\\n  ///////////////\\n  // Modifiers //\\n  ///////////////\\n\\n  modifier notGlobalPaused() {\\n    synthetixAdapter.requireNotGlobalPaused(address(this));\\n    _;\\n  }\\n\\n  ////////////\\n  // Events //\\n  ////////////\\n\\n  /**\\n   * @dev Emitted when a Board is created.\\n   */\\n  event BoardCreated(uint indexed boardId, uint expiry, uint baseIv, bool frozen);\\n\\n  /**\\n   * @dev Emitted when a Board frozen is updated.\\n   */\\n  event BoardFrozen(uint indexed boardId, bool frozen);\\n\\n  /**\\n   * @dev Emitted when a Board new baseIv is set.\\n   */\\n  event BoardBaseIvSet(uint indexed boardId, uint baseIv);\\n\\n  /**\\n   * @dev Emitted when a Strike new skew is set.\\n   */\\n  event StrikeSkewSet(uint indexed strikeId, uint skew);\\n\\n  /**\\n   * @dev Emitted when a Strike is added to a board\\n   */\\n  event StrikeAdded(uint indexed boardId, uint indexed strikeId, uint strikePrice, uint skew);\\n\\n  /**\\n   * @dev Emitted when parameters for the option market are adjusted\\n   */\\n  event OptionMarketParamsSet(OptionMarketParameters optionMarketParams);\\n\\n  /**\\n   * @dev Emitted whenever the security module claims their portion of fees\\n   */\\n  event SMClaimed(address securityModule, uint quoteAmount, uint baseAmount);\\n\\n  /**\\n   * @dev Emitted when a Position is opened, closed or liquidated.\\n   */\\n  event Trade(\\n    address indexed trader,\\n    uint indexed strikeId,\\n    uint indexed positionId,\\n    TradeEventData trade,\\n    OptionMarketPricer.TradeResult[] tradeResults,\\n    LiquidationEventData liquidation,\\n    uint timestamp\\n  );\\n\\n  /**\\n   * @dev Emitted when a Board is liquidated.\\n   */\\n  event BoardSettled(\\n    uint indexed boardId,\\n    uint spotPriceAtExpiry,\\n    uint totalUserLongProfitQuote,\\n    uint totalBoardLongCallCollateral,\\n    uint totalBoardLongPutCollateral,\\n    uint totalAMMShortCallProfitBase,\\n    uint totalAMMShortCallProfitQuote,\\n    uint totalAMMShortPutProfitQuote\\n  );\\n\\n  ////////////\\n  // Errors //\\n  ////////////\\n  // General purpose\\n  error ExpectedNonZeroValue(address thrower, NonZeroValues valueType);\\n\\n  // Admin\\n  error InvalidOptionMarketParams(address thrower, OptionMarketParameters optionMarketParams);\\n\\n  // Board related\\n  error InvalidBoardId(address thrower, uint boardId);\\n  error InvalidExpiryTimestamp(address thrower, uint currentTime, uint expiry, uint maxBoardExpiry);\\n  error BoardNotFrozen(address thrower, uint boardId);\\n  error BoardAlreadySettled(address thrower, uint boardId);\\n  error BoardNotExpired(address thrower, uint boardId);\\n\\n  // Strike related\\n  error InvalidStrikeId(address thrower, uint strikeId);\\n  error StrikeSkewLengthMismatch(address thrower, uint strikesLength, uint skewsLength);\\n\\n  // Trade\\n  error TotalCostOutsideOfSpecifiedBounds(address thrower, uint totalCost, uint minCost, uint maxCost);\\n  error BoardIsFrozen(address thrower, uint boardId);\\n  error BoardExpired(address thrower, uint boardId, uint boardExpiry, uint currentTime);\\n  error TradeIterationsHasRemainder(\\n    address thrower,\\n    uint iterations,\\n    uint expectedAmount,\\n    uint tradeAmount,\\n    uint totalAmount\\n  );\\n\\n  // Access\\n  error OnlySecurityModule(address thrower, address caller, address securityModule);\\n\\n  // Token transfers\\n  error BaseTransferFailed(address thrower, address from, address to, uint amount);\\n  error QuoteTransferFailed(address thrower, address from, address to, uint amount);\\n}\\n\",\"keccak256\":\"0xa5b06335e67cee4f85e11559fd20e4c5a4a2c53dac0361ffc31ef3ace5c3a29a\",\"license\":\"ISC\"},\"@lyrafinance/protocol/contracts/OptionMarketPricer.sol\":{\"content\":\"//SPDX-License-Identifier: ISC\\npragma solidity 0.8.9;\\n\\n// Libraries\\nimport \\\"./synthetix/SignedDecimalMath.sol\\\";\\nimport \\\"./synthetix/DecimalMath.sol\\\";\\nimport \\\"openzeppelin-contracts-4.4.1/utils/math/SafeCast.sol\\\";\\n\\n// Inherited\\nimport \\\"./synthetix/Owned.sol\\\";\\nimport \\\"./libraries/SimpleInitializeable.sol\\\";\\n\\n// Interfaces\\nimport \\\"./SynthetixAdapter.sol\\\";\\nimport \\\"./LiquidityPool.sol\\\";\\nimport \\\"./OptionMarket.sol\\\";\\nimport \\\"./OptionGreekCache.sol\\\";\\n\\n/**\\n * @title OptionMarketPricer\\n * @author Lyra\\n * @dev Logic for working out the price of an option. Includes the IV impact of the trade, the fee components and\\n * premium.\\n */\\ncontract OptionMarketPricer is Owned, SimpleInitializeable {\\n  using DecimalMath for uint;\\n\\n  ////////////////\\n  // Parameters //\\n  ////////////////\\n  struct PricingParameters {\\n    // Percentage of option price that is charged as a fee\\n    uint optionPriceFeeCoefficient;\\n    // Refer to: getTimeWeightedFee()\\n    uint optionPriceFee1xPoint;\\n    uint optionPriceFee2xPoint;\\n    // Percentage of spot price that is charged as a fee per option\\n    uint spotPriceFeeCoefficient;\\n    // Refer to: getTimeWeightedFee()\\n    uint spotPriceFee1xPoint;\\n    uint spotPriceFee2xPoint;\\n    // Refer to: getVegaUtilFee()\\n    uint vegaFeeCoefficient;\\n    // The amount of options traded to move baseIv for the board up or down 1 point (depending on trade direction)\\n    uint standardSize;\\n    // The relative move of skew for a given strike based on standard sizes traded\\n    uint skewAdjustmentFactor;\\n  }\\n\\n  struct TradeLimitParameters {\\n    // Delta cutoff past which no options can be traded (optionD > minD && optionD < 1 - minD) - using call delta\\n    int minDelta;\\n    // Delta cutoff at which ForceClose can be called (optionD < minD || optionD > 1 - minD) - using call delta\\n    int minForceCloseDelta;\\n    // Time when trading closes. Only ForceClose can be called after this\\n    uint tradingCutoff;\\n    // Lowest baseIv for a board that can be traded for regular option opens/closes\\n    uint minBaseIV;\\n    // Maximal baseIv for a board that can be traded for regular option opens/closes\\n    uint maxBaseIV;\\n    // Lowest skew for a strike that can be traded for regular option opens/closes\\n    uint minSkew;\\n    // Maximal skew for a strike that can be traded for regular option opens/closes\\n    uint maxSkew;\\n    // Minimal vol traded for regular option opens/closes (baseIv * skew)\\n    uint minVol;\\n    // Maximal vol traded for regular option opens/closes (baseIv * skew)\\n    uint maxVol;\\n    // Absolute lowest skew that ForceClose can go to\\n    uint absMinSkew;\\n    // Absolute highest skew that ForceClose can go to\\n    uint absMaxSkew;\\n    // Cap the skew the abs max/min skews - only relevant to liquidations\\n    bool capSkewsToAbs;\\n  }\\n\\n  struct VarianceFeeParameters {\\n    uint defaultVarianceFeeCoefficient;\\n    uint forceCloseVarianceFeeCoefficient;\\n    // coefficient that allows the skew component of the fee to be scaled up\\n    uint skewAdjustmentCoefficient;\\n    // measures the difference of the skew to a reference skew\\n    uint referenceSkew;\\n    // constant to ensure small vega terms have a fee\\n    uint minimumStaticSkewAdjustment;\\n    // coefficient that allows the vega component of the fee to be scaled up\\n    uint vegaCoefficient;\\n    // constant to ensure small vega terms have a fee\\n    uint minimumStaticVega;\\n    // coefficient that allows the ivVariance component of the fee to be scaled up\\n    uint ivVarianceCoefficient;\\n    // constant to ensure small variance terms have a fee\\n    uint minimumStaticIvVariance;\\n  }\\n\\n  ///////////////\\n  // In-memory //\\n  ///////////////\\n  struct TradeResult {\\n    uint amount;\\n    uint premium;\\n    uint optionPriceFee;\\n    uint spotPriceFee;\\n    VegaUtilFeeComponents vegaUtilFee;\\n    VarianceFeeComponents varianceFee;\\n    uint totalFee;\\n    uint totalCost;\\n    uint volTraded;\\n    uint newBaseIv;\\n    uint newSkew;\\n  }\\n\\n  struct VegaUtilFeeComponents {\\n    int preTradeAmmNetStdVega;\\n    int postTradeAmmNetStdVega;\\n    uint vegaUtil;\\n    uint volTraded;\\n    uint NAV;\\n    uint vegaUtilFee;\\n  }\\n\\n  struct VarianceFeeComponents {\\n    uint varianceFeeCoefficient;\\n    uint vega;\\n    uint vegaCoefficient;\\n    uint skew;\\n    uint skewCoefficient;\\n    uint ivVariance;\\n    uint ivVarianceCoefficient;\\n    uint varianceFee;\\n  }\\n\\n  struct VolComponents {\\n    uint vol;\\n    uint baseIv;\\n    uint skew;\\n  }\\n\\n  ///////////////\\n  // Variables //\\n  ///////////////\\n  address internal optionMarket;\\n  OptionGreekCache internal greekCache;\\n\\n  PricingParameters public pricingParams;\\n  TradeLimitParameters public tradeLimitParams;\\n  VarianceFeeParameters public varianceFeeParams;\\n\\n  ///////////\\n  // Setup //\\n  ///////////\\n\\n  constructor() Owned() {}\\n\\n  /**\\n   * @dev Initialize the contract.\\n   *\\n   * @param _optionMarket OptionMarket address\\n   * @param _greekCache OptionGreekCache address\\n   */\\n  function init(address _optionMarket, OptionGreekCache _greekCache) external onlyOwner initializer {\\n    optionMarket = _optionMarket;\\n    greekCache = _greekCache;\\n  }\\n\\n  ///////////\\n  // Admin //\\n  ///////////\\n\\n  /**\\n   * @dev\\n   *\\n   * @param params new parameters\\n   */\\n  function setPricingParams(PricingParameters memory _pricingParams) public onlyOwner {\\n    if (\\n      !(_pricingParams.optionPriceFeeCoefficient <= 200e18 &&\\n        _pricingParams.spotPriceFeeCoefficient <= 2e18 &&\\n        _pricingParams.optionPriceFee1xPoint >= 1 weeks &&\\n        _pricingParams.optionPriceFee2xPoint >= (_pricingParams.optionPriceFee1xPoint + 1 weeks) &&\\n        _pricingParams.spotPriceFee1xPoint >= 1 weeks &&\\n        _pricingParams.spotPriceFee2xPoint >= (_pricingParams.spotPriceFee1xPoint + 1 weeks) &&\\n        _pricingParams.standardSize > 0 &&\\n        _pricingParams.skewAdjustmentFactor <= 1000e18)\\n    ) {\\n      revert InvalidPricingParameters(address(this), _pricingParams);\\n    }\\n\\n    pricingParams = _pricingParams;\\n\\n    emit PricingParametersSet(pricingParams);\\n  }\\n\\n  /**\\n   * @dev\\n   *\\n   * @param params new parameters\\n   */\\n  function setTradeLimitParams(TradeLimitParameters memory _tradeLimitParams) public onlyOwner {\\n    if (\\n      !(_tradeLimitParams.minDelta <= 1e18 &&\\n        _tradeLimitParams.minForceCloseDelta <= 1e18 &&\\n        _tradeLimitParams.tradingCutoff > 0 &&\\n        _tradeLimitParams.tradingCutoff <= 10 days &&\\n        _tradeLimitParams.minBaseIV < 10e18 &&\\n        _tradeLimitParams.maxBaseIV > 0 &&\\n        _tradeLimitParams.maxBaseIV < 100e18 &&\\n        _tradeLimitParams.minSkew < 10e18 &&\\n        _tradeLimitParams.maxSkew > 0 &&\\n        _tradeLimitParams.maxSkew < 10e18 &&\\n        _tradeLimitParams.maxVol > 0 &&\\n        _tradeLimitParams.absMaxSkew >= _tradeLimitParams.maxSkew &&\\n        _tradeLimitParams.absMinSkew <= _tradeLimitParams.minSkew)\\n    ) {\\n      revert InvalidTradeLimitParameters(address(this), _tradeLimitParams);\\n    }\\n\\n    tradeLimitParams = _tradeLimitParams;\\n\\n    emit TradeLimitParametersSet(tradeLimitParams);\\n  }\\n\\n  /**\\n   * @dev\\n   *\\n   * @param params new parameters\\n   */\\n  function setVarianceFeeParams(VarianceFeeParameters memory _varianceFeeParams) public onlyOwner {\\n    varianceFeeParams = _varianceFeeParams;\\n\\n    emit VarianceFeeParametersSet(varianceFeeParams);\\n  }\\n\\n  ////////////////////////\\n  // Only Option Market //\\n  ////////////////////////\\n\\n  /**\\n   * @dev The entry point for the OptionMarket into the pricing logic when a trade is performed.\\n   *\\n   * @param strike The strike being traded.\\n   * @param trade The trade struct, containing fields related to the ongoing trade.\\n   * @param boardBaseIv The base IV of the OptionBoard.\\n   */\\n  function updateCacheAndGetTradeResult(\\n    OptionMarket.Strike memory strike,\\n    OptionMarket.TradeParameters memory trade,\\n    uint boardBaseIv,\\n    uint boardExpiry\\n  ) external onlyOptionMarket returns (TradeResult memory tradeResult) {\\n    (uint newBaseIv, uint newSkew) = ivImpactForTrade(trade, boardBaseIv, strike.skew);\\n\\n    bool isPostCutoff = block.timestamp + tradeLimitParams.tradingCutoff > boardExpiry;\\n\\n    if (trade.isForceClose) {\\n      // don't actually update baseIV for forceCloses\\n      newBaseIv = boardBaseIv;\\n\\n      // If it is a force close and skew ends up outside the \\\"abs min/max\\\" thresholds\\n      if (\\n        trade.tradeDirection != OptionMarket.TradeDirection.LIQUIDATE &&\\n        (newSkew <= tradeLimitParams.absMinSkew || newSkew >= tradeLimitParams.absMaxSkew)\\n      ) {\\n        revert ForceCloseSkewOutOfRange(\\n          address(this),\\n          trade.isBuy,\\n          newSkew,\\n          tradeLimitParams.absMinSkew,\\n          tradeLimitParams.absMaxSkew\\n        );\\n      }\\n    } else {\\n      if (isPostCutoff) {\\n        revert TradingCutoffReached(address(this), tradeLimitParams.tradingCutoff, boardExpiry, block.timestamp);\\n      }\\n\\n      uint newVol = newBaseIv.multiplyDecimal(newSkew);\\n\\n      if (trade.isBuy) {\\n        if (\\n          newVol > tradeLimitParams.maxVol ||\\n          newBaseIv > tradeLimitParams.maxBaseIV ||\\n          newSkew > tradeLimitParams.maxSkew\\n        ) {\\n          revert VolSkewOrBaseIvOutsideOfTradingBounds(\\n            address(this),\\n            trade.isBuy,\\n            VolComponents(boardBaseIv.multiplyDecimal(strike.skew), boardBaseIv, strike.skew),\\n            VolComponents(newVol, newBaseIv, newSkew),\\n            VolComponents(tradeLimitParams.maxVol, tradeLimitParams.maxBaseIV, tradeLimitParams.maxSkew)\\n          );\\n        }\\n      } else {\\n        if (\\n          newVol < tradeLimitParams.minVol ||\\n          newBaseIv < tradeLimitParams.minBaseIV ||\\n          newSkew < tradeLimitParams.minSkew\\n        ) {\\n          revert VolSkewOrBaseIvOutsideOfTradingBounds(\\n            address(this),\\n            trade.isBuy,\\n            VolComponents(boardBaseIv.multiplyDecimal(strike.skew), boardBaseIv, strike.skew),\\n            VolComponents(newVol, newBaseIv, newSkew),\\n            VolComponents(tradeLimitParams.minVol, tradeLimitParams.minBaseIV, tradeLimitParams.minSkew)\\n          );\\n        }\\n      }\\n    }\\n\\n    if (tradeLimitParams.capSkewsToAbs) {\\n      // Only relevant to liquidations. Technically only needs to be capped on the max side (as closing shorts)\\n      newSkew = _max(_min(newSkew, tradeLimitParams.absMaxSkew), tradeLimitParams.absMinSkew);\\n    }\\n\\n    OptionGreekCache.TradePricing memory pricing = greekCache.updateStrikeExposureAndGetPrice(\\n      strike,\\n      trade,\\n      newBaseIv,\\n      newSkew,\\n      isPostCutoff\\n    );\\n\\n    if (trade.isForceClose) {\\n      // ignore delta cutoffs post trading cutoff, and for liquidations\\n      if (trade.tradeDirection != OptionMarket.TradeDirection.LIQUIDATE && !isPostCutoff) {\\n        // delta must fall BELOW the min or ABOVE the max to allow for force closes\\n        if (\\n          pricing.callDelta > tradeLimitParams.minForceCloseDelta &&\\n          pricing.callDelta < (int(DecimalMath.UNIT) - tradeLimitParams.minForceCloseDelta)\\n        ) {\\n          revert ForceCloseDeltaOutOfRange(\\n            address(this),\\n            pricing.callDelta,\\n            tradeLimitParams.minForceCloseDelta,\\n            (int(DecimalMath.UNIT) - tradeLimitParams.minForceCloseDelta)\\n          );\\n        }\\n      }\\n    } else {\\n      if (\\n        pricing.callDelta < tradeLimitParams.minDelta ||\\n        pricing.callDelta > int(DecimalMath.UNIT) - tradeLimitParams.minDelta\\n      ) {\\n        revert TradeDeltaOutOfRange(\\n          address(this),\\n          pricing.callDelta,\\n          tradeLimitParams.minDelta,\\n          int(DecimalMath.UNIT) - tradeLimitParams.minDelta\\n        );\\n      }\\n    }\\n\\n    return getTradeResult(trade, pricing, newBaseIv, newSkew);\\n  }\\n\\n  /**\\n   * @dev Calculates the impact a trade has on the base IV of the OptionBoard and the skew of the Strike.\\n   *\\n   * @param trade The trade struct, containing fields related to the ongoing trade.\\n   * @param boardBaseIv The base IV of the OptionBoard.\\n   * @param strikeSkew The skew of the option being traded.\\n   */\\n  function ivImpactForTrade(\\n    OptionMarket.TradeParameters memory trade,\\n    uint boardBaseIv,\\n    uint strikeSkew\\n  ) public view returns (uint newBaseIv, uint newSkew) {\\n    uint orderSize = trade.amount.divideDecimal(pricingParams.standardSize);\\n    uint orderMoveBaseIv = orderSize / 100;\\n    uint orderMoveSkew = orderMoveBaseIv.multiplyDecimal(pricingParams.skewAdjustmentFactor);\\n    if (trade.isBuy) {\\n      return (boardBaseIv + orderMoveBaseIv, strikeSkew + orderMoveSkew);\\n    } else {\\n      return (boardBaseIv - orderMoveBaseIv, strikeSkew - orderMoveSkew);\\n    }\\n  }\\n\\n  /////////////////////\\n  // Fee Computation //\\n  /////////////////////\\n\\n  /**\\n   * @dev Calculates the final premium for a trade.\\n   *\\n   * @param trade The trade struct, containing fields related to the ongoing trade.\\n   * @param pricing Fields related to option pricing and required for fees.\\n   */\\n  function getTradeResult(\\n    OptionMarket.TradeParameters memory trade,\\n    OptionGreekCache.TradePricing memory pricing,\\n    uint newBaseIv,\\n    uint newSkew\\n  ) public view returns (TradeResult memory tradeResult) {\\n    uint premium = pricing.optionPrice.multiplyDecimal(trade.amount);\\n\\n    // time weight fees\\n    uint timeWeightedOptionPriceFee = getTimeWeightedFee(\\n      trade.expiry,\\n      pricingParams.optionPriceFee1xPoint,\\n      pricingParams.optionPriceFee2xPoint,\\n      pricingParams.optionPriceFeeCoefficient\\n    );\\n\\n    uint timeWeightedSpotPriceFee = getTimeWeightedFee(\\n      trade.expiry,\\n      pricingParams.spotPriceFee1xPoint,\\n      pricingParams.spotPriceFee2xPoint,\\n      pricingParams.spotPriceFeeCoefficient\\n    );\\n\\n    // scale by premium/amount/spot\\n    uint optionPriceFee = timeWeightedOptionPriceFee.multiplyDecimal(premium);\\n    uint spotPriceFee = timeWeightedSpotPriceFee.multiplyDecimal(trade.exchangeParams.spotPrice).multiplyDecimal(\\n      trade.amount\\n    );\\n    VegaUtilFeeComponents memory vegaUtilFeeComponents = getVegaUtilFee(trade, pricing);\\n    VarianceFeeComponents memory varianceFeeComponents = getVarianceFee(trade, pricing, newSkew);\\n\\n    uint totalFee = optionPriceFee +\\n      spotPriceFee +\\n      vegaUtilFeeComponents.vegaUtilFee +\\n      varianceFeeComponents.varianceFee;\\n\\n    uint totalCost;\\n    if (trade.isBuy) {\\n      // If we are selling, increase the amount the user pays\\n      totalCost = premium + totalFee;\\n    } else {\\n      // If we are buying, reduce the amount we pay\\n      if (totalFee > premium) {\\n        totalFee = premium;\\n        totalCost = 0;\\n      } else {\\n        totalCost = premium - totalFee;\\n      }\\n    }\\n\\n    return\\n      TradeResult({\\n        amount: trade.amount,\\n        premium: premium,\\n        optionPriceFee: optionPriceFee,\\n        spotPriceFee: spotPriceFee,\\n        vegaUtilFee: vegaUtilFeeComponents,\\n        varianceFee: varianceFeeComponents,\\n        totalCost: totalCost,\\n        totalFee: totalFee,\\n        newBaseIv: newBaseIv,\\n        newSkew: newSkew,\\n        volTraded: pricing.volTraded\\n      });\\n  }\\n\\n  /**\\n   * @dev Calculates a time weighted fee depending on the time to expiry. The fee graph has value = 1 and slope = 0\\n   * until pointA is reached; at which it increasing linearly to 2x at pointB. This only assumes pointA < pointB, so\\n   * fees can only get larger for longer dated options.\\n   *    |\\n   *    |       /\\n   *    |      /\\n   * 2x |     /|\\n   *    |    / |\\n   * 1x |___/  |\\n   *    |__________\\n   *        A  B\\n   * @param expiry the timestamp at which the listing/board expires\\n   * @param pointA the point (time to expiry) at which the fees start to increase beyond 1x\\n   * @param pointB the point (time to expiry) at which the fee are 2x\\n   * @param coefficient the fee coefficent as a result of the time to expiry.\\n   */\\n  function getTimeWeightedFee(\\n    uint expiry,\\n    uint pointA,\\n    uint pointB,\\n    uint coefficient\\n  ) public view returns (uint timeWeightedFee) {\\n    uint timeToExpiry = expiry - block.timestamp;\\n    if (timeToExpiry <= pointA) {\\n      return coefficient;\\n    }\\n    return\\n      coefficient.multiplyDecimal(DecimalMath.UNIT + ((timeToExpiry - pointA) * DecimalMath.UNIT) / (pointB - pointA));\\n  }\\n\\n  /**\\n   * @dev Calculates vega utilisation to be used as part of the trade fee. If the trade reduces net standard vega, this\\n   * component is omitted from the fee.\\n   *\\n   * @param trade The trade struct, containing fields related to the ongoing trade.\\n   * @param pricing Fields related to option pricing and required for fees.\\n   */\\n  function getVegaUtilFee(OptionMarket.TradeParameters memory trade, OptionGreekCache.TradePricing memory pricing)\\n    public\\n    view\\n    returns (VegaUtilFeeComponents memory vegaUtilFeeComponents)\\n  {\\n    if (_abs(pricing.preTradeAmmNetStdVega) >= _abs(pricing.postTradeAmmNetStdVega)) {\\n      return\\n        VegaUtilFeeComponents({\\n          preTradeAmmNetStdVega: pricing.preTradeAmmNetStdVega,\\n          postTradeAmmNetStdVega: pricing.postTradeAmmNetStdVega,\\n          vegaUtil: 0,\\n          volTraded: pricing.volTraded,\\n          NAV: trade.liquidity.NAV,\\n          vegaUtilFee: 0\\n        });\\n    }\\n    // As we use nav here and the value doesn't change between iterations, opening 5x 1 options will be different to\\n    // opening 5 options with 5 iterations as nav won't update each iteration\\n\\n    // This would be the whitepaper vegaUtil divided by 100 due to vol being stored as a percentage\\n    uint vegaUtil = pricing.volTraded.multiplyDecimal(_abs(pricing.postTradeAmmNetStdVega)).divideDecimal(\\n      trade.liquidity.NAV\\n    );\\n\\n    uint vegaUtilFee = pricingParams.vegaFeeCoefficient.multiplyDecimal(vegaUtil).multiplyDecimal(trade.amount);\\n    return\\n      VegaUtilFeeComponents({\\n        preTradeAmmNetStdVega: pricing.preTradeAmmNetStdVega,\\n        postTradeAmmNetStdVega: pricing.postTradeAmmNetStdVega,\\n        vegaUtil: vegaUtil,\\n        volTraded: pricing.volTraded,\\n        NAV: trade.liquidity.NAV,\\n        vegaUtilFee: vegaUtilFee\\n      });\\n  }\\n\\n  /**\\n   * @dev Calculates the variance fee to be used as part of the trade fee.\\n   *\\n   * @param trade The trade struct, containing fields related to the ongoing trade.\\n   * @param pricing Fields related to option pricing and required for fees.\\n   */\\n  function getVarianceFee(\\n    OptionMarket.TradeParameters memory trade,\\n    OptionGreekCache.TradePricing memory pricing,\\n    uint skew\\n  ) public view returns (VarianceFeeComponents memory varianceFeeComponents) {\\n    uint coefficient = trade.isForceClose\\n      ? varianceFeeParams.forceCloseVarianceFeeCoefficient\\n      : varianceFeeParams.defaultVarianceFeeCoefficient;\\n    if (coefficient == 0) {\\n      return\\n        VarianceFeeComponents({\\n          varianceFeeCoefficient: 0,\\n          vega: pricing.vega,\\n          vegaCoefficient: 0,\\n          skew: skew,\\n          skewCoefficient: 0,\\n          ivVariance: pricing.ivVariance,\\n          ivVarianceCoefficient: 0,\\n          varianceFee: 0\\n        });\\n    }\\n\\n    uint vegaCoefficient = varianceFeeParams.minimumStaticVega +\\n      pricing.vega.multiplyDecimal(varianceFeeParams.vegaCoefficient);\\n    uint skewCoefficient = varianceFeeParams.minimumStaticSkewAdjustment +\\n      _abs(SafeCast.toInt256(skew) - SafeCast.toInt256(varianceFeeParams.referenceSkew)).multiplyDecimal(\\n        varianceFeeParams.skewAdjustmentCoefficient\\n      );\\n    uint ivVarianceCoefficient = varianceFeeParams.minimumStaticIvVariance +\\n      pricing.ivVariance.multiplyDecimal(varianceFeeParams.ivVarianceCoefficient);\\n\\n    uint varianceFee = coefficient\\n      .multiplyDecimal(vegaCoefficient)\\n      .multiplyDecimal(skewCoefficient)\\n      .multiplyDecimal(ivVarianceCoefficient)\\n      .multiplyDecimal(trade.amount);\\n    return\\n      VarianceFeeComponents({\\n        varianceFeeCoefficient: coefficient,\\n        vega: pricing.vega,\\n        vegaCoefficient: vegaCoefficient,\\n        skew: skew,\\n        skewCoefficient: skewCoefficient,\\n        ivVariance: pricing.ivVariance,\\n        ivVarianceCoefficient: ivVarianceCoefficient,\\n        varianceFee: varianceFee\\n      });\\n  }\\n\\n  /////////////////////////////\\n  // External View functions //\\n  /////////////////////////////\\n\\n  /// @notice returns current pricing paramters\\n  function getPricingParams() external view returns (PricingParameters memory pricingParameters) {\\n    return pricingParams;\\n  }\\n\\n  /// @notice returns current trade limit parameters\\n  function getTradeLimitParams() external view returns (TradeLimitParameters memory tradeLimitParameters) {\\n    return tradeLimitParams;\\n  }\\n\\n  /// @notice returns current variance fee parameters\\n  function getVarianceFeeParams() external view returns (VarianceFeeParameters memory varianceFeeParameters) {\\n    return varianceFeeParams;\\n  }\\n\\n  ///////////\\n  // Utils //\\n  ///////////\\n\\n  function _min(uint x, uint y) internal pure returns (uint) {\\n    return (x < y) ? x : y;\\n  }\\n\\n  function _max(uint x, uint y) internal pure returns (uint) {\\n    return (x > y) ? x : y;\\n  }\\n\\n  /**\\n   * @dev Compute the absolute value of `val`.\\n   *\\n   * @param val The number to absolute value.\\n   */\\n  function _abs(int val) internal pure returns (uint) {\\n    return uint(val < 0 ? -val : val);\\n  }\\n\\n  ///////////////\\n  // Modifiers //\\n  ///////////////\\n\\n  modifier onlyOptionMarket() {\\n    if (msg.sender != optionMarket) {\\n      revert OnlyOptionMarket(address(this), msg.sender, optionMarket);\\n    }\\n    _;\\n  }\\n\\n  ////////////\\n  // Events //\\n  ////////////\\n\\n  event PricingParametersSet(PricingParameters pricingParams);\\n  event TradeLimitParametersSet(TradeLimitParameters tradeLimitParams);\\n  event VarianceFeeParametersSet(VarianceFeeParameters varianceFeeParams);\\n\\n  ////////////\\n  // Errors //\\n  ////////////\\n  // Admin\\n  error InvalidTradeLimitParameters(address thrower, TradeLimitParameters tradeLimitParams);\\n  error InvalidPricingParameters(address thrower, PricingParameters pricingParams);\\n\\n  // Trade limitations\\n  error TradingCutoffReached(address thrower, uint tradingCutoff, uint boardExpiry, uint currentTime);\\n  error ForceCloseSkewOutOfRange(address thrower, bool isBuy, uint newSkew, uint minSkew, uint maxSkew);\\n  error VolSkewOrBaseIvOutsideOfTradingBounds(\\n    address thrower,\\n    bool isBuy,\\n    VolComponents currentVol,\\n    VolComponents newVol,\\n    VolComponents tradeBounds\\n  );\\n  error TradeDeltaOutOfRange(address thrower, int strikeCallDelta, int minDelta, int maxDelta);\\n  error ForceCloseDeltaOutOfRange(address thrower, int strikeCallDelta, int minDelta, int maxDelta);\\n\\n  // Access\\n  error OnlyOptionMarket(address thrower, address caller, address optionMarket);\\n}\\n\",\"keccak256\":\"0xf1840b80312a739d11725febdd61efb561e6429ee9e9f6fa94ba8f5053e69b10\",\"license\":\"ISC\"},\"@lyrafinance/protocol/contracts/OptionToken.sol\":{\"content\":\"//SPDX-License-Identifier: ISC\\npragma solidity 0.8.9;\\n\\n// Libraries\\nimport \\\"./synthetix/DecimalMath.sol\\\";\\n\\n// Inherited\\nimport \\\"openzeppelin-contracts-4.4.1/token/ERC721/extensions/ERC721Enumerable.sol\\\";\\nimport \\\"./synthetix/Owned.sol\\\";\\nimport \\\"./libraries/SimpleInitializeable.sol\\\";\\nimport \\\"openzeppelin-contracts-4.4.1/security/ReentrancyGuard.sol\\\";\\nimport \\\"openzeppelin-contracts-4.4.1/utils/math/SafeCast.sol\\\";\\n\\n// Interfaces\\nimport \\\"./OptionMarket.sol\\\";\\nimport \\\"./SynthetixAdapter.sol\\\";\\nimport \\\"./OptionGreekCache.sol\\\";\\n\\n/**\\n * @title OptionToken\\n * @author Lyra\\n * @dev Provides a tokenized representation of each trade position including amount of options and collateral.\\n */\\ncontract OptionToken is Owned, SimpleInitializeable, ReentrancyGuard, ERC721Enumerable {\\n  using DecimalMath for uint;\\n\\n  enum PositionState {\\n    EMPTY,\\n    ACTIVE,\\n    CLOSED,\\n    LIQUIDATED,\\n    SETTLED,\\n    MERGED\\n  }\\n\\n  enum PositionUpdatedType {\\n    OPENED,\\n    ADJUSTED,\\n    CLOSED,\\n    SPLIT_FROM,\\n    SPLIT_INTO,\\n    MERGED,\\n    MERGED_INTO,\\n    SETTLED,\\n    LIQUIDATED,\\n    TRANSFER\\n  }\\n\\n  struct OptionPosition {\\n    uint positionId;\\n    uint strikeId;\\n    OptionMarket.OptionType optionType;\\n    uint amount;\\n    uint collateral;\\n    PositionState state;\\n  }\\n\\n  ///////////////\\n  // Parameters //\\n  ///////////////\\n\\n  struct PartialCollateralParameters {\\n    // Percent of collateral used for penalty (amm + sm + liquidator fees)\\n    uint penaltyRatio;\\n    // Percent of penalty used for amm fees\\n    uint liquidatorFeeRatio;\\n    // Percent of penalty used for SM fees\\n    uint smFeeRatio;\\n    // Minimal value of quote that is used to charge a fee\\n    uint minLiquidationFee;\\n  }\\n\\n  ///////////////\\n  // In-memory //\\n  ///////////////\\n  struct PositionWithOwner {\\n    uint positionId;\\n    uint strikeId;\\n    OptionMarket.OptionType optionType;\\n    uint amount;\\n    uint collateral;\\n    PositionState state;\\n    address owner;\\n  }\\n\\n  struct LiquidationFees {\\n    uint returnCollateral; // quote || base\\n    uint lpPremiums; // quote || base\\n    uint lpFee; // quote || base\\n    uint liquidatorFee; // quote || base\\n    uint smFee; // quote || base\\n    uint insolventAmount; // quote\\n  }\\n\\n  ///////////////\\n  // Variables //\\n  ///////////////\\n  OptionMarket internal optionMarket;\\n  OptionGreekCache internal greekCache;\\n  address internal shortCollateral;\\n  SynthetixAdapter internal synthetixAdapter;\\n\\n  mapping(uint => OptionPosition) public positions;\\n  uint public nextId = 1;\\n\\n  PartialCollateralParameters public partialCollatParams;\\n\\n  string public baseURI;\\n\\n  ///////////\\n  // Setup //\\n  ///////////\\n\\n  constructor(string memory name_, string memory symbol_) ERC721(name_, symbol_) Owned() {}\\n\\n  /**\\n   * @notice Initialise the contract.\\n   *\\n   * @param _optionMarket The OptionMarket contract address.\\n   */\\n  function init(\\n    OptionMarket _optionMarket,\\n    OptionGreekCache _greekCache,\\n    address _shortCollateral,\\n    SynthetixAdapter _synthetixAdapter\\n  ) external onlyOwner initializer {\\n    optionMarket = _optionMarket;\\n    greekCache = _greekCache;\\n    shortCollateral = _shortCollateral;\\n    synthetixAdapter = _synthetixAdapter;\\n  }\\n\\n  ///////////\\n  // Admin //\\n  ///////////\\n\\n  /// @notice set PartialCollateralParameters\\n  function setPartialCollateralParams(PartialCollateralParameters memory _partialCollatParams) external onlyOwner {\\n    if (\\n      _partialCollatParams.penaltyRatio > DecimalMath.UNIT ||\\n      (_partialCollatParams.liquidatorFeeRatio + _partialCollatParams.smFeeRatio) > DecimalMath.UNIT\\n    ) {\\n      revert InvalidPartialCollateralParameters(address(this), _partialCollatParams);\\n    }\\n\\n    partialCollatParams = _partialCollatParams;\\n    emit PartialCollateralParamsSet(partialCollatParams);\\n  }\\n\\n  /**\\n   * @param newURI The new uri definition for the contract.\\n   */\\n  function setURI(string memory newURI) external onlyOwner {\\n    baseURI = newURI;\\n    emit URISet(baseURI);\\n  }\\n\\n  function _baseURI() internal view override returns (string memory) {\\n    return baseURI;\\n  }\\n\\n  /////////////////////////\\n  // Adjusting positions //\\n  /////////////////////////\\n\\n  /**\\n   * @notice Adjusts position amount and collateral when position is:\\n   * - opened\\n   * - closed\\n   * - forceClosed\\n   * - liquidated\\n   *\\n   * @param trade TradeParameters as defined in OptionMarket.\\n   * @param strikeId id of strike for adjusted position.\\n   * @param trader owner of position.\\n   * @param positionId id of position.\\n   * @param optionCost totalCost of closing or opening position.\\n   * @param setCollateralTo final collateral to leave in position.\\n   * @param isOpen whether order is to increase or decrease position.amount.\\n   *\\n   * @return uint positionId of position being adjusted (relevant for new positions)\\n   * @return pendingCollateral amount of additional quote to receive from msg.sender\\n   */\\n  function adjustPosition(\\n    OptionMarket.TradeParameters memory trade,\\n    uint strikeId,\\n    address trader,\\n    uint positionId,\\n    uint optionCost,\\n    uint setCollateralTo,\\n    bool isOpen\\n  ) external onlyOptionMarket returns (uint, int pendingCollateral) {\\n    OptionPosition storage position;\\n    bool newPosition = false;\\n    if (positionId == 0) {\\n      if (!isOpen) {\\n        revert CannotClosePositionZero(address(this));\\n      }\\n      if (trade.amount == 0) {\\n        revert CannotOpenZeroAmount(address(this));\\n      }\\n\\n      positionId = nextId++;\\n      _mint(trader, positionId);\\n      position = positions[positionId];\\n\\n      position.positionId = positionId;\\n      position.strikeId = strikeId;\\n      position.optionType = trade.optionType;\\n      position.state = PositionState.ACTIVE;\\n\\n      newPosition = true;\\n    } else {\\n      position = positions[positionId];\\n    }\\n\\n    if (\\n      position.positionId == 0 ||\\n      position.state != PositionState.ACTIVE ||\\n      position.strikeId != strikeId ||\\n      position.optionType != trade.optionType\\n    ) {\\n      revert CannotAdjustInvalidPosition(\\n        address(this),\\n        positionId,\\n        position.positionId == 0,\\n        position.state != PositionState.ACTIVE,\\n        position.strikeId != strikeId,\\n        position.optionType != trade.optionType\\n      );\\n    }\\n    if (trader != ownerOf(position.positionId)) {\\n      revert OnlyOwnerCanAdjustPosition(address(this), positionId, trader, ownerOf(position.positionId));\\n    }\\n\\n    if (isOpen) {\\n      position.amount += trade.amount;\\n    } else {\\n      position.amount -= trade.amount;\\n    }\\n\\n    if (position.amount == 0) {\\n      if (setCollateralTo != 0) {\\n        revert FullyClosingWithNonZeroSetCollateral(address(this), position.positionId, setCollateralTo);\\n      }\\n      // return all collateral to the user if they fully close the position\\n      pendingCollateral = -(SafeCast.toInt256(position.collateral));\\n      if (\\n        trade.optionType == OptionMarket.OptionType.SHORT_CALL_QUOTE ||\\n        trade.optionType == OptionMarket.OptionType.SHORT_PUT_QUOTE\\n      ) {\\n        // Add the optionCost to the inverted collateral (subtract from collateral)\\n        pendingCollateral += SafeCast.toInt256(optionCost);\\n      }\\n      position.collateral = 0;\\n      position.state = PositionState.CLOSED;\\n      _burn(position.positionId); // burn tokens that have been closed.\\n      emit PositionUpdated(position.positionId, trader, PositionUpdatedType.CLOSED, position, block.timestamp);\\n      return (position.positionId, pendingCollateral);\\n    }\\n\\n    if (_isShort(trade.optionType)) {\\n      uint preCollateral = position.collateral;\\n      if (trade.optionType != OptionMarket.OptionType.SHORT_CALL_BASE) {\\n        if (isOpen) {\\n          preCollateral += optionCost;\\n        } else {\\n          // This will only throw if the position is insolvent\\n          preCollateral -= optionCost;\\n        }\\n      }\\n      pendingCollateral = SafeCast.toInt256(setCollateralTo) - SafeCast.toInt256(preCollateral);\\n      position.collateral = setCollateralTo;\\n      if (canLiquidate(position, trade.expiry, trade.strikePrice, trade.exchangeParams.spotPrice)) {\\n        revert AdjustmentResultsInMinimumCollateralNotBeingMet(address(this), position, trade.exchangeParams.spotPrice);\\n      }\\n    }\\n    // if long, pendingCollateral is 0 - ignore\\n\\n    emit PositionUpdated(\\n      position.positionId,\\n      trader,\\n      newPosition ? PositionUpdatedType.OPENED : PositionUpdatedType.ADJUSTED,\\n      position,\\n      block.timestamp\\n    );\\n\\n    return (position.positionId, pendingCollateral);\\n  }\\n\\n  /**\\n   * @notice Only allows increase to position.collateral\\n   *\\n   * @param positionId id of position.\\n   * @param amountCollateral amount of collateral to add to position.\\n   *\\n   * @return optionType OptionType of adjusted position\\n   */\\n  function addCollateral(uint positionId, uint amountCollateral)\\n    external\\n    onlyOptionMarket\\n    returns (OptionMarket.OptionType optionType)\\n  {\\n    OptionPosition storage position = positions[positionId];\\n\\n    if (position.positionId == 0 || position.state != PositionState.ACTIVE || !_isShort(position.optionType)) {\\n      revert AddingCollateralToInvalidPosition(\\n        address(this),\\n        positionId,\\n        position.positionId == 0,\\n        position.state != PositionState.ACTIVE,\\n        !_isShort(position.optionType)\\n      );\\n    }\\n\\n    _requireStrikeNotExpired(position.strikeId);\\n\\n    position.collateral += amountCollateral;\\n\\n    emit PositionUpdated(\\n      position.positionId,\\n      ownerOf(positionId),\\n      PositionUpdatedType.ADJUSTED,\\n      position,\\n      block.timestamp\\n    );\\n\\n    return position.optionType;\\n  }\\n\\n  /**\\n   * @notice burns and updates position.state when board is settled\\n   * @dev invalid positions get caught when trying to query owner for event (or in burn)\\n   *\\n   * @param positionIds array of position ids to settle\\n   */\\n  function settlePositions(uint[] memory positionIds) external onlyShortCollateral {\\n    for (uint i = 0; i < positionIds.length; i++) {\\n      positions[positionIds[i]].state = PositionState.SETTLED;\\n\\n      emit PositionUpdated(\\n        positionIds[i],\\n        ownerOf(positionIds[i]),\\n        PositionUpdatedType.SETTLED,\\n        positions[positionIds[i]],\\n        block.timestamp\\n      );\\n\\n      _burn(positionIds[i]);\\n    }\\n  }\\n\\n  /////////////////\\n  // Liquidation //\\n  /////////////////\\n\\n  /**\\n   * @notice checks of liquidation is valid, burns liquidation position and determines fee distribution\\n   * @dev called when 'OptionMarket.liquidatePosition()' is called\\n   *\\n   * @param positionId position id to liquidate\\n   * @param trade TradeParameters as defined in OptionMarket\\n   * @param totalCost totalCost paid to LiquidityPool from position.collateral (excludes liquidation fees)\\n   */\\n  function liquidate(\\n    uint positionId,\\n    OptionMarket.TradeParameters memory trade,\\n    uint totalCost\\n  ) external onlyOptionMarket returns (LiquidationFees memory liquidationFees) {\\n    OptionPosition storage position = positions[positionId];\\n\\n    if (!canLiquidate(position, trade.expiry, trade.strikePrice, trade.exchangeParams.spotPrice)) {\\n      revert PositionNotLiquidatable(address(this), position, trade.exchangeParams.spotPrice);\\n    }\\n\\n    uint convertedMinLiquidationFee = partialCollatParams.minLiquidationFee;\\n    uint insolvencyMultiplier = DecimalMath.UNIT;\\n    if (trade.optionType == OptionMarket.OptionType.SHORT_CALL_BASE) {\\n      totalCost = synthetixAdapter.estimateExchangeToExactQuote(trade.exchangeParams, totalCost);\\n      convertedMinLiquidationFee = partialCollatParams.minLiquidationFee.divideDecimal(trade.exchangeParams.spotPrice);\\n      insolvencyMultiplier = trade.exchangeParams.spotPrice;\\n    }\\n\\n    position.state = PositionState.LIQUIDATED;\\n\\n    emit PositionUpdated(\\n      position.positionId,\\n      ownerOf(position.positionId),\\n      PositionUpdatedType.LIQUIDATED,\\n      position,\\n      block.timestamp\\n    );\\n\\n    _burn(positionId);\\n\\n    return getLiquidationFees(totalCost, position.collateral, convertedMinLiquidationFee, insolvencyMultiplier);\\n  }\\n\\n  /**\\n   * @notice checks whether position is valid and position.collateral < minimum required collateral\\n   * @dev useful for estimating liquidatability in different spot/strike/expiry scenarios\\n   *\\n   * @param position any OptionPosition struct (does not need to be an existing position)\\n   * @param expiry expiry of option (does not need to match position.strikeId expiry)\\n   * @param strikePrice strike price of position\\n   * @param spotPrice spot price of base\\n   */\\n  function canLiquidate(\\n    OptionPosition memory position,\\n    uint expiry,\\n    uint strikePrice,\\n    uint spotPrice\\n  ) public view returns (bool) {\\n    if (!_isShort(position.optionType)) {\\n      return false;\\n    }\\n    if (position.state != PositionState.ACTIVE) {\\n      return false;\\n    }\\n\\n    // Option expiry is checked in optionMarket._doTrade()\\n    // Will revert if called post expiry\\n    uint minCollateral = greekCache.getMinCollateral(\\n      position.optionType,\\n      strikePrice,\\n      expiry,\\n      spotPrice,\\n      position.amount\\n    );\\n\\n    return position.collateral < minCollateral;\\n  }\\n\\n  /**\\n   * @notice gets breakdown of fee distribution during liquidation event\\n   * @dev useful for estimating fees earned by all parties during liquidation\\n   *\\n   * @param gwavPremium totalCost paid to LiquidityPool from position.collateral to close position\\n   * @param userPositionCollateral total collateral in position\\n   * @param convertedMinLiquidationFee minimum static liquidation fee (defined in partialCollatParams.minLiquidationFee)\\n   * @param insolvencyMultiplier used to denominate insolveny in quote in case of base collateral insolvencies\\n   */\\n  function getLiquidationFees(\\n    uint gwavPremium, // quote || base\\n    uint userPositionCollateral, // quote || base\\n    uint convertedMinLiquidationFee, // quote || base\\n    uint insolvencyMultiplier // 1 for quote || spotPrice for base\\n  ) public view returns (LiquidationFees memory liquidationFees) {\\n    // User is fully solvent\\n    uint minOwed = gwavPremium + convertedMinLiquidationFee;\\n    uint totalCollatPenalty;\\n\\n    if (userPositionCollateral >= minOwed) {\\n      uint remainingCollateral = userPositionCollateral - gwavPremium;\\n      totalCollatPenalty = remainingCollateral.multiplyDecimal(partialCollatParams.penaltyRatio);\\n      if (totalCollatPenalty < convertedMinLiquidationFee) {\\n        totalCollatPenalty = convertedMinLiquidationFee;\\n      }\\n      liquidationFees.returnCollateral = remainingCollateral - totalCollatPenalty;\\n    } else {\\n      // user is insolvent\\n      liquidationFees.returnCollateral = 0;\\n      // edge case where short call base collat < minLiquidationFee\\n      if (userPositionCollateral >= convertedMinLiquidationFee) {\\n        totalCollatPenalty = convertedMinLiquidationFee;\\n        liquidationFees.insolventAmount = (minOwed - userPositionCollateral).multiplyDecimal(insolvencyMultiplier);\\n      } else {\\n        totalCollatPenalty = userPositionCollateral;\\n        liquidationFees.insolventAmount = (gwavPremium).multiplyDecimal(insolvencyMultiplier);\\n      }\\n    }\\n    liquidationFees.smFee = totalCollatPenalty.multiplyDecimal(partialCollatParams.smFeeRatio);\\n    liquidationFees.liquidatorFee = totalCollatPenalty.multiplyDecimal(partialCollatParams.liquidatorFeeRatio);\\n    liquidationFees.lpFee = totalCollatPenalty - (liquidationFees.smFee + liquidationFees.liquidatorFee);\\n    liquidationFees.lpPremiums = userPositionCollateral - totalCollatPenalty - liquidationFees.returnCollateral;\\n  }\\n\\n  ///////////////\\n  // Transfers //\\n  ///////////////\\n\\n  /**\\n   * @notice Allows a user to split a curent position into two. The amount of the original position will\\n   *         be subtracted from and a new position will be minted with the desired amount and collateral.\\n   * @dev Only ACTIVE positions can be owned by users, so status does not need to be checked\\n   * @dev Both resulting positions must not be liquidatable\\n   *\\n   * @param positionId the positionId of the original position to be split\\n   * @param newAmount the amount in the new position\\n   * @param newCollateral the amount of collateral for the new position\\n   * @param recipient recipient of new position\\n   */\\n  function split(\\n    uint positionId,\\n    uint newAmount,\\n    uint newCollateral,\\n    address recipient\\n  ) external nonReentrant notGlobalPaused returns (uint newPositionId) {\\n    OptionPosition storage originalPosition = positions[positionId];\\n\\n    // Will both check whether position is valid and whether approved to split\\n    // Will revert if it is an invalid positionId or inactive position (as they cannot be owned)\\n    if (!_isApprovedOrOwner(msg.sender, originalPosition.positionId)) {\\n      revert SplittingUnapprovedPosition(address(this), msg.sender, originalPosition.positionId);\\n    }\\n\\n    _requireStrikeNotExpired(originalPosition.strikeId);\\n\\n    // Do not allow splits that result in originalPosition.amount = 0 && newPosition.amount = 0;\\n    if (newAmount >= originalPosition.amount || newAmount == 0) {\\n      revert InvalidSplitAmount(address(this), originalPosition.amount, newAmount);\\n    }\\n\\n    originalPosition.amount -= newAmount;\\n\\n    // Create new position\\n    newPositionId = nextId++;\\n    _mint(recipient, newPositionId);\\n\\n    OptionPosition storage newPosition = positions[newPositionId];\\n    newPosition.positionId = newPositionId;\\n    newPosition.amount = newAmount;\\n    newPosition.strikeId = originalPosition.strikeId;\\n    newPosition.optionType = originalPosition.optionType;\\n    newPosition.state = PositionState.ACTIVE;\\n\\n    if (_isShort(originalPosition.optionType)) {\\n      // only change collateral if partial option type\\n      originalPosition.collateral -= newCollateral;\\n      newPosition.collateral = newCollateral;\\n\\n      (uint strikePrice, uint expiry) = optionMarket.getStrikeAndExpiry(originalPosition.strikeId);\\n      uint spotPrice = synthetixAdapter.getSpotPriceForMarket(address(optionMarket));\\n\\n      if (canLiquidate(originalPosition, expiry, strikePrice, spotPrice)) {\\n        revert ResultingOriginalPositionLiquidatable(address(this), originalPosition, spotPrice);\\n      }\\n      if (canLiquidate(newPosition, expiry, strikePrice, spotPrice)) {\\n        revert ResultingNewPositionLiquidatable(address(this), newPosition, spotPrice);\\n      }\\n    }\\n    emit PositionUpdated(\\n      newPosition.positionId,\\n      recipient,\\n      PositionUpdatedType.SPLIT_INTO,\\n      newPosition,\\n      block.timestamp\\n    );\\n    emit PositionUpdated(\\n      originalPosition.positionId,\\n      ownerOf(positionId),\\n      PositionUpdatedType.SPLIT_FROM,\\n      originalPosition,\\n      block.timestamp\\n    );\\n  }\\n\\n  /**\\n   * @notice User can merge many positions with matching strike and optionType into a single position\\n   * @dev Only ACTIVE positions can be owned by users, so status does not need to be checked.\\n   * @dev Merged position must not be liquidatable.\\n   *\\n   * @param positionIds the positionIds to be merged together\\n   */\\n  function merge(uint[] memory positionIds) external nonReentrant notGlobalPaused {\\n    if (positionIds.length < 2) {\\n      revert MustMergeTwoOrMorePositions(address(this));\\n    }\\n\\n    OptionPosition storage firstPosition = positions[positionIds[0]];\\n    if (!_isApprovedOrOwner(msg.sender, firstPosition.positionId)) {\\n      revert MergingUnapprovedPosition(address(this), msg.sender, firstPosition.positionId);\\n    }\\n    _requireStrikeNotExpired(firstPosition.strikeId);\\n\\n    address positionOwner = ownerOf(firstPosition.positionId);\\n\\n    OptionPosition storage nextPosition;\\n    for (uint i = 1; i < positionIds.length; i++) {\\n      nextPosition = positions[positionIds[i]];\\n\\n      if (!_isApprovedOrOwner(msg.sender, nextPosition.positionId)) {\\n        revert MergingUnapprovedPosition(address(this), msg.sender, nextPosition.positionId);\\n      }\\n\\n      if (\\n        positionOwner != ownerOf(nextPosition.positionId) ||\\n        firstPosition.strikeId != nextPosition.strikeId ||\\n        firstPosition.optionType != nextPosition.optionType ||\\n        firstPosition.positionId == nextPosition.positionId\\n      ) {\\n        revert PositionMismatchWhenMerging(\\n          address(this),\\n          firstPosition,\\n          nextPosition,\\n          positionOwner != ownerOf(nextPosition.positionId),\\n          firstPosition.strikeId != nextPosition.strikeId,\\n          firstPosition.optionType != nextPosition.optionType,\\n          firstPosition.positionId == nextPosition.positionId\\n        );\\n      }\\n\\n      firstPosition.amount += nextPosition.amount;\\n      firstPosition.collateral += nextPosition.collateral;\\n      nextPosition.collateral = 0;\\n      nextPosition.amount = 0;\\n      nextPosition.state = PositionState.MERGED;\\n\\n      // By burning the position, if the position owner is queried again, it will revert.\\n      _burn(positionIds[i]);\\n\\n      emit PositionUpdated(\\n        nextPosition.positionId,\\n        positionOwner,\\n        PositionUpdatedType.MERGED,\\n        nextPosition,\\n        block.timestamp\\n      );\\n    }\\n\\n    // make sure final position is not liquidatable\\n    if (_isShort(firstPosition.optionType)) {\\n      (uint strikePrice, uint expiry) = optionMarket.getStrikeAndExpiry(firstPosition.strikeId);\\n      uint spotPrice = synthetixAdapter.getSpotPriceForMarket(address(optionMarket));\\n      if (canLiquidate(firstPosition, expiry, strikePrice, spotPrice)) {\\n        revert ResultingNewPositionLiquidatable(address(this), firstPosition, spotPrice);\\n      }\\n    }\\n\\n    emit PositionUpdated(\\n      firstPosition.positionId,\\n      positionOwner,\\n      PositionUpdatedType.MERGED_INTO,\\n      firstPosition,\\n      block.timestamp\\n    );\\n  }\\n\\n  //////////\\n  // Util //\\n  //////////\\n\\n  /// @dev Returns bool on whether the optionType is SHORT_CALL_BASE, SHORT_CALL_QUOTE or SHORT_PUT_QUOTE\\n  function _isShort(OptionMarket.OptionType optionType) internal pure returns (bool shortPosition) {\\n    shortPosition = (uint(optionType) >= uint(OptionMarket.OptionType.SHORT_CALL_BASE)) ? true : false;\\n  }\\n\\n  /// @dev Returns the PositionState of a given positionId\\n  function getPositionState(uint positionId) external view returns (PositionState) {\\n    return positions[positionId].state;\\n  }\\n\\n  /// @dev Returns an OptionPosition struct of a given positionId\\n  function getOptionPosition(uint positionId) external view returns (OptionPosition memory) {\\n    return positions[positionId];\\n  }\\n\\n  /// @dev Returns an array of OptionPosition structs given an array of positionIds\\n  function getOptionPositions(uint[] memory positionIds) external view returns (OptionPosition[] memory) {\\n    OptionPosition[] memory result = new OptionPosition[](positionIds.length);\\n    for (uint i = 0; i < positionIds.length; i++) {\\n      result[i] = positions[positionIds[i]];\\n    }\\n    return result;\\n  }\\n\\n  /// @dev Returns a PositionWithOwner struct of a given positionId (same as OptionPosition but with owner)\\n  function getPositionWithOwner(uint positionId) external view returns (PositionWithOwner memory) {\\n    return _getPositionWithOwner(positionId);\\n  }\\n\\n  /// @dev Returns an array of PositionWithOwner structs given an array of positionIds\\n  function getPositionsWithOwner(uint[] memory positionIds) external view returns (PositionWithOwner[] memory) {\\n    PositionWithOwner[] memory result = new PositionWithOwner[](positionIds.length);\\n    for (uint i = 0; i < positionIds.length; i++) {\\n      result[i] = _getPositionWithOwner(positionIds[i]);\\n    }\\n    return result;\\n  }\\n\\n  /// @notice Returns an array of OptionPosition structs owned by a given address\\n  /// @dev Meant to be used offchain as it can run out of gas\\n  function getOwnerPositions(address target) external view returns (OptionPosition[] memory) {\\n    uint balance = balanceOf(target);\\n    OptionPosition[] memory result = new OptionPosition[](balance);\\n    for (uint i = 0; i < balance; i++) {\\n      result[i] = positions[ERC721Enumerable.tokenOfOwnerByIndex(target, i)];\\n    }\\n    return result;\\n  }\\n\\n  function _getPositionWithOwner(uint positionId) internal view returns (PositionWithOwner memory) {\\n    OptionPosition memory position = positions[positionId];\\n    return\\n      PositionWithOwner({\\n        positionId: position.positionId,\\n        strikeId: position.strikeId,\\n        optionType: position.optionType,\\n        amount: position.amount,\\n        collateral: position.collateral,\\n        state: position.state,\\n        owner: ownerOf(positionId)\\n      });\\n  }\\n\\n  /// @dev returns PartialCollateralParameters struct\\n  function getPartialCollatParams() external view returns (PartialCollateralParameters memory) {\\n    return partialCollatParams;\\n  }\\n\\n  function _requireStrikeNotExpired(uint strikeId) internal view {\\n    (, uint priceAtExpiry, ) = optionMarket.getSettlementParameters(strikeId);\\n    if (priceAtExpiry != 0) {\\n      revert StrikeIsSettled(address(this), strikeId);\\n    }\\n  }\\n\\n  ///////////////\\n  // Modifiers //\\n  ///////////////\\n\\n  modifier onlyOptionMarket() {\\n    if (msg.sender != address(optionMarket)) {\\n      revert OnlyOptionMarket(address(this), msg.sender, address(optionMarket));\\n    }\\n    _;\\n  }\\n  modifier onlyShortCollateral() {\\n    if (msg.sender != address(shortCollateral)) {\\n      revert OnlyShortCollateral(address(this), msg.sender, address(shortCollateral));\\n    }\\n    _;\\n  }\\n\\n  modifier notGlobalPaused() {\\n    synthetixAdapter.requireNotGlobalPaused(address(optionMarket));\\n    _;\\n  }\\n\\n  function _beforeTokenTransfer(\\n    address from,\\n    address to,\\n    uint tokenId\\n  ) internal override {\\n    super._beforeTokenTransfer(from, to, tokenId);\\n\\n    if (from != address(0) && to != address(0)) {\\n      emit PositionUpdated(tokenId, to, PositionUpdatedType.TRANSFER, positions[tokenId], block.timestamp);\\n    }\\n  }\\n\\n  ////////////\\n  // Events //\\n  ///////////\\n\\n  /**\\n   * @dev Emitted when the URI is modified\\n   */\\n  event URISet(string URI);\\n\\n  /**\\n   * @dev Emitted when partial collateral parameters are modified\\n   */\\n  event PartialCollateralParamsSet(PartialCollateralParameters partialCollateralParams);\\n\\n  /**\\n   * @dev Emitted when a position is minted, adjusted, burned, merged or split.\\n   */\\n  event PositionUpdated(\\n    uint indexed positionId,\\n    address indexed owner,\\n    PositionUpdatedType indexed updatedType,\\n    OptionPosition position,\\n    uint timestamp\\n  );\\n\\n  ////////////\\n  // Errors //\\n  ////////////\\n\\n  // Admin\\n  error InvalidPartialCollateralParameters(address thrower, PartialCollateralParameters partialCollatParams);\\n\\n  // Adjusting\\n  error AdjustmentResultsInMinimumCollateralNotBeingMet(address thrower, OptionPosition position, uint spotPrice);\\n  error CannotClosePositionZero(address thrower);\\n  error CannotOpenZeroAmount(address thrower);\\n  error CannotAdjustInvalidPosition(\\n    address thrower,\\n    uint positionId,\\n    bool invalidPositionId,\\n    bool positionInactive,\\n    bool strikeMismatch,\\n    bool optionTypeMismatch\\n  );\\n  error OnlyOwnerCanAdjustPosition(address thrower, uint positionId, address trader, address owner);\\n  error FullyClosingWithNonZeroSetCollateral(address thrower, uint positionId, uint setCollateralTo);\\n  error AddingCollateralToInvalidPosition(\\n    address thrower,\\n    uint positionId,\\n    bool invalidPositionId,\\n    bool positionInactive,\\n    bool isShort\\n  );\\n\\n  // Liquidation\\n  error PositionNotLiquidatable(address thrower, OptionPosition position, uint spotPrice);\\n\\n  // Splitting\\n  error SplittingUnapprovedPosition(address thrower, address caller, uint positionId);\\n  error InvalidSplitAmount(address thrower, uint originalPositionAmount, uint splitAmount);\\n  error ResultingOriginalPositionLiquidatable(address thrower, OptionPosition position, uint spotPrice);\\n  error ResultingNewPositionLiquidatable(address thrower, OptionPosition position, uint spotPrice);\\n\\n  // Merging\\n  error MustMergeTwoOrMorePositions(address thrower);\\n  error MergingUnapprovedPosition(address thrower, address caller, uint positionId);\\n  error PositionMismatchWhenMerging(\\n    address thrower,\\n    OptionPosition firstPosition,\\n    OptionPosition nextPosition,\\n    bool ownerMismatch,\\n    bool strikeMismatch,\\n    bool optionTypeMismatch,\\n    bool duplicatePositionId\\n  );\\n\\n  // Access\\n  error StrikeIsSettled(address thrower, uint strikeId);\\n  error OnlyOptionMarket(address thrower, address caller, address optionMarket);\\n  error OnlyShortCollateral(address thrower, address caller, address shortCollateral);\\n}\\n\",\"keccak256\":\"0x3b8a177fe2f2a840672d3d360a6554ccd4dd12a93f7ea14799773f3afe66674a\",\"license\":\"ISC\"},\"@lyrafinance/protocol/contracts/ShortCollateral.sol\":{\"content\":\"//SPDX-License-Identifier: ISC\\npragma solidity 0.8.9;\\n\\n// Libraries\\nimport \\\"./synthetix/DecimalMath.sol\\\";\\n// Inherited\\nimport \\\"./synthetix/Owned.sol\\\";\\nimport \\\"./libraries/SimpleInitializeable.sol\\\";\\nimport \\\"openzeppelin-contracts-4.4.1/security/ReentrancyGuard.sol\\\";\\n// Interfaces\\nimport \\\"openzeppelin-contracts-4.4.1/token/ERC20/ERC20.sol\\\";\\nimport \\\"./libraries/PoolHedger.sol\\\";\\nimport \\\"./SynthetixAdapter.sol\\\";\\nimport \\\"./LiquidityPool.sol\\\";\\nimport \\\"./OptionMarket.sol\\\";\\nimport \\\"./OptionToken.sol\\\";\\n\\n/**\\n * @title ShortCollateral\\n * @author Lyra\\n * @dev Holds collateral from users who are selling (shorting) options to the OptionMarket.\\n */\\ncontract ShortCollateral is Owned, SimpleInitializeable, ReentrancyGuard {\\n  using DecimalMath for uint;\\n\\n  OptionMarket internal optionMarket;\\n  LiquidityPool internal liquidityPool;\\n  OptionToken internal optionToken;\\n  SynthetixAdapter internal synthetixAdapter;\\n  ERC20 internal quoteAsset;\\n  ERC20 internal baseAsset;\\n\\n  // The amount the SC underpaid the LP due to insolvency.\\n  // The SC will take this much less from the LP when settling insolvent positions.\\n  uint public LPBaseExcess;\\n  uint public LPQuoteExcess;\\n\\n  ///////////\\n  // Setup //\\n  ///////////\\n\\n  constructor() Owned() {}\\n\\n  /**\\n   * @dev Initialize the contract.\\n   */\\n  function init(\\n    OptionMarket _optionMarket,\\n    LiquidityPool _liquidityPool,\\n    OptionToken _optionToken,\\n    SynthetixAdapter _synthetixAdapter,\\n    ERC20 _quoteAsset,\\n    ERC20 _baseAsset\\n  ) external onlyOwner initializer {\\n    optionMarket = _optionMarket;\\n    liquidityPool = _liquidityPool;\\n    optionToken = _optionToken;\\n    synthetixAdapter = _synthetixAdapter;\\n    quoteAsset = _quoteAsset;\\n    baseAsset = _baseAsset;\\n\\n    synthetixAdapter.delegateApprovals().approveExchangeOnBehalf(address(synthetixAdapter));\\n  }\\n\\n  ///////////\\n  // Admin //\\n  ///////////\\n\\n  /// @dev In case of an update to the synthetix contract that revokes the approval\\n  function updateDelegateApproval() external onlyOwner {\\n    synthetixAdapter.delegateApprovals().approveExchangeOnBehalf(address(synthetixAdapter));\\n  }\\n\\n  ////////////////////////////////\\n  // Collateral/premium sending //\\n  ////////////////////////////////\\n\\n  /**\\n   * @notice Transfers quoteAsset to the recipient. This should only be called by OptionMarket in the following cases:\\n   * - A short is closed, in which case the premium for the option is sent to the LP\\n   * - A user reduces their collateral position on a quote collateralized option\\n   *\\n   * @param recipient The recipient of the transfer.\\n   * @param amount The amount to send.\\n   */\\n  function sendQuoteCollateral(address recipient, uint amount) external onlyOptionMarket {\\n    _sendQuoteCollateral(recipient, amount);\\n  }\\n\\n  /**\\n   * @notice Transfers baseAsset to the recipient. This should only be called by OptionMarket when a user is reducing\\n   * their collateral on a base collateralized option.\\n   *\\n   * @param recipient The recipient of the transfer.\\n   * @param amount The amount to send.\\n   */\\n  function sendBaseCollateral(address recipient, uint amount) external onlyOptionMarket {\\n    _sendBaseCollateral(recipient, amount);\\n  }\\n\\n  /**\\n   * @notice Transfers quote/base fees and remaining collateral when `OptionMarket.liquidatePosition()` called\\n   * - liquidator: liquidator portion of liquidation fees\\n   * - LiquidityPool: premium to close position + LP portion of liquidation fees\\n   * - OptionMarket: SM portion of the liquidation fees\\n   * - position owner: remaining collateral after all above fees deducted\\n   *\\n   * @param trader address of position owner\\n   * @param liquidator address of liquidator\\n   * @param optionType OptionType\\n   * @param liquidationFees fee/collateral distribution as determined by OptionToken\\n   */\\n  function routeLiquidationFunds(\\n    address trader,\\n    address liquidator,\\n    OptionMarket.OptionType optionType,\\n    OptionToken.LiquidationFees memory liquidationFees\\n  ) external onlyOptionMarket {\\n    if (optionType == OptionMarket.OptionType.SHORT_CALL_BASE) {\\n      _sendBaseCollateral(trader, liquidationFees.returnCollateral);\\n      _sendBaseCollateral(liquidator, liquidationFees.liquidatorFee);\\n      _exchangeAndSendBaseCollateral(address(optionMarket), liquidationFees.smFee);\\n      _exchangeAndSendBaseCollateral(address(liquidityPool), liquidationFees.lpFee + liquidationFees.lpPremiums);\\n    } else {\\n      // quote collateral\\n      _sendQuoteCollateral(trader, liquidationFees.returnCollateral);\\n      _sendQuoteCollateral(liquidator, liquidationFees.liquidatorFee);\\n      _sendQuoteCollateral(address(optionMarket), liquidationFees.smFee);\\n      _sendQuoteCollateral(address(liquidityPool), liquidationFees.lpFee + liquidationFees.lpPremiums);\\n    }\\n  }\\n\\n  //////////////////////\\n  // Board settlement //\\n  //////////////////////\\n\\n  /**\\n   * @notice Transfers quoteAsset and baseAsset to the LiquidityPool on board settlement.\\n   *\\n   * @param amountBase The amount of baseAsset to transfer.\\n   * @param amountQuote The amount of quoteAsset to transfer.\\n   * @return lpBaseInsolvency total base amount owed to LP but not sent due to large amount of user insolvencies\\n   * @return lpQuoteInsolvency total quote amount owed to LP but not sent due to large amount of user insolvencies\\n   */\\n  function boardSettlement(uint amountBase, uint amountQuote)\\n    external\\n    onlyOptionMarket\\n    returns (uint lpBaseInsolvency, uint lpQuoteInsolvency)\\n  {\\n    uint currentBaseBalance = baseAsset.balanceOf(address(this));\\n    if (amountBase > currentBaseBalance) {\\n      lpBaseInsolvency = amountBase - currentBaseBalance;\\n      amountBase = currentBaseBalance;\\n      LPBaseExcess += lpBaseInsolvency;\\n    }\\n\\n    uint currentQuoteBalance = quoteAsset.balanceOf(address(this));\\n    if (amountQuote > currentQuoteBalance) {\\n      lpQuoteInsolvency = amountQuote - currentQuoteBalance;\\n      amountQuote = currentQuoteBalance;\\n      LPQuoteExcess += lpQuoteInsolvency;\\n    }\\n\\n    _sendBaseCollateral(address(liquidityPool), amountBase);\\n    _sendQuoteCollateral(address(liquidityPool), amountQuote);\\n\\n    emit BoardSettlementCollateralSent(\\n      amountBase,\\n      amountQuote,\\n      lpBaseInsolvency,\\n      lpQuoteInsolvency,\\n      LPBaseExcess,\\n      LPQuoteExcess\\n    );\\n\\n    return (lpBaseInsolvency, lpQuoteInsolvency);\\n  }\\n\\n  /////////////////////////\\n  // Position Settlement //\\n  /////////////////////////\\n\\n  /**\\n   * @notice Routes profits or remaining collateral for settled long and short options.\\n   *\\n   * @param positionIds The ids of the relevant OptionTokens.\\n   */\\n  function settleOptions(uint[] memory positionIds) external nonReentrant notGlobalPaused {\\n    // This is how much is missing from the ShortCollateral contract that was claimed by LPs at board expiry\\n    // We want to take it back when we know how much was missing.\\n    uint baseInsolventAmount;\\n    uint quoteInsolventAmount;\\n\\n    OptionToken.PositionWithOwner[] memory optionPositions = optionToken.getPositionsWithOwner(positionIds);\\n\\n    for (uint i = 0; i < optionPositions.length; i++) {\\n      OptionToken.PositionWithOwner memory position = optionPositions[i];\\n      uint settlementAmount;\\n      uint insolventAmount;\\n      (uint strikePrice, uint priceAtExpiry, uint ammShortCallBaseProfitRatio) = optionMarket.getSettlementParameters(\\n        position.strikeId\\n      );\\n\\n      if (priceAtExpiry == 0) {\\n        revert BoardMustBeSettled(address(this), position);\\n      }\\n\\n      if (position.optionType == OptionMarket.OptionType.LONG_CALL) {\\n        settlementAmount = _sendLongCallProceeds(position.owner, position.amount, strikePrice, priceAtExpiry);\\n      } else if (position.optionType == OptionMarket.OptionType.LONG_PUT) {\\n        settlementAmount = _sendLongPutProceeds(position.owner, position.amount, strikePrice, priceAtExpiry);\\n      } else if (position.optionType == OptionMarket.OptionType.SHORT_CALL_BASE) {\\n        (settlementAmount, insolventAmount) = _sendShortCallBaseProceeds(\\n          position.owner,\\n          position.collateral,\\n          position.amount,\\n          ammShortCallBaseProfitRatio\\n        );\\n        baseInsolventAmount += insolventAmount;\\n      } else if (position.optionType == OptionMarket.OptionType.SHORT_CALL_QUOTE) {\\n        (settlementAmount, insolventAmount) = _sendShortCallQuoteProceeds(\\n          position.owner,\\n          position.collateral,\\n          position.amount,\\n          strikePrice,\\n          priceAtExpiry\\n        );\\n        quoteInsolventAmount += insolventAmount;\\n      } else {\\n        // OptionMarket.OptionType.SHORT_PUT_QUOTE\\n        (settlementAmount, insolventAmount) = _sendShortPutQuoteProceeds(\\n          position.owner,\\n          position.collateral,\\n          position.amount,\\n          strikePrice,\\n          priceAtExpiry\\n        );\\n        quoteInsolventAmount += insolventAmount;\\n      }\\n\\n      emit PositionSettled(\\n        position.positionId,\\n        msg.sender,\\n        position.owner,\\n        strikePrice,\\n        priceAtExpiry,\\n        position.optionType,\\n        position.amount,\\n        settlementAmount,\\n        insolventAmount\\n      );\\n    }\\n\\n    _reclaimInsolvency(baseInsolventAmount, quoteInsolventAmount);\\n    optionToken.settlePositions(positionIds);\\n  }\\n\\n  /// @dev Send quote or base owed to LiquidityPool due to large number of insolvencies\\n  function _reclaimInsolvency(uint baseInsolventAmount, uint quoteInsolventAmount) internal {\\n    SynthetixAdapter.ExchangeParams memory exchangeParams = synthetixAdapter.getExchangeParams(address(optionMarket));\\n\\n    if (LPBaseExcess > baseInsolventAmount) {\\n      LPBaseExcess -= baseInsolventAmount;\\n    } else if (baseInsolventAmount > 0) {\\n      baseInsolventAmount -= LPBaseExcess;\\n      LPBaseExcess = 0;\\n      liquidityPool.reclaimInsolventBase(exchangeParams, baseInsolventAmount);\\n    }\\n\\n    if (LPQuoteExcess > quoteInsolventAmount) {\\n      LPQuoteExcess -= quoteInsolventAmount;\\n    } else if (quoteInsolventAmount > 0) {\\n      quoteInsolventAmount -= LPQuoteExcess;\\n      LPQuoteExcess = 0;\\n      liquidityPool.reclaimInsolventQuote(exchangeParams.spotPrice, quoteInsolventAmount);\\n    }\\n  }\\n\\n  function _sendLongCallProceeds(\\n    address account,\\n    uint amount,\\n    uint strikePrice,\\n    uint priceAtExpiry\\n  ) internal returns (uint settlementAmount) {\\n    settlementAmount = (priceAtExpiry > strikePrice) ? (priceAtExpiry - strikePrice).multiplyDecimal(amount) : 0;\\n    liquidityPool.sendSettlementValue(account, settlementAmount);\\n    return settlementAmount;\\n  }\\n\\n  function _sendLongPutProceeds(\\n    address account,\\n    uint amount,\\n    uint strikePrice,\\n    uint priceAtExpiry\\n  ) internal returns (uint settlementAmount) {\\n    settlementAmount = (strikePrice > priceAtExpiry) ? (strikePrice - priceAtExpiry).multiplyDecimal(amount) : 0;\\n    liquidityPool.sendSettlementValue(account, settlementAmount);\\n    return settlementAmount;\\n  }\\n\\n  function _sendShortCallBaseProceeds(\\n    address account,\\n    uint userCollateral,\\n    uint amount,\\n    uint strikeToBaseReturnedRatio\\n  ) internal returns (uint settlementAmount, uint insolvency) {\\n    uint ammProfit = strikeToBaseReturnedRatio.multiplyDecimal(amount);\\n    (settlementAmount, insolvency) = _getInsolvency(userCollateral, ammProfit);\\n    _sendBaseCollateral(account, settlementAmount);\\n    return (settlementAmount, insolvency);\\n  }\\n\\n  function _sendShortCallQuoteProceeds(\\n    address account,\\n    uint userCollateral,\\n    uint amount,\\n    uint strikePrice,\\n    uint priceAtExpiry\\n  ) internal returns (uint settlementAmount, uint insolvency) {\\n    uint ammProfit = (priceAtExpiry > strikePrice) ? (priceAtExpiry - strikePrice).multiplyDecimal(amount) : 0;\\n    (settlementAmount, insolvency) = _getInsolvency(userCollateral, ammProfit);\\n    _sendQuoteCollateral(account, settlementAmount);\\n    return (settlementAmount, insolvency);\\n  }\\n\\n  function _sendShortPutQuoteProceeds(\\n    address account,\\n    uint userCollateral,\\n    uint amount,\\n    uint strikePrice,\\n    uint priceAtExpiry\\n  ) internal returns (uint settlementAmount, uint insolvency) {\\n    uint ammProfit = (priceAtExpiry < strikePrice) ? (strikePrice - priceAtExpiry).multiplyDecimal(amount) : 0;\\n    (settlementAmount, insolvency) = _getInsolvency(userCollateral, ammProfit);\\n    _sendQuoteCollateral(account, settlementAmount);\\n    return (settlementAmount, insolvency);\\n  }\\n\\n  function _getInsolvency(uint userCollateral, uint ammProfit)\\n    internal\\n    pure\\n    returns (uint returnCollateral, uint insolvency)\\n  {\\n    if (userCollateral >= ammProfit) {\\n      returnCollateral = userCollateral - ammProfit;\\n    } else {\\n      insolvency = ammProfit - userCollateral;\\n    }\\n    return (returnCollateral, insolvency);\\n  }\\n\\n  ///////////////\\n  // Transfers //\\n  ///////////////\\n  function _sendQuoteCollateral(address recipient, uint amount) internal {\\n    if (amount == 0) {\\n      return;\\n    }\\n\\n    uint currentBalance = quoteAsset.balanceOf(address(this));\\n\\n    if (amount > currentBalance) {\\n      revert OutOfQuoteCollateralForTransfer(address(this), currentBalance, amount);\\n    }\\n\\n    if (!quoteAsset.transfer(recipient, amount)) {\\n      revert QuoteTransferFailed(address(this), address(this), recipient, amount);\\n    }\\n    emit QuoteSent(recipient, amount);\\n  }\\n\\n  function _sendBaseCollateral(address recipient, uint amount) internal {\\n    if (amount == 0) {\\n      return;\\n    }\\n\\n    uint currentBalance = baseAsset.balanceOf(address(this));\\n\\n    if (amount > currentBalance) {\\n      revert OutOfBaseCollateralForTransfer(address(this), currentBalance, amount);\\n    }\\n\\n    if (!baseAsset.transfer(recipient, amount)) {\\n      revert BaseTransferFailed(address(this), address(this), recipient, amount);\\n    }\\n    emit BaseSent(recipient, amount);\\n  }\\n\\n  function _exchangeAndSendBaseCollateral(address recipient, uint amountBase) internal {\\n    if (amountBase == 0) {\\n      return;\\n    }\\n\\n    uint currentBalance = baseAsset.balanceOf(address(this));\\n    if (amountBase > currentBalance) {\\n      revert OutOfBaseCollateralForExchangeAndTransfer(address(this), currentBalance, amountBase);\\n    }\\n\\n    uint quoteReceived = synthetixAdapter.exchangeFromExactBase(address(optionMarket), amountBase);\\n\\n    if (!quoteAsset.transfer(recipient, quoteReceived)) {\\n      revert QuoteTransferFailed(address(this), address(this), recipient, quoteReceived);\\n    }\\n\\n    emit BaseExchangedAndQuoteSent(recipient, amountBase, quoteReceived);\\n  }\\n\\n  ///////////////\\n  // Modifiers //\\n  ///////////////\\n\\n  modifier onlyOptionMarket() {\\n    if (msg.sender != address(optionMarket)) {\\n      revert OnlyOptionMarket(address(this), msg.sender, address(optionMarket));\\n    }\\n    _;\\n  }\\n\\n  modifier notGlobalPaused() {\\n    synthetixAdapter.requireNotGlobalPaused(address(optionMarket));\\n    _;\\n  }\\n\\n  ////////////\\n  // Events //\\n  ////////////\\n\\n  /// @dev Emitted when a board is settled\\n  event BoardSettlementCollateralSent(\\n    uint amountBaseSent,\\n    uint amountQuoteSent,\\n    uint lpBaseInsolvency,\\n    uint lpQuoteInsolvency,\\n    uint LPBaseExcess,\\n    uint LPQuoteExcess\\n  );\\n\\n  /**\\n   * @dev Emitted when an Option is settled.\\n   */\\n  event PositionSettled(\\n    uint indexed positionId,\\n    address indexed settler,\\n    address indexed optionOwner,\\n    uint strikePrice,\\n    uint priceAtExpiry,\\n    OptionMarket.OptionType optionType,\\n    uint amount,\\n    uint settlementAmount,\\n    uint insolventAmount\\n  );\\n\\n  /**\\n   * @dev Emitted when quote is sent to either a user or the LiquidityPool\\n   */\\n  event QuoteSent(address indexed receiver, uint amount);\\n  /**\\n   * @dev Emitted when base is sent to either a user or the LiquidityPool\\n   */\\n  event BaseSent(address indexed receiver, uint amount);\\n\\n  event BaseExchangedAndQuoteSent(address indexed recipient, uint amountBase, uint quoteReceived);\\n\\n  ////////////\\n  // Errors //\\n  ////////////\\n\\n  // Collateral transfers\\n  error OutOfQuoteCollateralForTransfer(address thrower, uint balance, uint amount);\\n  error OutOfBaseCollateralForTransfer(address thrower, uint balance, uint amount);\\n  error OutOfBaseCollateralForExchangeAndTransfer(address thrower, uint balance, uint amount);\\n\\n  // Token transfers\\n  error BaseTransferFailed(address thrower, address from, address to, uint amount);\\n  error QuoteTransferFailed(address thrower, address from, address to, uint amount);\\n\\n  // Access\\n  error BoardMustBeSettled(address thrower, OptionToken.PositionWithOwner position);\\n  error OnlyOptionMarket(address thrower, address caller, address optionMarket);\\n}\\n\",\"keccak256\":\"0x90644c65546bf5677cf7313f13d704831fdae7df3f4e182591fb3f3a9ff110a3\",\"license\":\"ISC\"},\"@lyrafinance/protocol/contracts/SynthetixAdapter.sol\":{\"content\":\"//SPDX-License-Identifier: ISC\\npragma solidity 0.8.9;\\n\\n// Libraries\\nimport \\\"./synthetix/DecimalMath.sol\\\";\\n\\n// Inherited\\nimport \\\"./synthetix/OwnedUpgradeable.sol\\\";\\n\\n// Interfaces\\nimport \\\"./interfaces/ISynthetix.sol\\\";\\nimport \\\"./interfaces/IAddressResolver.sol\\\";\\nimport \\\"./interfaces/IExchanger.sol\\\";\\nimport \\\"./interfaces/IExchangeRates.sol\\\";\\nimport \\\"./LiquidityPool.sol\\\";\\nimport \\\"./interfaces/IDelegateApprovals.sol\\\";\\n\\n/**\\n * @title SynthetixAdapter\\n * @author Lyra\\n * @dev Manages access to exchange functions on Synthetix.\\n * The OptionMarket contract address is used as the key to access the relevant exchange parameters for the market.\\n */\\ncontract SynthetixAdapter is OwnedUpgradeable {\\n  using DecimalMath for uint;\\n\\n  /**\\n   * @dev Structs to help reduce the number of calls between other contracts and this one\\n   * Grouped in usage for a particular contract/use case\\n   */\\n  struct ExchangeParams {\\n    // snx oracle exchange rate for base\\n    uint spotPrice;\\n    // snx quote asset identifier key\\n    bytes32 quoteKey;\\n    // snx base asset identifier key\\n    bytes32 baseKey;\\n    // snx spot exchange rate from quote to base\\n    uint quoteBaseFeeRate;\\n    // snx spot exchange rate from base to quote\\n    uint baseQuoteFeeRate;\\n  }\\n\\n  /// @dev Pause the whole system. Note; this will not pause settling previously expired options.\\n  mapping(address => bool) public isMarketPaused;\\n  bool public isGlobalPaused;\\n\\n  IAddressResolver public addressResolver;\\n\\n  bytes32 private constant CONTRACT_SYNTHETIX = \\\"ProxySynthetix\\\";\\n  bytes32 private constant CONTRACT_EXCHANGER = \\\"Exchanger\\\";\\n  bytes32 private constant CONTRACT_EXCHANGE_RATES = \\\"ExchangeRates\\\";\\n  bytes32 private constant CONTRACT_DELEGATE_APPROVALS = \\\"DelegateApprovals\\\";\\n\\n  // Cached addresses that can be updated via a public function\\n  ISynthetix public synthetix;\\n  IExchanger public exchanger;\\n  IExchangeRates public exchangeRates;\\n  IDelegateApprovals public delegateApprovals;\\n\\n  // Variables related to calculating premium/fees\\n  mapping(address => bytes32) public quoteKey;\\n  mapping(address => bytes32) public baseKey;\\n  mapping(address => address) public rewardAddress;\\n  mapping(address => bytes32) public trackingCode;\\n\\n  function initialize() external initializer {\\n    __Ownable_init();\\n  }\\n\\n  /////////////\\n  // Setters //\\n  /////////////\\n\\n  /**\\n   * @dev Set the address of the Synthetix address resolver.\\n   *\\n   * @param _addressResolver The address of Synthetix's AddressResolver.\\n   */\\n  function setAddressResolver(IAddressResolver _addressResolver) external onlyOwner {\\n    addressResolver = _addressResolver;\\n    updateSynthetixAddresses();\\n    emit AddressResolverSet(addressResolver);\\n  }\\n\\n  /**\\n   * @dev Set the synthetixAdapter for a specific OptionMarket.\\n   *\\n   * @param _contractAddress The address of the OptionMarket.\\n   * @param _quoteKey The key of the quoteAsset.\\n   * @param _baseKey The key of the baseAsset.\\n   */\\n  function setGlobalsForContract(\\n    address _contractAddress,\\n    bytes32 _quoteKey,\\n    bytes32 _baseKey,\\n    address _rewardAddress,\\n    bytes32 _trackingCode\\n  ) external onlyOwner {\\n    if (_rewardAddress == address(0)) {\\n      revert InvalidRewardAddress(address(this), _rewardAddress);\\n    }\\n    quoteKey[_contractAddress] = _quoteKey;\\n    baseKey[_contractAddress] = _baseKey;\\n    rewardAddress[_contractAddress] = _rewardAddress;\\n    trackingCode[_contractAddress] = _trackingCode;\\n    emit GlobalsSetForContract(_contractAddress, _quoteKey, _baseKey, _rewardAddress, _trackingCode);\\n  }\\n\\n  /**\\n   * @dev Pauses all market actions for a given market.\\n   *\\n   * @param _isPaused Whether getting synthetixAdapter will revert or not.\\n   */\\n  function setMarketPaused(address _contractAddress, bool _isPaused) external onlyOwner {\\n    isMarketPaused[_contractAddress] = _isPaused;\\n    emit MarketPausedSet(_contractAddress, _isPaused);\\n  }\\n\\n  /**\\n   * @dev Pauses all market actions for all markets.\\n   *\\n   * @param _isPaused Whether getting synthetixAdapter will revert or not.\\n   */\\n  function setGlobalPaused(bool _isPaused) external onlyOwner {\\n    isGlobalPaused = _isPaused;\\n    emit GlobalPausedSet(_isPaused);\\n  }\\n\\n  //////////////////////\\n  // Address Resolver //\\n  //////////////////////\\n\\n  /**\\n   * @dev Public function to update synthetix addresses Lyra uses. The addresses are cached this way for gas efficiency.\\n   */\\n  function updateSynthetixAddresses() public {\\n    synthetix = ISynthetix(addressResolver.getAddress(CONTRACT_SYNTHETIX));\\n    exchanger = IExchanger(addressResolver.getAddress(CONTRACT_EXCHANGER));\\n    exchangeRates = IExchangeRates(addressResolver.getAddress(CONTRACT_EXCHANGE_RATES));\\n    delegateApprovals = IDelegateApprovals(addressResolver.getAddress(CONTRACT_DELEGATE_APPROVALS));\\n\\n    emit SynthetixAddressesUpdated(synthetix, exchanger, exchangeRates, delegateApprovals);\\n  }\\n\\n  /////////////\\n  // Getters //\\n  /////////////\\n  /**\\n   * @notice Returns the price of the baseAsset.\\n   *\\n   * @param _contractAddress The address of the OptionMarket.\\n   */\\n  function getSpotPriceForMarket(address _contractAddress)\\n    public\\n    view\\n    notPaused(_contractAddress)\\n    returns (uint spotPrice)\\n  {\\n    return getSpotPrice(baseKey[_contractAddress]);\\n  }\\n\\n  /**\\n   * @notice Gets spot price of an asset.\\n   * @dev All rates are denominated in terms of sUSD,\\n   * so the price of sUSD is always $1.00, and is never stale.\\n   *\\n   * @param to The key of the synthetic asset.\\n   */\\n  function getSpotPrice(bytes32 to) public view returns (uint) {\\n    (uint spotPrice, bool invalid) = exchangeRates.rateAndInvalid(to);\\n    if (spotPrice == 0 || invalid) {\\n      revert RateIsInvalid(address(this), spotPrice, invalid);\\n    }\\n    return spotPrice;\\n  }\\n\\n  /**\\n   * @notice Returns the ExchangeParams.\\n   *\\n   * @param optionMarket The address of the OptionMarket.\\n   */\\n  function getExchangeParams(address optionMarket)\\n    public\\n    view\\n    notPaused(optionMarket)\\n    returns (ExchangeParams memory exchangeParams)\\n  {\\n    exchangeParams = ExchangeParams({\\n      spotPrice: 0,\\n      quoteKey: quoteKey[optionMarket],\\n      baseKey: baseKey[optionMarket],\\n      quoteBaseFeeRate: 0,\\n      baseQuoteFeeRate: 0\\n    });\\n\\n    exchangeParams.spotPrice = getSpotPrice(exchangeParams.baseKey);\\n    exchangeParams.quoteBaseFeeRate = exchanger.feeRateForExchange(exchangeParams.quoteKey, exchangeParams.baseKey);\\n    exchangeParams.baseQuoteFeeRate = exchanger.feeRateForExchange(exchangeParams.baseKey, exchangeParams.quoteKey);\\n  }\\n\\n  /// @dev Revert if the global state is paused\\n  function requireNotGlobalPaused(address optionMarket) external view {\\n    if (isGlobalPaused) {\\n      revert AllMarketsPaused(address(this), optionMarket);\\n    }\\n  }\\n\\n  /////////////////////////////////////////\\n  // Exchanging QuoteAsset for BaseAsset //\\n  /////////////////////////////////////////\\n\\n  /**\\n   * @notice Swap an exact amount of quote for base.\\n   *\\n   * @param optionMarket The base asset of this option market to receive\\n   * @param amountQuote The exact amount of quote to be used for the swap\\n   * @return baseReceived The amount of base received from the swap\\n   */\\n  function exchangeFromExactQuote(address optionMarket, uint amountQuote) external returns (uint baseReceived) {\\n    return _exchangeQuoteForBase(optionMarket, amountQuote);\\n  }\\n\\n  /**\\n   * @notice Swap quote for an exact amount of base.\\n   *\\n   * @param exchangeParams The current exchange rates for the swap\\n   * @param optionMarket The base asset of this option market to receive\\n   * @param amountBase The exact amount of base to receive from the swap\\n   * @return quoteSpent The amount of quote spent on the swap\\n   * @return baseReceived The amount of base received\\n   */\\n  function exchangeToExactBase(\\n    ExchangeParams memory exchangeParams,\\n    address optionMarket,\\n    uint amountBase\\n  ) external returns (uint quoteSpent, uint baseReceived) {\\n    return exchangeToExactBaseWithLimit(exchangeParams, optionMarket, amountBase, type(uint).max);\\n  }\\n\\n  /**\\n   * @notice Swap quote for base with a limit on the amount of quote to be spent.\\n   *\\n   * @param exchangeParams The current exchange rates for the swap\\n   * @param optionMarket The base asset of this option market to receive\\n   * @param amountBase The exact amount of base to receive from the swap\\n   * @param quoteLimit The maximum amount of quote to spend for base\\n   * @return quoteSpent The amount of quote spent on the swap\\n   * @return baseReceived The amount of baes received from the swap\\n   */\\n  function exchangeToExactBaseWithLimit(\\n    ExchangeParams memory exchangeParams,\\n    address optionMarket,\\n    uint amountBase,\\n    uint quoteLimit\\n  ) public returns (uint quoteSpent, uint baseReceived) {\\n    uint quoteToSpend = estimateExchangeToExactBase(exchangeParams, amountBase);\\n    if (quoteToSpend > quoteLimit) {\\n      revert QuoteBaseExchangeExceedsLimit(\\n        address(this),\\n        amountBase,\\n        quoteToSpend,\\n        quoteLimit,\\n        exchangeParams.spotPrice,\\n        exchangeParams.quoteKey,\\n        exchangeParams.baseKey\\n      );\\n    }\\n\\n    return (quoteToSpend, _exchangeQuoteForBase(optionMarket, quoteToSpend));\\n  }\\n\\n  function _exchangeQuoteForBase(address optionMarket, uint amountQuote) internal returns (uint baseReceived) {\\n    if (amountQuote == 0) {\\n      return 0;\\n    }\\n    baseReceived = synthetix.exchangeOnBehalfWithTracking(\\n      msg.sender,\\n      quoteKey[optionMarket],\\n      amountQuote,\\n      baseKey[optionMarket],\\n      rewardAddress[optionMarket],\\n      trackingCode[optionMarket]\\n    );\\n    if (amountQuote > 1e10 && baseReceived == 0) {\\n      revert ReceivedZeroFromExchange(\\n        address(this),\\n        quoteKey[optionMarket],\\n        baseKey[optionMarket],\\n        amountQuote,\\n        baseReceived\\n      );\\n    }\\n    emit QuoteSwappedForBase(optionMarket, msg.sender, amountQuote, baseReceived);\\n    return baseReceived;\\n  }\\n\\n  /**\\n   * @notice Returns an estimated amount of quote required to swap for the specified amount of base.\\n   *\\n   * @param exchangeParams The current exchange rates for the swap\\n   * @param amountBase The amount of base to receive\\n   * @return quoteNeeded The amount of quote required to received the amount of base requested\\n   */\\n  function estimateExchangeToExactBase(ExchangeParams memory exchangeParams, uint amountBase)\\n    public\\n    pure\\n    returns (uint quoteNeeded)\\n  {\\n    return\\n      amountBase.divideDecimalRound(DecimalMath.UNIT - exchangeParams.quoteBaseFeeRate).multiplyDecimalRound(\\n        exchangeParams.spotPrice\\n      );\\n  }\\n\\n  /////////////////////////////////////////\\n  // Exchanging BaseAsset for QuoteAsset //\\n  /////////////////////////////////////////\\n\\n  /**\\n   * @notice Swap an exact amount of base for quote.\\n   *\\n   * @param optionMarket The base asset of this optionMarket to be used\\n   * @param amountBase The exact amount of base to be used for the swap\\n   * @return quoteReceived The amount of quote received from the swap\\n   */\\n  function exchangeFromExactBase(address optionMarket, uint amountBase) external returns (uint quoteReceived) {\\n    return _exchangeBaseForQuote(optionMarket, amountBase);\\n  }\\n\\n  /**\\n   * @notice Swap base for an exact amount of quote\\n   *\\n   * @param exchangeParams The current exchange rates for the swap\\n   * @param optionMarket The base asset of this optionMarket to be used\\n   * @param amountQuote The exact amount of quote to receive\\n   * @return baseSpent The amount of baseSpent on the swap\\n   * @return quoteReceived The amount of quote received from the swap\\n   */\\n  function exchangeToExactQuote(\\n    ExchangeParams memory exchangeParams,\\n    address optionMarket,\\n    uint amountQuote\\n  ) external returns (uint baseSpent, uint quoteReceived) {\\n    return exchangeToExactQuoteWithLimit(exchangeParams, optionMarket, amountQuote, type(uint).max);\\n  }\\n\\n  /**\\n   * @notice Swap base for an exact amount of quote with a limit on the amount of base to be used\\n   *\\n   * @param exchangeParams The current exchange rates for the swap\\n   * @param optionMarket The base asset of this optionMarket to be used\\n   * @param amountQuote The exact amount of quote to receive\\n   * @param baseLimit The limit on the amount of base to be used\\n   * @return baseSpent The amount of base spent on the swap\\n   * @return quoteReceived The amount of quote received from the swap\\n   */\\n  function exchangeToExactQuoteWithLimit(\\n    ExchangeParams memory exchangeParams,\\n    address optionMarket,\\n    uint amountQuote,\\n    uint baseLimit\\n  ) public returns (uint baseSpent, uint quoteReceived) {\\n    uint baseToSpend = estimateExchangeToExactQuote(exchangeParams, amountQuote);\\n    if (baseToSpend > baseLimit) {\\n      revert BaseQuoteExchangeExceedsLimit(\\n        address(this),\\n        amountQuote,\\n        baseToSpend,\\n        baseLimit,\\n        exchangeParams.spotPrice,\\n        exchangeParams.baseKey,\\n        exchangeParams.quoteKey\\n      );\\n    }\\n\\n    return (baseToSpend, _exchangeBaseForQuote(optionMarket, baseToSpend));\\n  }\\n\\n  function _exchangeBaseForQuote(address optionMarket, uint amountBase) internal returns (uint quoteReceived) {\\n    if (amountBase == 0) {\\n      return 0;\\n    }\\n    // swap exactly `amountBase` baseAsset for quoteAsset\\n    quoteReceived = synthetix.exchangeOnBehalfWithTracking(\\n      msg.sender,\\n      baseKey[optionMarket],\\n      amountBase,\\n      quoteKey[optionMarket],\\n      rewardAddress[optionMarket],\\n      trackingCode[optionMarket]\\n    );\\n    if (amountBase > 1e10 && quoteReceived == 0) {\\n      revert ReceivedZeroFromExchange(\\n        address(this),\\n        baseKey[optionMarket],\\n        quoteKey[optionMarket],\\n        amountBase,\\n        quoteReceived\\n      );\\n    }\\n    emit BaseSwappedForQuote(optionMarket, msg.sender, amountBase, quoteReceived);\\n    return quoteReceived;\\n  }\\n\\n  /**\\n   * @notice Returns an estimated amount of base required to swap for the amount of quote\\n   *\\n   * @param exchangeParams The current exchange rates for the swap\\n   * @param amountQuote The amount of quote to swap to\\n   * @return baseNeeded The amount of base required for the swap\\n   */\\n  function estimateExchangeToExactQuote(ExchangeParams memory exchangeParams, uint amountQuote)\\n    public\\n    pure\\n    returns (uint baseNeeded)\\n  {\\n    return\\n      amountQuote.divideDecimalRound(DecimalMath.UNIT - exchangeParams.baseQuoteFeeRate).divideDecimalRound(\\n        exchangeParams.spotPrice\\n      );\\n  }\\n\\n  ///////////////\\n  // Modifiers //\\n  ///////////////\\n\\n  modifier notPaused(address _contractAddress) {\\n    if (isGlobalPaused) {\\n      revert AllMarketsPaused(address(this), _contractAddress);\\n    }\\n    if (isMarketPaused[_contractAddress]) {\\n      revert MarketIsPaused(address(this), _contractAddress);\\n    }\\n    _;\\n  }\\n\\n  ////////////\\n  // Events //\\n  ////////////\\n\\n  /**\\n   * @dev Emitted when the address resolver is set.\\n   */\\n  event AddressResolverSet(IAddressResolver addressResolver);\\n  /**\\n   * @dev Emitted when synthetix contracts are updated.\\n   */\\n  event SynthetixAddressesUpdated(\\n    ISynthetix synthetix,\\n    IExchanger exchanger,\\n    IExchangeRates exchangeRates,\\n    IDelegateApprovals delegateApprovals\\n  );\\n  /**\\n   * @dev Emitted when values for a given option market are set.\\n   */\\n  event GlobalsSetForContract(\\n    address indexed market,\\n    bytes32 quoteKey,\\n    bytes32 baseKey,\\n    address rewardAddress,\\n    bytes32 trackingCode\\n  );\\n  /**\\n   * @dev Emitted when GlobalPause.\\n   */\\n  event GlobalPausedSet(bool isPaused);\\n  /**\\n   * @dev Emitted when single market paused.\\n   */\\n  event MarketPausedSet(address contractAddress, bool isPaused);\\n  /**\\n   * @dev Emitted when an exchange for base to quote occurs.\\n   * Which base and quote were swapped can be determined by the given marketAddress.\\n   */\\n  event BaseSwappedForQuote(\\n    address indexed marketAddress,\\n    address indexed exchanger,\\n    uint baseSwapped,\\n    uint quoteReceived\\n  );\\n  /**\\n   * @dev Emitted when an exchange for quote to base occurs.\\n   * Which base and quote were swapped can be determined by the given marketAddress.\\n   */\\n  event QuoteSwappedForBase(\\n    address indexed marketAddress,\\n    address indexed exchanger,\\n    uint quoteSwapped,\\n    uint baseReceived\\n  );\\n\\n  ////////////\\n  // Errors //\\n  ////////////\\n  // Admin\\n  error InvalidRewardAddress(address thrower, address rewardAddress);\\n\\n  // Market Paused\\n  error AllMarketsPaused(address thrower, address marketAddress);\\n  error MarketIsPaused(address thrower, address marketAddress);\\n\\n  // Exchanging\\n  error ReceivedZeroFromExchange(\\n    address thrower,\\n    bytes32 fromKey,\\n    bytes32 toKey,\\n    uint amountSwapped,\\n    uint amountReceived\\n  );\\n  error QuoteBaseExchangeExceedsLimit(\\n    address thrower,\\n    uint amountBaseRequested,\\n    uint quoteToSpend,\\n    uint quoteLimit,\\n    uint spotPrice,\\n    bytes32 quoteKey,\\n    bytes32 baseKey\\n  );\\n  error BaseQuoteExchangeExceedsLimit(\\n    address thrower,\\n    uint amountQuoteRequested,\\n    uint baseToSpend,\\n    uint baseLimit,\\n    uint spotPrice,\\n    bytes32 baseKey,\\n    bytes32 quoteKey\\n  );\\n  error RateIsInvalid(address thrower, uint spotPrice, bool invalid);\\n}\\n\",\"keccak256\":\"0xb89c9c5fe3c97ae2cee2a4ae964b2ac9055f7e7dc8e4d46c4eb9a9ecdb6fec66\",\"license\":\"ISC\"},\"@lyrafinance/protocol/contracts/interfaces/IAddressResolver.sol\":{\"content\":\"//SPDX-License-Identifier: ISC\\npragma solidity ^0.8.9;\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/iaddressresolver\\ninterface IAddressResolver {\\n  function getAddress(bytes32 name) external view returns (address);\\n}\\n\",\"keccak256\":\"0x260e0cd742719bccaa7a070f5fcb94d61e800106750a4f889a2b7a9c157d717b\",\"license\":\"ISC\"},\"@lyrafinance/protocol/contracts/interfaces/ICurve.sol\":{\"content\":\"//SPDX-License-Identifier: ISC\\npragma solidity ^0.8.9;\\n\\ninterface ICurve {\\n  function exchange_with_best_rate(\\n    address _from,\\n    address _to,\\n    uint _amount,\\n    uint _expected,\\n    address _receiver\\n  ) external payable returns (uint amountOut);\\n\\n  function exchange_underlying(\\n    int128 _from,\\n    int128 _to,\\n    uint _amount,\\n    uint _expected\\n  ) external payable returns (uint amountOut);\\n\\n  function get_best_rate(\\n    address _from,\\n    address _to,\\n    uint _amount\\n  ) external view returns (address pool, uint amountOut);\\n}\\n\",\"keccak256\":\"0x016c7fa88dead72662e455bff791dc1898627757876606fc32b2e37f293b6990\",\"license\":\"ISC\"},\"@lyrafinance/protocol/contracts/interfaces/IDelegateApprovals.sol\":{\"content\":\"//SPDX-License-Identifier: ISC\\npragma solidity ^0.8.9;\\n\\ninterface IDelegateApprovals {\\n  function approveExchangeOnBehalf(address delegate) external;\\n}\\n\",\"keccak256\":\"0x8fa682b3dce7aefc56dca44ab1adac2d02caea6ac89eb22f1612354240486f13\",\"license\":\"ISC\"},\"@lyrafinance/protocol/contracts/interfaces/IExchangeRates.sol\":{\"content\":\"//SPDX-License-Identifier:MIT\\npragma solidity ^0.8.9;\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/iexchangerates\\ninterface IExchangeRates {\\n  function rateAndInvalid(bytes32 currencyKey) external view returns (uint rate, bool isInvalid);\\n}\\n\",\"keccak256\":\"0xf475f01aaa23f721273fc4b91f45589c13c7dad344f8e1d6d5ac84fcae5c316a\",\"license\":\"MIT\"},\"@lyrafinance/protocol/contracts/interfaces/IExchanger.sol\":{\"content\":\"//SPDX-License-Identifier:MIT\\npragma solidity ^0.8.9;\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/iexchanger\\ninterface IExchanger {\\n  function feeRateForExchange(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey)\\n    external\\n    view\\n    returns (uint exchangeFeeRate);\\n}\\n\",\"keccak256\":\"0x977c63c307c4832f4399d77ba9961a295620560f2afc5b2717eaf3cf71f82da6\",\"license\":\"MIT\"},\"@lyrafinance/protocol/contracts/interfaces/IFeeCounter.sol\":{\"content\":\"//SPDX-License-Identifier: ISC\\npragma solidity ^0.8.9;\\n\\ninterface IFeeCounter {\\n  function trackFee(\\n    address market,\\n    address trader,\\n    uint amount,\\n    uint totalCost,\\n    uint totalFee\\n  ) external;\\n}\\n\",\"keccak256\":\"0xf401d58dec60111f52aa3902454d7aa8dcd58b489d69c01bffde67a5aeafeafa\",\"license\":\"ISC\"},\"@lyrafinance/protocol/contracts/interfaces/ILiquidityTracker.sol\":{\"content\":\"//SPDX-License-Identifier: ISC\\npragma solidity ^0.8.9;\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/iaddressresolver\\ninterface ILiquidityTracker {\\n  function addTokens(address trader, uint amount) external;\\n\\n  function removeTokens(address trader, uint amount) external;\\n}\\n\",\"keccak256\":\"0x68542752ab4675f9a34943314cd00257100fe8093cc748ef3249562f4df13a3e\",\"license\":\"ISC\"},\"@lyrafinance/protocol/contracts/interfaces/ISynthetix.sol\":{\"content\":\"//SPDX-License-Identifier: ISC\\npragma solidity ^0.8.9;\\n\\ninterface ISynthetix {\\n  function exchange(\\n    bytes32 sourceCurrencyKey,\\n    uint sourceAmount,\\n    bytes32 destinationCurrencyKey\\n  ) external returns (uint amountReceived);\\n\\n  function exchangeOnBehalfWithTracking(\\n    address exchangeForAddress,\\n    bytes32 sourceCurrencyKey,\\n    uint sourceAmount,\\n    bytes32 destinationCurrencyKey,\\n    address rewardAddress,\\n    bytes32 trackingCode\\n  ) external returns (uint amountReceived);\\n}\\n\",\"keccak256\":\"0x8b115aed5963422a16354518ce83459c83aebf181488ba36fa91d657d4a314cf\",\"license\":\"ISC\"},\"@lyrafinance/protocol/contracts/libraries/BlackScholes.sol\":{\"content\":\"//SPDX-License-Identifier: ISC\\npragma solidity 0.8.9;\\n\\n// Libraries\\nimport \\\"../synthetix/SignedDecimalMath.sol\\\";\\nimport \\\"../synthetix/DecimalMath.sol\\\";\\nimport \\\"./FixedPointMathLib.sol\\\";\\n\\n/**\\n * @title BlackScholes\\n * @author Lyra\\n * @dev Contract to compute the black scholes price of options. Where the unit is unspecified, it should be treated as a\\n * PRECISE_DECIMAL, which has 1e27 units of precision. The default decimal matches the ethereum standard of 1e18 units\\n * of precision.\\n */\\nlibrary BlackScholes {\\n  using DecimalMath for uint;\\n  using SignedDecimalMath for int;\\n\\n  struct PricesDeltaStdVega {\\n    uint callPrice;\\n    uint putPrice;\\n    int callDelta;\\n    int putDelta;\\n    uint vega;\\n    uint stdVega;\\n  }\\n\\n  /**\\n   * @param timeToExpirySec Number of seconds to the expiry of the option\\n   * @param volatilityDecimal Implied volatility over the period til expiry as a percentage\\n   * @param spotDecimal The current price of the base asset\\n   * @param strikePriceDecimal The strikePrice price of the option\\n   * @param rateDecimal The percentage risk free rate + carry cost\\n   */\\n  struct BlackScholesInputs {\\n    uint timeToExpirySec;\\n    uint volatilityDecimal;\\n    uint spotDecimal;\\n    uint strikePriceDecimal;\\n    int rateDecimal;\\n  }\\n\\n  uint private constant SECONDS_PER_YEAR = 31536000;\\n  /// @dev Internally this library uses 27 decimals of precision\\n  uint private constant PRECISE_UNIT = 1e27;\\n  uint private constant SQRT_TWOPI = 2506628274631000502415765285;\\n  /// @dev Below this value, return 0\\n  int private constant MIN_CDF_STD_DIST_INPUT = (int(PRECISE_UNIT) * -45) / 10; // -4.5\\n  /// @dev Above this value, return 1\\n  int private constant MAX_CDF_STD_DIST_INPUT = int(PRECISE_UNIT) * 10;\\n  /// @dev Value to use to avoid any division by 0 or values near 0\\n  uint private constant MIN_T_ANNUALISED = PRECISE_UNIT / SECONDS_PER_YEAR; // 1 second\\n  uint private constant MIN_VOLATILITY = PRECISE_UNIT / 10000; // 0.001%\\n  uint private constant VEGA_STANDARDISATION_MIN_DAYS = 7 days;\\n  /// @dev Magic numbers for normal CDF\\n  uint private constant SPLIT = 7071067811865470000000000000;\\n  uint private constant N0 = 220206867912376000000000000000;\\n  uint private constant N1 = 221213596169931000000000000000;\\n  uint private constant N2 = 112079291497871000000000000000;\\n  uint private constant N3 = 33912866078383000000000000000;\\n  uint private constant N4 = 6373962203531650000000000000;\\n  uint private constant N5 = 700383064443688000000000000;\\n  uint private constant N6 = 35262496599891100000000000;\\n  uint private constant M0 = 440413735824752000000000000000;\\n  uint private constant M1 = 793826512519948000000000000000;\\n  uint private constant M2 = 637333633378831000000000000000;\\n  uint private constant M3 = 296564248779674000000000000000;\\n  uint private constant M4 = 86780732202946100000000000000;\\n  uint private constant M5 = 16064177579207000000000000000;\\n  uint private constant M6 = 1755667163182640000000000000;\\n  uint private constant M7 = 88388347648318400000000000;\\n\\n  /////////////////////////////////////\\n  // Option Pricing public functions //\\n  /////////////////////////////////////\\n\\n  /**\\n   * @dev Returns call and put prices for options with given parameters.\\n   */\\n  function optionPrices(BlackScholesInputs memory bsInput) public pure returns (uint call, uint put) {\\n    uint tAnnualised = _annualise(bsInput.timeToExpirySec);\\n    uint spotPrecise = bsInput.spotDecimal.decimalToPreciseDecimal();\\n    uint strikePricePrecise = bsInput.strikePriceDecimal.decimalToPreciseDecimal();\\n    int ratePrecise = bsInput.rateDecimal.decimalToPreciseDecimal();\\n    (int d1, int d2) = _d1d2(\\n      tAnnualised,\\n      bsInput.volatilityDecimal.decimalToPreciseDecimal(),\\n      spotPrecise,\\n      strikePricePrecise,\\n      ratePrecise\\n    );\\n    (call, put) = _optionPrices(tAnnualised, spotPrecise, strikePricePrecise, ratePrecise, d1, d2);\\n    return (call.preciseDecimalToDecimal(), put.preciseDecimalToDecimal());\\n  }\\n\\n  /**\\n   * @dev Returns call/put prices and delta/stdVega for options with given parameters.\\n   */\\n  function pricesDeltaStdVega(BlackScholesInputs memory bsInput) public pure returns (PricesDeltaStdVega memory) {\\n    uint tAnnualised = _annualise(bsInput.timeToExpirySec);\\n    uint spotPrecise = bsInput.spotDecimal.decimalToPreciseDecimal();\\n\\n    (int d1, int d2) = _d1d2(\\n      tAnnualised,\\n      bsInput.volatilityDecimal.decimalToPreciseDecimal(),\\n      spotPrecise,\\n      bsInput.strikePriceDecimal.decimalToPreciseDecimal(),\\n      bsInput.rateDecimal.decimalToPreciseDecimal()\\n    );\\n    (uint callPrice, uint putPrice) = _optionPrices(\\n      tAnnualised,\\n      spotPrecise,\\n      bsInput.strikePriceDecimal.decimalToPreciseDecimal(),\\n      bsInput.rateDecimal.decimalToPreciseDecimal(),\\n      d1,\\n      d2\\n    );\\n    (uint vegaPrecise, uint stdVegaPrecise) = _standardVega(d1, spotPrecise, bsInput.timeToExpirySec);\\n    (int callDelta, int putDelta) = _delta(d1);\\n\\n    return\\n      PricesDeltaStdVega(\\n        callPrice.preciseDecimalToDecimal(),\\n        putPrice.preciseDecimalToDecimal(),\\n        callDelta.preciseDecimalToDecimal(),\\n        putDelta.preciseDecimalToDecimal(),\\n        vegaPrecise.preciseDecimalToDecimal(),\\n        stdVegaPrecise.preciseDecimalToDecimal()\\n      );\\n  }\\n\\n  /**\\n   * @dev Returns call delta given parameters.\\n   */\\n\\n  function delta(BlackScholesInputs memory bsInput) public pure returns (int callDeltaDecimal, int putDeltaDecimal) {\\n    uint tAnnualised = _annualise(bsInput.timeToExpirySec);\\n    uint spotPrecise = bsInput.spotDecimal.decimalToPreciseDecimal();\\n\\n    (int d1, ) = _d1d2(\\n      tAnnualised,\\n      bsInput.volatilityDecimal.decimalToPreciseDecimal(),\\n      spotPrecise,\\n      bsInput.strikePriceDecimal.decimalToPreciseDecimal(),\\n      bsInput.rateDecimal.decimalToPreciseDecimal()\\n    );\\n\\n    (int callDelta, int putDelta) = _delta(d1);\\n    return (callDelta.preciseDecimalToDecimal(), putDelta.preciseDecimalToDecimal());\\n  }\\n\\n  /**\\n   * @dev Returns non-normalized vega given parameters. Quoted in cents.\\n   */\\n  function vega(BlackScholesInputs memory bsInput) public pure returns (uint vegaDecimal) {\\n    uint tAnnualised = _annualise(bsInput.timeToExpirySec);\\n    uint spotPrecise = bsInput.spotDecimal.decimalToPreciseDecimal();\\n\\n    (int d1, ) = _d1d2(\\n      tAnnualised,\\n      bsInput.volatilityDecimal.decimalToPreciseDecimal(),\\n      spotPrecise,\\n      bsInput.strikePriceDecimal.decimalToPreciseDecimal(),\\n      bsInput.rateDecimal.decimalToPreciseDecimal()\\n    );\\n    return _vega(tAnnualised, spotPrecise, d1).preciseDecimalToDecimal();\\n  }\\n\\n  //////////////////////\\n  // Computing Greeks //\\n  //////////////////////\\n\\n  /**\\n   * @dev Returns internal coefficients of the Black-Scholes call price formula, d1 and d2.\\n   * @param tAnnualised Number of years to expiry\\n   * @param volatility Implied volatility over the period til expiry as a percentage\\n   * @param spot The current price of the base asset\\n   * @param strikePrice The strikePrice price of the option\\n   * @param rate The percentage risk free rate + carry cost\\n   */\\n  function _d1d2(\\n    uint tAnnualised,\\n    uint volatility,\\n    uint spot,\\n    uint strikePrice,\\n    int rate\\n  ) internal pure returns (int d1, int d2) {\\n    // Set minimum values for tAnnualised and volatility to not break computation in extreme scenarios\\n    // These values will result in option prices reflecting only the difference in stock/strikePrice, which is expected.\\n    // This should be caught before calling this function, however the function shouldn't break if the values are 0.\\n    tAnnualised = tAnnualised < MIN_T_ANNUALISED ? MIN_T_ANNUALISED : tAnnualised;\\n    volatility = volatility < MIN_VOLATILITY ? MIN_VOLATILITY : volatility;\\n\\n    int vtSqrt = int(volatility.multiplyDecimalRoundPrecise(_sqrtPrecise(tAnnualised)));\\n    int log = FixedPointMathLib.lnPrecise(int(spot.divideDecimalRoundPrecise(strikePrice)));\\n    int v2t = (int(volatility.multiplyDecimalRoundPrecise(volatility) / 2) + rate).multiplyDecimalRoundPrecise(\\n      int(tAnnualised)\\n    );\\n    d1 = (log + v2t).divideDecimalRoundPrecise(vtSqrt);\\n    d2 = d1 - vtSqrt;\\n  }\\n\\n  /**\\n   * @dev Internal coefficients of the Black-Scholes call price formula.\\n   * @param tAnnualised Number of years to expiry\\n   * @param spot The current price of the base asset\\n   * @param strikePrice The strikePrice price of the option\\n   * @param rate The percentage risk free rate + carry cost\\n   * @param d1 Internal coefficient of Black-Scholes\\n   * @param d2 Internal coefficient of Black-Scholes\\n   */\\n  function _optionPrices(\\n    uint tAnnualised,\\n    uint spot,\\n    uint strikePrice,\\n    int rate,\\n    int d1,\\n    int d2\\n  ) internal pure returns (uint call, uint put) {\\n    uint strikePricePV = strikePrice.multiplyDecimalRoundPrecise(\\n      FixedPointMathLib.expPrecise(int(-rate.multiplyDecimalRoundPrecise(int(tAnnualised))))\\n    );\\n    uint spotNd1 = spot.multiplyDecimalRoundPrecise(_stdNormalCDF(d1));\\n    uint strikePriceNd2 = strikePricePV.multiplyDecimalRoundPrecise(_stdNormalCDF(d2));\\n\\n    // We clamp to zero if the minuend is less than the subtrahend\\n    // In some scenarios it may be better to compute put price instead and derive call from it depending on which way\\n    // around is more precise.\\n    call = strikePriceNd2 <= spotNd1 ? spotNd1 - strikePriceNd2 : 0;\\n    put = call + strikePricePV;\\n    put = spot <= put ? put - spot : 0;\\n  }\\n\\n  /*\\n   * Greeks\\n   */\\n\\n  /**\\n   * @dev Returns the option's delta value\\n   * @param d1 Internal coefficient of Black-Scholes\\n   */\\n  function _delta(int d1) internal pure returns (int callDelta, int putDelta) {\\n    callDelta = int(_stdNormalCDF(d1));\\n    putDelta = callDelta - int(PRECISE_UNIT);\\n  }\\n\\n  /**\\n   * @dev Returns the option's vega value based on d1. Quoted in cents.\\n   *\\n   * @param d1 Internal coefficient of Black-Scholes\\n   * @param tAnnualised Number of years to expiry\\n   * @param spot The current price of the base asset\\n   */\\n  function _vega(\\n    uint tAnnualised,\\n    uint spot,\\n    int d1\\n  ) internal pure returns (uint) {\\n    return _sqrtPrecise(tAnnualised).multiplyDecimalRoundPrecise(_stdNormal(d1).multiplyDecimalRoundPrecise(spot));\\n  }\\n\\n  /**\\n   * @dev Returns the option's vega value with expiry modified to be at least VEGA_STANDARDISATION_MIN_DAYS\\n   * @param d1 Internal coefficient of Black-Scholes\\n   * @param spot The current price of the base asset\\n   * @param timeToExpirySec Number of seconds to expiry\\n   */\\n  function _standardVega(\\n    int d1,\\n    uint spot,\\n    uint timeToExpirySec\\n  ) internal pure returns (uint, uint) {\\n    uint tAnnualised = _annualise(timeToExpirySec);\\n    uint normalisationFactor = _getVegaNormalisationFactorPrecise(timeToExpirySec);\\n    uint vegaPrecise = _vega(tAnnualised, spot, d1);\\n    return (vegaPrecise, vegaPrecise.multiplyDecimalRoundPrecise(normalisationFactor));\\n  }\\n\\n  function _getVegaNormalisationFactorPrecise(uint timeToExpirySec) internal pure returns (uint) {\\n    timeToExpirySec = timeToExpirySec < VEGA_STANDARDISATION_MIN_DAYS ? VEGA_STANDARDISATION_MIN_DAYS : timeToExpirySec;\\n    uint daysToExpiry = timeToExpirySec / 1 days;\\n    uint thirty = 30 * PRECISE_UNIT;\\n    return _sqrtPrecise(thirty / daysToExpiry) / 100;\\n  }\\n\\n  /////////////////////\\n  // Math Operations //\\n  /////////////////////\\n\\n  /**\\n   * @dev Compute the absolute value of `val`.\\n   *\\n   * @param val The number to absolute value.\\n   */\\n  function _abs(int val) internal pure returns (uint) {\\n    return uint(val < 0 ? -val : val);\\n  }\\n\\n  /// @notice Calculates the square root of x, rounding down (borrowed from https://github.com/paulrberg/prb-math)\\n  /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\\n  /// @param x The uint256 number for which to calculate the square root.\\n  /// @return result The result as an uint256.\\n  function _sqrt(uint x) internal pure returns (uint result) {\\n    if (x == 0) {\\n      return 0;\\n    }\\n\\n    // Calculate the square root of the perfect square of a power of two that is the closest to x.\\n    uint xAux = uint(x);\\n    result = 1;\\n    if (xAux >= 0x100000000000000000000000000000000) {\\n      xAux >>= 128;\\n      result <<= 64;\\n    }\\n    if (xAux >= 0x10000000000000000) {\\n      xAux >>= 64;\\n      result <<= 32;\\n    }\\n    if (xAux >= 0x100000000) {\\n      xAux >>= 32;\\n      result <<= 16;\\n    }\\n    if (xAux >= 0x10000) {\\n      xAux >>= 16;\\n      result <<= 8;\\n    }\\n    if (xAux >= 0x100) {\\n      xAux >>= 8;\\n      result <<= 4;\\n    }\\n    if (xAux >= 0x10) {\\n      xAux >>= 4;\\n      result <<= 2;\\n    }\\n    if (xAux >= 0x8) {\\n      result <<= 1;\\n    }\\n\\n    // The operations can never overflow because the result is max 2^127 when it enters this block.\\n    unchecked {\\n      result = (result + x / result) >> 1;\\n      result = (result + x / result) >> 1;\\n      result = (result + x / result) >> 1;\\n      result = (result + x / result) >> 1;\\n      result = (result + x / result) >> 1;\\n      result = (result + x / result) >> 1;\\n      result = (result + x / result) >> 1; // Seven iterations should be enough\\n      uint roundedDownResult = x / result;\\n      return result >= roundedDownResult ? roundedDownResult : result;\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the square root of the value using Newton's method.\\n   */\\n  function _sqrtPrecise(uint x) internal pure returns (uint) {\\n    // Add in an extra unit factor for the square root to gobble;\\n    // otherwise, sqrt(x * UNIT) = sqrt(x) * sqrt(UNIT)\\n    return _sqrt(x * PRECISE_UNIT);\\n  }\\n\\n  /**\\n   * @dev The standard normal distribution of the value.\\n   */\\n  function _stdNormal(int x) internal pure returns (uint) {\\n    return\\n      FixedPointMathLib.expPrecise(int(-x.multiplyDecimalRoundPrecise(x / 2))).divideDecimalRoundPrecise(SQRT_TWOPI);\\n  }\\n\\n  /**\\n   * @dev The standard normal cumulative distribution of the value.\\n   * borrowed from a C++ implementation https://stackoverflow.com/a/23119456\\n   */\\n  function _stdNormalCDF(int x) public pure returns (uint) {\\n    uint z = _abs(x);\\n    int c;\\n\\n    if (z <= 37 * PRECISE_UNIT) {\\n      uint e = FixedPointMathLib.expPrecise(-int(z.multiplyDecimalRoundPrecise(z / 2)));\\n      if (z < SPLIT) {\\n        c = int(\\n          (_stdNormalCDFNumerator(z).divideDecimalRoundPrecise(_stdNormalCDFDenom(z)).multiplyDecimalRoundPrecise(e))\\n        );\\n      } else {\\n        uint f = (z +\\n          PRECISE_UNIT.divideDecimalRoundPrecise(\\n            z +\\n              (2 * PRECISE_UNIT).divideDecimalRoundPrecise(\\n                z +\\n                  (3 * PRECISE_UNIT).divideDecimalRoundPrecise(\\n                    z + (4 * PRECISE_UNIT).divideDecimalRoundPrecise(z + ((PRECISE_UNIT * 13) / 20))\\n                  )\\n              )\\n          ));\\n        c = int(e.divideDecimalRoundPrecise(f.multiplyDecimalRoundPrecise(SQRT_TWOPI)));\\n      }\\n    }\\n    return uint((x <= 0 ? c : (int(PRECISE_UNIT) - c)));\\n  }\\n\\n  /**\\n   * @dev Helper for _stdNormalCDF\\n   */\\n  function _stdNormalCDFNumerator(uint z) internal pure returns (uint) {\\n    uint numeratorInner = ((((((N6 * z) / PRECISE_UNIT + N5) * z) / PRECISE_UNIT + N4) * z) / PRECISE_UNIT + N3);\\n    return (((((numeratorInner * z) / PRECISE_UNIT + N2) * z) / PRECISE_UNIT + N1) * z) / PRECISE_UNIT + N0;\\n  }\\n\\n  /**\\n   * @dev Helper for _stdNormalCDF\\n   */\\n  function _stdNormalCDFDenom(uint z) internal pure returns (uint) {\\n    uint denominatorInner = ((((((M7 * z) / PRECISE_UNIT + M6) * z) / PRECISE_UNIT + M5) * z) / PRECISE_UNIT + M4);\\n    return\\n      (((((((denominatorInner * z) / PRECISE_UNIT + M3) * z) / PRECISE_UNIT + M2) * z) / PRECISE_UNIT + M1) * z) /\\n      PRECISE_UNIT +\\n      M0;\\n  }\\n\\n  /**\\n   * @dev Converts an integer number of seconds to a fractional number of years.\\n   */\\n  function _annualise(uint secs) internal pure returns (uint yearFraction) {\\n    return secs.divideDecimalRoundPrecise(SECONDS_PER_YEAR);\\n  }\\n}\\n\",\"keccak256\":\"0x9ae7c895353ca808cc6b9833b9ff6a9600f11086de655e4524fe26957a053db0\",\"license\":\"ISC\"},\"@lyrafinance/protocol/contracts/libraries/FixedPointMathLib.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.9;\\n\\nlibrary FixedPointMathLib {\\n  /// @dev Computes ln(x) for a 1e27 fixed point. Loses 9 last significant digits of precision.\\n  function lnPrecise(int x) internal pure returns (int r) {\\n    return ln(x / 1e9) * 1e9;\\n  }\\n\\n  /// @dev Computes e ^ x for a 1e27 fixed point. Loses 9 last significant digits of precision.\\n  function expPrecise(int x) internal pure returns (uint r) {\\n    return exp(x / 1e9) * 1e9;\\n  }\\n\\n  // Computes ln(x) in 1e18 fixed point.\\n  // Reverts if x is negative or zero.\\n  // Consumes 670 gas.\\n  function ln(int x) internal pure returns (int r) {\\n    unchecked {\\n      if (x < 1) {\\n        if (x < 0) revert LnNegativeUndefined();\\n        revert Overflow();\\n      }\\n\\n      // We want to convert x from 10**18 fixed point to 2**96 fixed point.\\n      // We do this by multiplying by 2**96 / 10**18.\\n      // But since ln(x * C) = ln(x) + ln(C), we can simply do nothing here\\n      // and add ln(2**96 / 10**18) at the end.\\n\\n      // Reduce range of x to (1, 2) * 2**96\\n      // ln(2^k * x) = k * ln(2) + ln(x)\\n      // Note: inlining ilog2 saves 8 gas.\\n      int k = int(ilog2(uint(x))) - 96;\\n      x <<= uint(159 - k);\\n      x = int(uint(x) >> 159);\\n\\n      // Evaluate using a (8, 8)-term rational approximation\\n      // p is made monic, we will multiply by a scale factor later\\n      int p = x + 3273285459638523848632254066296;\\n      p = ((p * x) >> 96) + 24828157081833163892658089445524;\\n      p = ((p * x) >> 96) + 43456485725739037958740375743393;\\n      p = ((p * x) >> 96) - 11111509109440967052023855526967;\\n      p = ((p * x) >> 96) - 45023709667254063763336534515857;\\n      p = ((p * x) >> 96) - 14706773417378608786704636184526;\\n      p = p * x - (795164235651350426258249787498 << 96);\\n      //emit log_named_int(\\\"p\\\", p);\\n      // We leave p in 2**192 basis so we don't need to scale it back up for the division.\\n      // q is monic by convention\\n      int q = x + 5573035233440673466300451813936;\\n      q = ((q * x) >> 96) + 71694874799317883764090561454958;\\n      q = ((q * x) >> 96) + 283447036172924575727196451306956;\\n      q = ((q * x) >> 96) + 401686690394027663651624208769553;\\n      q = ((q * x) >> 96) + 204048457590392012362485061816622;\\n      q = ((q * x) >> 96) + 31853899698501571402653359427138;\\n      q = ((q * x) >> 96) + 909429971244387300277376558375;\\n      assembly {\\n        // Div in assembly because solidity adds a zero check despite the `unchecked`.\\n        // The q polynomial is known not to have zeros in the domain. (All roots are complex)\\n        // No scaling required because p is already 2**96 too large.\\n        r := sdiv(p, q)\\n      }\\n      // r is in the range (0, 0.125) * 2**96\\n\\n      // Finalization, we need to\\n      // * multiply by the scale factor s = 5.549\\u2026\\n      // * add ln(2**96 / 10**18)\\n      // * add k * ln(2)\\n      // * multiply by 10**18 / 2**96 = 5**18 >> 78\\n      // mul s * 5e18 * 2**96, base is now 5**18 * 2**192\\n      r *= 1677202110996718588342820967067443963516166;\\n      // add ln(2) * k * 5e18 * 2**192\\n      r += 16597577552685614221487285958193947469193820559219878177908093499208371 * k;\\n      // add ln(2**96 / 10**18) * 5e18 * 2**192\\n      r += 600920179829731861736702779321621459595472258049074101567377883020018308;\\n      // base conversion: mul 2**18 / 2**192\\n      r >>= 174;\\n    }\\n  }\\n\\n  // Integer log2\\n  // @returns floor(log2(x)) if x is nonzero, otherwise 0. This is the same\\n  //          as the location of the highest set bit.\\n  // Consumes 232 gas. This could have been an 3 gas EVM opcode though.\\n  function ilog2(uint x) internal pure returns (uint r) {\\n    assembly {\\n      r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\\n      r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\\n      r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n      r := or(r, shl(4, lt(0xffff, shr(r, x))))\\n      r := or(r, shl(3, lt(0xff, shr(r, x))))\\n      r := or(r, shl(2, lt(0xf, shr(r, x))))\\n      r := or(r, shl(1, lt(0x3, shr(r, x))))\\n      r := or(r, lt(0x1, shr(r, x)))\\n    }\\n  }\\n\\n  // Computes e^x in 1e18 fixed point.\\n  function exp(int x) internal pure returns (uint r) {\\n    unchecked {\\n      // Input x is in fixed point format, with scale factor 1/1e18.\\n\\n      // When the result is < 0.5 we return zero. This happens when\\n      // x <= floor(log(0.5e18) * 1e18) ~ -42e18\\n      if (x <= -42139678854452767551) {\\n        return 0;\\n      }\\n\\n      // When the result is > (2**255 - 1) / 1e18 we can not represent it\\n      // as an int256. This happens when x >= floor(log((2**255 -1) / 1e18) * 1e18) ~ 135.\\n      if (x >= 135305999368893231589) revert ExpOverflow();\\n\\n      // x is now in the range (-42, 136) * 1e18. Convert to (-42, 136) * 2**96\\n      // for more intermediate precision and a binary basis. This base conversion\\n      // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\\n      x = (x << 78) / 5**18;\\n\\n      // Reduce range of x to (-\\u00bd ln 2, \\u00bd ln 2) * 2**96 by factoring out powers of two\\n      // such that exp(x) = exp(x') * 2**k, where k is an integer.\\n      // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\\n      int k = ((x << 96) / 54916777467707473351141471128 + 2**95) >> 96;\\n      x = x - k * 54916777467707473351141471128;\\n      // k is in the range [-61, 195].\\n\\n      // Evaluate using a (6, 7)-term rational approximation\\n      // p is made monic, we will multiply by a scale factor later\\n      int p = x + 2772001395605857295435445496992;\\n      p = ((p * x) >> 96) + 44335888930127919016834873520032;\\n      p = ((p * x) >> 96) + 398888492587501845352592340339721;\\n      p = ((p * x) >> 96) + 1993839819670624470859228494792842;\\n      p = p * x + (4385272521454847904632057985693276 << 96);\\n      // We leave p in 2**192 basis so we don't need to scale it back up for the division.\\n      // Evaluate using using Knuth's scheme from p. 491.\\n      int z = x + 750530180792738023273180420736;\\n      z = ((z * x) >> 96) + 32788456221302202726307501949080;\\n      int w = x - 2218138959503481824038194425854;\\n      w = ((w * z) >> 96) + 892943633302991980437332862907700;\\n      int q = z + w - 78174809823045304726920794422040;\\n      q = ((q * w) >> 96) + 4203224763890128580604056984195872;\\n      assembly {\\n        // Div in assembly because solidity adds a zero check despite the `unchecked`.\\n        // The q polynomial is known not to have zeros in the domain. (All roots are complex)\\n        // No scaling required because p is already 2**96 too large.\\n        r := sdiv(p, q)\\n      }\\n      // r should be in the range (0.09, 0.25) * 2**96.\\n\\n      // We now need to multiply r by\\n      //  * the scale factor s = ~6.031367120...,\\n      //  * the 2**k factor from the range reduction, and\\n      //  * the 1e18 / 2**96 factor for base converison.\\n      // We do all of this at once, with an intermediate result in 2**213 basis\\n      // so the final right shift is always by a positive amount.\\n      r = (uint(r) * 3822833074963236453042738258902158003155416615667) >> uint(195 - k);\\n    }\\n  }\\n\\n  error Overflow();\\n  error ExpOverflow();\\n  error LnNegativeUndefined();\\n}\\n\",\"keccak256\":\"0xac40b21d21c7d073eb65194d1d9b735a206386814d41af5481f657315cffe1df\",\"license\":\"UNLICENSED\"},\"@lyrafinance/protocol/contracts/libraries/GWAV.sol\":{\"content\":\"// SPDX-License-Identifier: ISC\\npragma solidity 0.8.9;\\n\\nimport \\\"../synthetix/SignedDecimalMath.sol\\\";\\nimport \\\"../synthetix/DecimalMath.sol\\\";\\nimport \\\"./FixedPointMathLib.sol\\\";\\n\\n/**\\n * @title Geometric Moving Average Oracle\\n * @author Lyra\\n * @dev Instances of stored oracle data, \\\"observations\\\", are collected in the oracle array\\n *\\n * The GWAV values are calculated from the blockTimestamps and \\\"q\\\" accumulator values of two Observations. When\\n * requested the closest observations are scaled to the requested timestamp.\\n */\\nlibrary GWAV {\\n  using DecimalMath for uint;\\n  using SignedDecimalMath for int;\\n\\n  /// @dev Stores all past Observations and the current index\\n  struct Params {\\n    Observation[] observations;\\n    uint index;\\n  }\\n\\n  /// @dev An observation holds the cumulative log value of all historic observations (accumulator)\\n  /// and other relevant fields for computing the next accumulator value.\\n  /// @dev A pair of oracle Observations is used to deduce the GWAV TWAP\\n  struct Observation {\\n    int q; // accumulator value used to compute GWAV\\n    uint nextVal; // value at the time the observation was made, used to calculate the next q value\\n    uint blockTimestamp;\\n  }\\n\\n  /////////////\\n  // Setters //\\n  /////////////\\n\\n  /**\\n   * @notice Initialize the oracle array by writing the first Observation.\\n   * @dev Called once for the lifecycle of the observations array\\n   * @dev First Observation uses blockTimestamp as the time interval to prevent manipulation of the GWAV immediately\\n   * after initialization\\n   * @param self Stores past Observations and the index of the latest Observation\\n   * @param newVal First observed value for blockTimestamp\\n   * @param blockTimestamp Timestamp of first Observation\\n   */\\n  function _initialize(\\n    Params storage self,\\n    uint newVal,\\n    uint blockTimestamp\\n  ) internal {\\n    // if Observation older than blockTimestamp is used for GWAV,\\n    // _getFirstBefore() will scale the first Observation \\\"q\\\" accordingly\\n    _initializeWithManualQ(self, FixedPointMathLib.ln((int(newVal))) * int(blockTimestamp), newVal, blockTimestamp);\\n  }\\n\\n  /**\\n   * @notice Writes an oracle Observation to the GWAV array\\n   * @dev Writable at most once per block. BlockTimestamp must be > last.blockTimestamp\\n   * @param self Stores past Observations and the index of the latest Observation\\n   * @param nextVal Value at given blockTimestamp\\n   * @param blockTimestamp Current blockTimestamp\\n   */\\n  function _write(\\n    Params storage self,\\n    uint nextVal,\\n    uint blockTimestamp\\n  ) internal {\\n    Observation memory last = self.observations[self.index];\\n\\n    // Ensure entries are sequential\\n    if (blockTimestamp < last.blockTimestamp) {\\n      revert InvalidBlockTimestamp(address(this), blockTimestamp, last.blockTimestamp);\\n    }\\n\\n    // early return if we've already written an observation this block\\n    if (last.blockTimestamp == blockTimestamp) {\\n      self.observations[self.index].nextVal = nextVal;\\n      return;\\n    }\\n    // No reason to record an entry if it's the same as the last one\\n    if (last.nextVal == nextVal) return;\\n\\n    // update accumulator value\\n    // assumes the market value between the previous and current blockTimstamps was \\\"last.nextVal\\\"\\n    uint timestampDelta = blockTimestamp - last.blockTimestamp;\\n    int newQ = last.q + FixedPointMathLib.ln((int(last.nextVal))) * int(timestampDelta);\\n\\n    // update latest index and store Observation\\n    uint indexUpdated = (self.index + 1);\\n    self.observations.push(_transform(newQ, nextVal, blockTimestamp));\\n    self.index = indexUpdated;\\n  }\\n\\n  /////////////\\n  // Getters //\\n  /////////////\\n\\n  /**\\n   * @notice Calculates the geometric moving average between two Observations A & B. These observations are scaled to\\n   * the requested timestamps\\n   * @dev For the current GWAV value, \\\"0\\\" may be passed in for secondsAgo\\n   * @dev If timestamps A==B, returns the value at A/B.\\n   * @param self Stores past Observations and the index of the latest Observation\\n   * @param secondsAgoA Seconds from blockTimestamp to Observation A\\n   * @param secondsAgoB Seconds from blockTimestamp to Observation B\\n   */\\n  function getGWAVForPeriod(\\n    Params storage self,\\n    uint secondsAgoA,\\n    uint secondsAgoB\\n  ) public view returns (uint) {\\n    (int q0, uint t0) = queryFirstBeforeAndScale(self, block.timestamp, secondsAgoA);\\n    (int q1, uint t1) = queryFirstBeforeAndScale(self, block.timestamp, secondsAgoB);\\n\\n    if (t0 == t1) {\\n      return uint(FixedPointMathLib.exp(q1 / int(t1)));\\n    }\\n\\n    return uint(FixedPointMathLib.exp((q1 - q0) / int(t1 - t0)));\\n  }\\n\\n  /**\\n   * @notice Returns the GWAV accumulator/timestamps values for each \\\"secondsAgo\\\" in the array `secondsAgos[]`\\n   * @param currentBlockTimestamp Timestamp of current block\\n   * @param secondsAgos Array of all timestamps for which to export accumulator/timestamp values\\n   */\\n  function observe(\\n    Params storage self,\\n    uint currentBlockTimestamp,\\n    uint[] memory secondsAgos\\n  ) public view returns (int[] memory qCumulatives, uint[] memory timestamps) {\\n    qCumulatives = new int[](secondsAgos.length);\\n    timestamps = new uint[](secondsAgos.length);\\n    for (uint i = 0; i < secondsAgos.length; i++) {\\n      (qCumulatives[i], timestamps[i]) = queryFirstBefore(self, currentBlockTimestamp, secondsAgos[i]);\\n    }\\n  }\\n\\n  //////////////////////////////////////////////////////\\n  // Querying observation closest to target timestamp //\\n  //////////////////////////////////////////////////////\\n\\n  /**\\n   * @notice Finds the first observation before a timestamp \\\"secondsAgo\\\" from the \\\"currentBlockTimestamp\\\"\\n   * @dev If target falls between two Observations, the older one is returned\\n   * @dev See _queryFirstBefore() for edge cases where target lands\\n   * after the newest Observation or before the oldest Observation\\n   * @dev Reverts if secondsAgo exceeds the currentBlockTimestamp\\n   * @param self Stores past Observations and the index of the latest Observation\\n   * @param currentBlockTimestamp Timestamp of current block\\n   * @param secondsAgo Seconds from currentBlockTimestamp to target Observation\\n   */\\n  function queryFirstBefore(\\n    Params storage self,\\n    uint currentBlockTimestamp,\\n    uint secondsAgo\\n  ) internal view returns (int qCumulative, uint timestamp) {\\n    uint target = currentBlockTimestamp - secondsAgo;\\n    Observation memory beforeOrAt = _queryFirstBefore(self, target);\\n\\n    return (beforeOrAt.q, beforeOrAt.blockTimestamp);\\n  }\\n\\n  function queryFirstBeforeAndScale(\\n    Params storage self,\\n    uint currentBlockTimestamp,\\n    uint secondsAgo\\n  ) internal view returns (int qCumulative, uint timestamp) {\\n    uint target = currentBlockTimestamp - secondsAgo;\\n    Observation memory beforeOrAt = _queryFirstBefore(self, target);\\n\\n    int timestampDelta = int(target - beforeOrAt.blockTimestamp);\\n\\n    return (beforeOrAt.q + (FixedPointMathLib.ln(int(beforeOrAt.nextVal)) * timestampDelta), target);\\n  }\\n\\n  /**\\n   * @notice Finds the first observation before the \\\"target\\\" timestamp\\n   * @dev Checks for trivial scenarios before entering _binarySearch()\\n   * @dev Assumes _initialize() has been called\\n   * @param self Stores past Observations and the index of the latest Observation\\n   * @param target BlockTimestamp of target Observation\\n   */\\n  function _queryFirstBefore(Params storage self, uint target) private view returns (Observation memory beforeOrAt) {\\n    // Case 1: target blockTimestamp is at or after the most recent Observation\\n    beforeOrAt = self.observations[self.index];\\n    if (beforeOrAt.blockTimestamp <= target) {\\n      return (beforeOrAt);\\n    }\\n\\n    // Now, set to the oldest observation\\n    beforeOrAt = self.observations[0];\\n\\n    // Case 2: target blockTimestamp is older than the oldest Observation\\n    // The observation is scaled to the target using the nextVal\\n    if (beforeOrAt.blockTimestamp > target) {\\n      return _transform((beforeOrAt.q * int(target)) / int(beforeOrAt.blockTimestamp), beforeOrAt.nextVal, target);\\n    }\\n\\n    // Case 3: target is within the recorded Observations.\\n    return self.observations[_binarySearch(self, target)];\\n  }\\n\\n  /**\\n   * @notice Finds closest Observation before target using binary search and returns its index\\n   * @dev Used when the target is located within the stored observation boundaries\\n   * e.g. Older than the most recent observation and younger, or the same age as, the oldest observation\\n   * @return foundIndex Returns the Observation which is older than target (instead of newer)\\n   * @param self Stores past Observations and the index of the latest Observation\\n   * @param target BlockTimestamp of target Observation\\n   */\\n  function _binarySearch(Params storage self, uint target) internal view returns (uint) {\\n    uint oldest = 0; // oldest observation\\n    uint newest = self.index; // newest observation\\n    uint i;\\n    while (true) {\\n      i = (oldest + newest) / 2;\\n      uint beforeOrAtTimestamp = self.observations[i].blockTimestamp;\\n\\n      uint atOrAfterTimestamp = self.observations[i + 1].blockTimestamp;\\n      bool targetAtOrAfter = beforeOrAtTimestamp <= target;\\n\\n      // check if we've found the answer!\\n      if (targetAtOrAfter && target <= atOrAfterTimestamp) break;\\n\\n      if (!targetAtOrAfter) {\\n        newest = i - 1;\\n      } else {\\n        oldest = i + 1;\\n      }\\n    }\\n\\n    return i;\\n  }\\n\\n  /////////////\\n  // Utility //\\n  /////////////\\n\\n  /**\\n   * @notice Creates the first Observation with manual Q accumulator value.\\n   * @param qVal Initial GWAV accumulator value\\n   * @param nextVal First observed value for blockTimestamp\\n   * @param blockTimestamp Timestamp of Observation\\n   */\\n  function _initializeWithManualQ(\\n    Params storage self,\\n    int qVal,\\n    uint nextVal,\\n    uint blockTimestamp\\n  ) internal {\\n    self.observations.push(Observation({q: qVal, nextVal: nextVal, blockTimestamp: blockTimestamp}));\\n  }\\n\\n  /**\\n   * @dev Creates an Observation given a GWAV accumulator, latest value, and a blockTimestamp\\n   */\\n  function _transform(\\n    int newQ,\\n    uint nextVal,\\n    uint blockTimestamp\\n  ) private pure returns (Observation memory) {\\n    return Observation({q: newQ, nextVal: nextVal, blockTimestamp: blockTimestamp});\\n  }\\n\\n  ////////////\\n  // Errors //\\n  ////////////\\n  error InvalidBlockTimestamp(address thrower, uint timestamp, uint lastObservedTimestamp);\\n}\\n\",\"keccak256\":\"0xacd9b0cd63a8ea5560955a48cd83eb04d04fcd02b23ba7ed19fc711496fed527\",\"license\":\"ISC\"},\"@lyrafinance/protocol/contracts/libraries/PoolHedger.sol\":{\"content\":\"//SPDX-License-Identifier: ISC\\npragma solidity 0.8.9;\\n\\n// Interfaces\\nimport \\\"../LiquidityPool.sol\\\";\\n\\n/**\\n * @title PoolHedger\\n * @author Lyra\\n * @dev Uses the delta hedging funds from the LiquidityPool to hedge option deltas, so LPs are minimally exposed to\\n * movements in the underlying asset price.\\n */\\nabstract contract PoolHedger {\\n  struct PoolHedgerParameters {\\n    uint interactionDelay;\\n    uint hedgeCap;\\n  }\\n\\n  LiquidityPool internal liquidityPool;\\n  PoolHedgerParameters internal poolHedgerParams;\\n  uint public lastInteraction;\\n\\n  /////////////\\n  // Only LP //\\n  /////////////\\n  function resetInteractionDelay() external onlyLiquidityPool {\\n    lastInteraction = 0;\\n  }\\n\\n  /////////////\\n  // Getters //\\n  /////////////\\n\\n  /**\\n   * @dev Returns the current hedged netDelta position.\\n   */\\n  function getCurrentHedgedNetDelta() external view virtual returns (int);\\n\\n  /// @notice Returns pending delta hedge liquidity and used delta hedge liquidity\\n  /// @dev include funds that would need to be transferred to the contract to hedge optimally\\n  function getHedgingLiquidity(uint spotPrice)\\n    external\\n    view\\n    virtual\\n    returns (uint pendingDeltaLiquidity, uint usedDeltaLiquidity);\\n\\n  /**\\n   * @dev Calculates the expected delta hedge that hedger must perform and\\n   * adjusts the result down to the hedgeCap param if needed.\\n   */\\n  function getCappedExpectedHedge() public view virtual returns (int cappedExpectedHedge);\\n\\n  //////////////\\n  // External //\\n  //////////////\\n\\n  /**\\n   * @dev Retrieves the netDelta for the system and hedges appropriately.\\n   */\\n  function hedgeDelta() external virtual;\\n\\n  function updateCollateral() external virtual;\\n\\n  function getPoolHedgerParams() external view virtual returns (PoolHedgerParameters memory) {\\n    return poolHedgerParams;\\n  }\\n\\n  //////////////\\n  // Internal //\\n  //////////////\\n\\n  function _setPoolHedgerParams(PoolHedgerParameters memory _poolHedgerParams) internal {\\n    poolHedgerParams = _poolHedgerParams;\\n    emit PoolHedgerParametersSet(poolHedgerParams);\\n  }\\n\\n  ///////////////\\n  // Modifiers //\\n  ///////////////\\n\\n  modifier onlyLiquidityPool() {\\n    if (msg.sender != address(liquidityPool)) {\\n      revert OnlyLiquidityPool(address(this), msg.sender, address(liquidityPool));\\n    }\\n    _;\\n  }\\n\\n  ////////////\\n  // Events //\\n  ////////////\\n  /**\\n   * @dev Emitted when pool hedger parameters are updated.\\n   */\\n  event PoolHedgerParametersSet(PoolHedgerParameters poolHedgerParams);\\n\\n  ////////////\\n  // Errors //\\n  ////////////\\n\\n  // Access\\n  error OnlyLiquidityPool(address thrower, address caller, address liquidityPool);\\n}\\n\",\"keccak256\":\"0x19698e1c533a78d5f2261bc1bcccee08bf7c7409f57de0ca27fdcf917bb58f84\",\"license\":\"ISC\"},\"@lyrafinance/protocol/contracts/libraries/SimpleInitializeable.sol\":{\"content\":\"// SPDX-License-Identifier: ISC\\npragma solidity 0.8.9;\\n\\n/**\\n * @title SimpleInitializeable\\n * @author Lyra\\n * @dev Contract to enable a function to be marked as the initializer\\n */\\nabstract contract SimpleInitializeable {\\n  bool internal initialized = false;\\n\\n  modifier initializer() {\\n    if (initialized) {\\n      revert AlreadyInitialised(address(this));\\n    }\\n    initialized = true;\\n    _;\\n  }\\n\\n  ////////////\\n  // Errors //\\n  ////////////\\n  error AlreadyInitialised(address thrower);\\n}\\n\",\"keccak256\":\"0xb20a7b21c4faaf9fd08c0dda0a2ad5d3b1fcc058874739c904257a92e4bae18f\",\"license\":\"ISC\"},\"@lyrafinance/protocol/contracts/periphery/BasicFeeCounter.sol\":{\"content\":\"//SPDX-License-Identifier:ISC\\npragma solidity 0.8.9;\\n\\nimport \\\"../synthetix/Owned.sol\\\";\\nimport \\\"../interfaces/IFeeCounter.sol\\\";\\n\\n/**\\n * @title BasicFeeCounter\\n */\\ncontract BasicFeeCounter is IFeeCounter, Owned {\\n  mapping(address => bool) public trustedCounter;\\n  mapping(address => mapping(address => uint)) public totalFeesPerMarket;\\n\\n  constructor() Owned() {}\\n\\n  function setTrustedCounter(address counter, bool isTrusted) external onlyOwner {\\n    trustedCounter[counter] = isTrusted;\\n  }\\n\\n  function trackFee(\\n    address market,\\n    address trader,\\n    uint,\\n    uint,\\n    uint totalFee\\n  ) external onlyTrustedCounter {\\n    totalFeesPerMarket[market][trader] += totalFee;\\n  }\\n\\n  modifier onlyTrustedCounter() {\\n    require(trustedCounter[msg.sender], \\\"not trusted counter\\\");\\n    _;\\n  }\\n}\\n\",\"keccak256\":\"0x34d4f62d40ab6941693c3687c2f568d09493c7536dcdf9bbfceac78cfe72d81d\",\"license\":\"ISC\"},\"@lyrafinance/protocol/contracts/periphery/GWAVOracle.sol\":{\"content\":\"//SPDX-License-Identifier:ISC\\npragma solidity 0.8.9;\\n\\n// Libraries\\nimport \\\"../libraries/GWAV.sol\\\";\\nimport \\\"../libraries/BlackScholes.sol\\\";\\nimport \\\"../synthetix/DecimalMath.sol\\\";\\n\\n// Inherited\\nimport \\\"../synthetix/Owned.sol\\\";\\n\\n// Interfaces\\nimport \\\"../OptionMarket.sol\\\";\\nimport \\\"../OptionGreekCache.sol\\\";\\nimport \\\"../SynthetixAdapter.sol\\\";\\n\\ncontract GWAVOracle is Owned {\\n  using DecimalMath for uint;\\n\\n  ///////////////\\n  // Variables //\\n  ///////////////\\n\\n  OptionMarket internal optionMarket;\\n  OptionGreekCache internal greekCache;\\n  SynthetixAdapter internal synthetixAdapter;\\n\\n  constructor() Owned() {}\\n\\n  //////////\\n  // init //\\n  //////////\\n\\n  /**\\n   * @dev Initializes the contract\\n   * @param _optionMarket OptionMarket Address\\n   * @param _greekCache greekCache address\\n   * @param _synthetixAdapter synthetixAdapter address\\n   */\\n\\n  function init(\\n    OptionMarket _optionMarket,\\n    OptionGreekCache _greekCache,\\n    SynthetixAdapter _synthetixAdapter\\n  ) external onlyOwner {\\n    setLyraAddresses(_optionMarket, _greekCache, _synthetixAdapter);\\n  }\\n\\n  function setLyraAddresses(\\n    OptionMarket _optionMarket,\\n    OptionGreekCache _greekCache,\\n    SynthetixAdapter _synthetixAdapter\\n  ) public onlyOwner {\\n    optionMarket = _optionMarket;\\n    greekCache = _greekCache;\\n    synthetixAdapter = _synthetixAdapter;\\n  }\\n\\n  function ivGWAV(uint boardId, uint secondsAgo) public view returns (uint) {\\n    return greekCache.getIvGWAV(boardId, secondsAgo);\\n  }\\n\\n  function skewGWAV(uint strikeId, uint secondsAgo) public view returns (uint) {\\n    return greekCache.getSkewGWAV(strikeId, secondsAgo);\\n  }\\n\\n  function volGWAV(uint strikeId, uint secondsAgo) public view returns (uint) {\\n    OptionMarket.Strike memory strike = optionMarket.getStrike(strikeId);\\n\\n    return ivGWAV(strike.boardId, secondsAgo).multiplyDecimal(skewGWAV(strikeId, secondsAgo));\\n  }\\n\\n  function deltaGWAV(uint strikeId, uint secondsAgo) external view returns (int callDelta) {\\n    BlackScholes.BlackScholesInputs memory bsInput = _getBsInput(strikeId);\\n\\n    bsInput.volatilityDecimal = volGWAV(strikeId, secondsAgo);\\n    (callDelta, ) = BlackScholes.delta(bsInput);\\n  }\\n\\n  // pure vega (not normalized for expiry)\\n  function vegaGWAV(uint strikeId, uint secondsAgo) external view returns (uint vega) {\\n    BlackScholes.BlackScholesInputs memory bsInput = _getBsInput(strikeId);\\n\\n    bsInput.volatilityDecimal = volGWAV(strikeId, secondsAgo);\\n    vega = BlackScholes.vega(bsInput);\\n  }\\n\\n  function optionPriceGWAV(uint strikeId, uint secondsAgo) external view returns (uint callPrice, uint putPrice) {\\n    BlackScholes.BlackScholesInputs memory bsInput = _getBsInput(strikeId);\\n\\n    bsInput.volatilityDecimal = volGWAV(strikeId, secondsAgo);\\n    (callPrice, putPrice) = BlackScholes.optionPrices(bsInput);\\n  }\\n\\n  //////////\\n  // Misc //\\n  //////////\\n\\n  function _getBsInput(uint strikeId) internal view returns (BlackScholes.BlackScholesInputs memory bsInput) {\\n    (OptionMarket.Strike memory strike, OptionMarket.OptionBoard memory board) = optionMarket.getStrikeAndBoard(\\n      strikeId\\n    );\\n\\n    bsInput = BlackScholes.BlackScholesInputs({\\n      timeToExpirySec: board.expiry - block.timestamp,\\n      volatilityDecimal: board.iv.multiplyDecimal(strike.skew),\\n      spotDecimal: synthetixAdapter.getSpotPriceForMarket(address(optionMarket)),\\n      strikePriceDecimal: strike.strikePrice,\\n      rateDecimal: greekCache.getGreekCacheParams().rateAndCarry\\n    });\\n  }\\n}\\n\",\"keccak256\":\"0x6afe3208bf5371752f202351450a16a5ca8f4d43fd92f758386ecae1ce52e1ec\",\"license\":\"ISC\"},\"@lyrafinance/protocol/contracts/periphery/LyraAdapter.sol\":{\"content\":\"//SPDX-License-Identifier:ISC\\npragma solidity 0.8.9;\\n\\n// Libraries\\nimport \\\"../libraries/GWAV.sol\\\";\\nimport \\\"../libraries/BlackScholes.sol\\\";\\nimport \\\"../synthetix/DecimalMath.sol\\\";\\n\\n// Inherited\\nimport \\\"openzeppelin-contracts-4.4.1/access/Ownable.sol\\\";\\nimport \\\"openzeppelin-contracts-4.4.1/token/ERC20/IERC20.sol\\\";\\n\\n// Interfaces\\nimport \\\"../OptionToken.sol\\\";\\nimport \\\"../OptionMarket.sol\\\";\\nimport \\\"../LiquidityPool.sol\\\";\\nimport \\\"../ShortCollateral.sol\\\";\\nimport \\\"../OptionGreekCache.sol\\\";\\nimport \\\"../SynthetixAdapter.sol\\\";\\nimport \\\"../interfaces/ICurve.sol\\\";\\nimport \\\"./GWAVOracle.sol\\\";\\nimport \\\"./BasicFeeCounter.sol\\\";\\nimport \\\"./LyraRegistry.sol\\\";\\n\\n/**\\n * @title LyraAdapter\\n * @author Lyra\\n * @dev Provides helpful functions for any Lyra trading/market data/vault related actions in one contract\\n *      To earn trading rewards, integrators must request to be whitelisted by Lyra\\n */\\n\\ncontract LyraAdapter is Ownable {\\n  using DecimalMath for uint;\\n\\n  ///////////////////////\\n  // Abstract Contract //\\n  ///////////////////////\\n\\n  struct Strike {\\n    // strike listing identifier\\n    uint id;\\n    // expiry of strike\\n    uint expiry;\\n    // strike price\\n    uint strikePrice;\\n    // volatility component specific to the strike listing (boardIv * skew = vol of strike)\\n    uint skew;\\n    // volatility component specific to the board (boardIv * skew = vol of strike)\\n    uint boardIv;\\n  }\\n\\n  struct Board {\\n    // board identifier\\n    uint id;\\n    // expiry of all strikes belong to\\n    uint expiry;\\n    // volatility component specific to the board (boardIv * skew = vol of strike)\\n    uint boardIv;\\n    // all strikes belonging to board\\n    uint[] strikeIds;\\n  }\\n\\n  struct OptionPosition {\\n    // OptionToken ERC721 identifier for position\\n    uint positionId;\\n    // strike identifier\\n    uint strikeId;\\n    // LONG_CALL | LONG_PUT | SHORT_CALL_BASE | SHORT_CALL_QUOTE | SHORT_PUT_QUOTE\\n    OptionType optionType;\\n    // number of options contract owned by position\\n    uint amount;\\n    // collateral held in position (only applies to shorts)\\n    uint collateral;\\n    // EMPTY | ACTIVE | CLOSED | LIQUIDATED | SETTLED | MERGED\\n    PositionState state;\\n  }\\n\\n  enum OptionType {\\n    LONG_CALL,\\n    LONG_PUT,\\n    SHORT_CALL_BASE,\\n    SHORT_CALL_QUOTE,\\n    SHORT_PUT_QUOTE\\n  }\\n\\n  enum PositionState {\\n    EMPTY,\\n    ACTIVE,\\n    CLOSED,\\n    LIQUIDATED,\\n    SETTLED,\\n    MERGED\\n  }\\n\\n  struct TradeInputParameters {\\n    // id of strike\\n    uint strikeId;\\n    // OptionToken ERC721 id for position (set to 0 for new positions)\\n    uint positionId;\\n    // number of sub-orders to break order into (reduces slippage)\\n    uint iterations;\\n    // type of option to trade\\n    OptionType optionType;\\n    // number of contracts to trade\\n    uint amount;\\n    // final amount of collateral to leave in OptionToken position\\n    uint setCollateralTo;\\n    // revert trade if totalCost is below this value\\n    uint minTotalCost;\\n    // revert trade if totalCost is above this value\\n    uint maxTotalCost;\\n    // address of recipient for Lyra trading rewards (must request Lyra to be whitelisted for rewards)\\n    address rewardRecipient;\\n  }\\n\\n  struct TradeResult {\\n    // OptionToken ERC721 id for position\\n    uint positionId;\\n    // total option cost paid/received during trade including premium and totalFee\\n    uint totalCost;\\n    // trading fees as determined in OptionMarketPricer.sol\\n    uint totalFee;\\n  }\\n\\n  struct Liquidity {\\n    // Amount of liquidity available for option collateral and premiums\\n    uint freeLiquidity;\\n    // Amount of liquidity available for withdrawals - different to freeLiquidity\\n    uint burnableLiquidity;\\n    // Amount of liquidity reserved for long options sold to traders\\n    uint usedCollatLiquidity;\\n    // Portion of liquidity reserved for delta hedging (quote outstanding)\\n    uint pendingDeltaLiquidity;\\n    // Current value of delta hedge\\n    uint usedDeltaLiquidity;\\n    // Net asset value, including everything and netOptionValue\\n    uint NAV;\\n  }\\n\\n  struct MarketParams {\\n    // The amount of options traded to move baseIv for the board up or down 1 point (depending on trade direction)\\n    uint standardSize;\\n    // Determines relative move of skew for a given strike compared to shift in baseIv\\n    uint skewAdjustmentParam;\\n    // Interest/risk free rate used in BlackScholes\\n    int rateAndCarry;\\n    // Delta cutoff past which options can be traded (optionD > minD && optionD < 1 - minD) - can use forceClose to bypass\\n    int deltaCutOff;\\n    // Time when trading closes - can use forceClose to bypass\\n    uint tradingCutoff;\\n    // Delta cutoff at which forceClose can be called (optionD < minD || optionD > 1 - minD) - using call delta\\n    int minForceCloseDelta;\\n  }\\n\\n  struct ExchangeRateParams {\\n    // current snx oracle base price\\n    uint spotPrice;\\n    // snx spot exchange rate from quote to base\\n    uint quoteBaseFeeRate;\\n    // snx spot exchange rate from base to quote\\n    uint baseQuoteFeeRate;\\n  }\\n\\n  ///////////////\\n  // Variables //\\n  ///////////////\\n\\n  LyraRegistry public lyraRegistry;\\n  SynthetixAdapter internal synthetixAdapter;\\n  OptionMarket public optionMarket;\\n  OptionToken public optionToken;\\n  LiquidityPool public liquidityPool;\\n  ShortCollateral public shortCollateral;\\n  GWAVOracle public gwavOracle;\\n  OptionMarketPricer public optionPricer;\\n  OptionGreekCache public greekCache;\\n  IERC20 public quoteAsset;\\n  IERC20 public baseAsset;\\n\\n  ICurve public curveSwap;\\n  BasicFeeCounter public feeCounter;\\n  bytes32 private constant SNX_ADAPTER = \\\"SYNTHETIX_ADAPTER\\\";\\n\\n  ///////////\\n  // Admin //\\n  ///////////\\n\\n  constructor() Ownable() {}\\n\\n  /**\\n   * @dev Assigns all lyra contracts\\n\\n   * @param _lyraRegistry LyraRegistry address which holds latest market and global addressess\\n   * @param _optionMarket OptionMarket address\\n   * @param _curveSwap Curve pool address for swapping sUSD and other stables via `exchange_with_best_rate`\\n   * @param _feeCounter Fee counter addressu used to determine Lyra trading rewards\\n   */\\n\\n  function setLyraAddresses(\\n    address _lyraRegistry,\\n    address _optionMarket,\\n    address _curveSwap,\\n    address _feeCounter\\n  ) public onlyOwner {\\n    // remove allowance from old assets\\n    if (address(quoteAsset) != address(0)) {\\n      quoteAsset.approve(address(optionMarket), 0);\\n    }\\n    if (address(baseAsset) != address(0)) {\\n      baseAsset.approve(address(optionMarket), 0);\\n    }\\n\\n    optionMarket = OptionMarket(_optionMarket);\\n\\n    // Get market & global addresses via LyraRegistry\\n    lyraRegistry = LyraRegistry(_lyraRegistry);\\n    synthetixAdapter = SynthetixAdapter(lyraRegistry.getGlobalAddress(SNX_ADAPTER));\\n    _assignLyraRegistryMarketAddresses();\\n\\n    // assign curve and Lyra reward counter\\n    curveSwap = ICurve(_curveSwap);\\n    feeCounter = BasicFeeCounter(_feeCounter);\\n\\n    // Do approvals\\n    synthetixAdapter.delegateApprovals().approveExchangeOnBehalf(address(synthetixAdapter));\\n    quoteAsset.approve(address(optionMarket), type(uint).max);\\n    baseAsset.approve(address(optionMarket), type(uint).max);\\n  }\\n\\n  /// @notice In case of an update to the synthetix contract that revokes the approval\\n  function updateDelegateApproval() external onlyOwner {\\n    synthetixAdapter.delegateApprovals().approveExchangeOnBehalf(address(synthetixAdapter));\\n  }\\n\\n  ////////////////////\\n  // Market Actions //\\n  ////////////////////\\n\\n  /**\\n   * @notice Attempts to open positions within cost bounds.\\n   * @dev If a positionId is specified params.amount will be added to the position\\n   * @dev params.amount can be zero when adjusting an existing position\\n   *\\n   * @param params The parameters for the requested trade\\n   */\\n  function _openPosition(TradeInputParameters memory params) internal returns (TradeResult memory tradeResult) {\\n    OptionMarket.Result memory result = optionMarket.openPosition(_convertParams(params));\\n    if (params.rewardRecipient != address(0)) {\\n      feeCounter.trackFee(\\n        address(optionMarket),\\n        params.rewardRecipient,\\n        _convertParams(params).amount,\\n        result.totalCost,\\n        result.totalFee\\n      );\\n    }\\n    return TradeResult({positionId: result.positionId, totalCost: result.totalCost, totalFee: result.totalFee});\\n  }\\n\\n  /**\\n   * @notice Attempt close under normal condition or forceClose\\n   *          if position is outside of delta or too close to expiry.\\n   *\\n   * @param params The parameters for the requested trade\\n   */\\n  function _closeOrForceClosePosition(TradeInputParameters memory params)\\n    internal\\n    returns (TradeResult memory tradeResult)\\n  {\\n    if (!_isOutsideDeltaCutoff(params.strikeId) && !_isWithinTradingCutoff(params.strikeId)) {\\n      return _closePosition(params);\\n    } else {\\n      // will pay less competitive price to close position but bypasses Lyra delta/trading cutoffs\\n      return _forceClosePosition(params);\\n    }\\n  }\\n\\n  /**\\n   * @notice Attempts to close an existing position within cost bounds.\\n   * @dev If a positionId is specified params.amount will be subtracted from the position\\n   * @dev params.amount can be zero when adjusting an existing position\\n   *\\n   * @param params The parameters for the requested trade\\n   */\\n  function _closePosition(TradeInputParameters memory params) internal returns (TradeResult memory tradeResult) {\\n    OptionMarket.Result memory result = optionMarket.closePosition(_convertParams(params));\\n    if (params.rewardRecipient != address(0)) {\\n      feeCounter.trackFee(\\n        address(optionMarket),\\n        params.rewardRecipient,\\n        _convertParams(params).amount,\\n        result.totalCost,\\n        result.totalFee\\n      );\\n    }\\n    return TradeResult({positionId: result.positionId, totalCost: result.totalCost, totalFee: result.totalFee});\\n  }\\n\\n  /**\\n   * @notice Attempts to close an existing position outside of the delta or trading cutoffs (as specified in MarketParams).\\n   * @dev This market action will charge higher fees than the standard `closePosition()`\\n   *\\n   * @param params The parameters for the requested trade\\n   */\\n  function _forceClosePosition(TradeInputParameters memory params) internal returns (TradeResult memory tradeResult) {\\n    OptionMarket.Result memory result = optionMarket.forceClosePosition(_convertParams(params));\\n    if (params.rewardRecipient != address(0)) {\\n      feeCounter.trackFee(\\n        address(optionMarket),\\n        params.rewardRecipient,\\n        _convertParams(params).amount,\\n        result.totalCost,\\n        result.totalFee\\n      );\\n    }\\n    return TradeResult({positionId: result.positionId, totalCost: result.totalCost, totalFee: result.totalFee});\\n  }\\n\\n  //////////////\\n  // Exchange //\\n  //////////////\\n\\n  /// @notice Exchange an exact amount of quote for a minimum amount of base (revert otherwise)\\n  function _exchangeFromExactQuote(uint amountQuote, uint minBaseReceived) internal returns (uint baseReceived) {\\n    baseReceived = synthetixAdapter.exchangeFromExactQuote(address(optionMarket), amountQuote);\\n    if (baseReceived < minBaseReceived) {\\n      revert ExchangerBaseReceivedTooLow(address(this), minBaseReceived, baseReceived);\\n    }\\n  }\\n\\n  /// @notice Exchange to an exact amount of quote for a maximum amount of base (revert otherwise)\\n  function _exchangeToExactQuote(uint amountQuote, uint maxBaseUsed) internal returns (uint quoteReceived) {\\n    SynthetixAdapter.ExchangeParams memory exchangeParams = synthetixAdapter.getExchangeParams(address(optionMarket));\\n    (, quoteReceived) = synthetixAdapter.exchangeToExactQuoteWithLimit(\\n      exchangeParams,\\n      address(optionMarket),\\n      amountQuote,\\n      maxBaseUsed\\n    );\\n  }\\n\\n  /// @notice Exchange an exact amount of base for a minimum amount of quote (revert otherwise)\\n  function _exchangeFromExactBase(uint amountBase, uint minQuoteReceived) internal returns (uint quoteReceived) {\\n    quoteReceived = synthetixAdapter.exchangeFromExactBase(address(optionMarket), amountBase);\\n    if (quoteReceived < minQuoteReceived) {\\n      revert ExchangerQuoteReceivedTooLow(address(this), minQuoteReceived, quoteReceived);\\n    }\\n  }\\n\\n  /// @notice Exchange to an exact amount of base for a maximum amount of quote (revert otherwise)\\n  function _exchangeToExactBase(uint amountBase, uint maxQuoteUsed) internal returns (uint baseReceived) {\\n    SynthetixAdapter.ExchangeParams memory exchangeParams = synthetixAdapter.getExchangeParams(address(optionMarket));\\n    (, baseReceived) = synthetixAdapter.exchangeToExactBaseWithLimit(\\n      exchangeParams,\\n      address(optionMarket),\\n      amountBase,\\n      maxQuoteUsed\\n    );\\n  }\\n\\n  /// @notice Returns the ExchangeParams for current market.\\n  function _getExchangeParams() internal view returns (ExchangeRateParams memory) {\\n    SynthetixAdapter.ExchangeParams memory params = synthetixAdapter.getExchangeParams(address(optionMarket));\\n    return\\n      ExchangeRateParams({\\n        spotPrice: params.spotPrice,\\n        quoteBaseFeeRate: params.quoteBaseFeeRate,\\n        baseQuoteFeeRate: params.baseQuoteFeeRate\\n      });\\n  }\\n\\n  /**\\n   * @notice WARNING: ENSURE CURVE HAS SUFFICIENT sUSD LIQUIDITY\\n   *         Exchange between stables within the curveSwap sUSD pool.\\n   *\\n   * @param from start ERC20\\n   * @param to destination ERC20\\n   * @param amount amount of \\\"from\\\" currency to exchange\\n   * @param expected minimum expected amount of \\\"to\\\" currency\\n   * @param receiver address of recipient of \\\"to\\\" currency\\n   *\\n   * @return amountOut received amount\\n   */\\n  function _swapStables(\\n    address from,\\n    address to,\\n    uint amount,\\n    uint expected,\\n    address receiver\\n  ) internal returns (uint amountOut) {\\n    amountOut = curveSwap.exchange_with_best_rate(from, to, amount, expected, receiver);\\n  }\\n\\n  //////////////////////////\\n  // Option Token Actions //\\n  //////////////////////////\\n\\n  /// @notice Get position info for given positionIds\\n  function _getPositions(uint[] memory positionIds) internal view returns (OptionPosition[] memory) {\\n    OptionToken.OptionPosition[] memory positions = optionToken.getOptionPositions(positionIds);\\n\\n    OptionPosition[] memory convertedPositions = new OptionPosition[](positions.length);\\n    for (uint i = 0; i < positions.length; i++) {\\n      convertedPositions[i] = OptionPosition({\\n        positionId: positions[i].positionId,\\n        strikeId: positions[i].strikeId,\\n        optionType: OptionType(uint(positions[i].optionType)),\\n        amount: positions[i].amount,\\n        collateral: positions[i].collateral,\\n        state: PositionState(uint(positions[i].state))\\n      });\\n    }\\n\\n    return convertedPositions;\\n  }\\n\\n  /**\\n   * @notice Allows a user to split a curent position into two. The amount of the original position will\\n   *         be subtracted from and a new position will be minted with the desired amount and collateral.\\n   * @dev Only ACTIVE positions can be owned by users, so status does not need to be checked\\n   * @dev Both resulting positions must not be liquidatable\\n   *\\n   * @param positionId the positionId of the original position to be split\\n   * @param newAmount the amount in the new position\\n   * @param newCollateral the amount of collateral for the new position\\n   * @param recipient recipient of new position\\n   */\\n  function _splitPosition(\\n    uint positionId,\\n    uint newAmount,\\n    uint newCollateral,\\n    address recipient\\n  ) internal returns (uint newPositionId) {\\n    newPositionId = optionToken.split(positionId, newAmount, newCollateral, recipient);\\n  }\\n\\n  /**\\n   * @notice User can merge many positions with matching strike and optionType into a single position\\n   * @dev Only ACTIVE positions can be owned by users, so status does not need to be checked.\\n   * @dev Merged position must not be liquidatable.\\n   *\\n   * @param positionIds the positionIds to be merged together\\n   */\\n  function _mergePositions(uint[] memory positionIds) internal {\\n    optionToken.merge(positionIds);\\n  }\\n\\n  ////////////////////\\n  // Market Getters //\\n  ////////////////////\\n\\n  /// @notice Returns the list of live board ids.\\n  function _getLiveBoards() internal view returns (uint[] memory liveBoards) {\\n    liveBoards = optionMarket.getLiveBoards();\\n  }\\n\\n  /// @notice Returns Board struct for a given boardId\\n  function _getBoard(uint boardId) internal view returns (Board memory) {\\n    OptionMarket.OptionBoard memory board = optionMarket.getOptionBoard(boardId);\\n    return Board({id: board.id, expiry: board.expiry, boardIv: board.iv, strikeIds: board.strikeIds});\\n  }\\n\\n  /// @notice Returns all Strike structs for a list of strikeIds\\n  function _getStrikes(uint[] memory strikeIds) internal view returns (Strike[] memory allStrikes) {\\n    allStrikes = new Strike[](strikeIds.length);\\n\\n    for (uint i = 0; i < strikeIds.length; i++) {\\n      (OptionMarket.Strike memory strike, OptionMarket.OptionBoard memory board) = optionMarket.getStrikeAndBoard(\\n        strikeIds[i]\\n      );\\n\\n      allStrikes[i] = Strike({\\n        id: strike.id,\\n        expiry: board.expiry,\\n        strikePrice: strike.strikePrice,\\n        skew: strike.skew,\\n        boardIv: board.iv\\n      });\\n    }\\n    return allStrikes;\\n  }\\n\\n  /// @notice Returns current spot volatilities for given strikeIds (boardIv * skew)\\n  function _getVols(uint[] memory strikeIds) internal view returns (uint[] memory vols) {\\n    vols = new uint[](strikeIds.length);\\n\\n    for (uint i = 0; i < strikeIds.length; i++) {\\n      (OptionMarket.Strike memory strike, OptionMarket.OptionBoard memory board) = optionMarket.getStrikeAndBoard(\\n        strikeIds[i]\\n      );\\n\\n      vols[i] = board.iv.multiplyDecimal(strike.skew);\\n    }\\n    return vols;\\n  }\\n\\n  /// @notice Returns current spot deltas for given strikeIds (using BlackScholes and spot volatilities)\\n  function _getDeltas(uint[] memory strikeIds) internal view returns (int[] memory callDeltas) {\\n    callDeltas = new int[](strikeIds.length);\\n    for (uint i = 0; i < strikeIds.length; i++) {\\n      BlackScholes.BlackScholesInputs memory bsInput = _getBsInput(strikeIds[i]);\\n      (callDeltas[i], ) = BlackScholes.delta(bsInput);\\n    }\\n  }\\n\\n  /// @notice Returns current spot vegas for given strikeIds (using BlackScholes and spot volatilities)\\n  function _getVegas(uint[] memory strikeIds) internal view returns (uint[] memory vegas) {\\n    vegas = new uint[](strikeIds.length);\\n    for (uint i = 0; i < strikeIds.length; i++) {\\n      BlackScholes.BlackScholesInputs memory bsInput = _getBsInput(strikeIds[i]);\\n      vegas[i] = BlackScholes.vega(bsInput);\\n    }\\n  }\\n\\n  /// @notice Calculate the pure black-scholes premium for given params\\n  function _getPurePremium(\\n    uint secondsToExpiry,\\n    uint vol,\\n    uint spotPrice,\\n    uint strikePrice\\n  ) internal view returns (uint call, uint put) {\\n    BlackScholes.BlackScholesInputs memory bsInput = BlackScholes.BlackScholesInputs({\\n      timeToExpirySec: secondsToExpiry,\\n      volatilityDecimal: vol,\\n      spotDecimal: spotPrice,\\n      strikePriceDecimal: strikePrice,\\n      rateDecimal: greekCache.getGreekCacheParams().rateAndCarry\\n    });\\n    (call, put) = BlackScholes.optionPrices(bsInput);\\n  }\\n\\n  /// @notice Calculate the spot black-scholes premium for a given strike\\n  /// @dev Does not include slippage or trading fees\\n  function _getPurePremiumForStrike(uint strikeId) internal view returns (uint call, uint put) {\\n    BlackScholes.BlackScholesInputs memory bsInput = _getBsInput(strikeId);\\n    (call, put) = BlackScholes.optionPrices(bsInput);\\n  }\\n\\n  /// @notice Returns the breakdown of current liquidity usage (see Liquidity struct)\\n  function _getLiquidity() internal view returns (Liquidity memory) {\\n    LiquidityPool.Liquidity memory liquidity = liquidityPool.getCurrentLiquidity();\\n    return\\n      Liquidity({\\n        freeLiquidity: liquidity.freeLiquidity,\\n        burnableLiquidity: liquidity.burnableLiquidity,\\n        usedCollatLiquidity: liquidity.usedCollatLiquidity,\\n        pendingDeltaLiquidity: liquidity.pendingDeltaLiquidity,\\n        usedDeltaLiquidity: liquidity.usedDeltaLiquidity,\\n        NAV: liquidity.NAV\\n      });\\n  }\\n\\n  /// @notice Returns the amount of liquidity available for trading\\n  function _getFreeLiquidity() internal view returns (uint freeLiquidity) {\\n    freeLiquidity = liquidityPool.getCurrentLiquidity().freeLiquidity;\\n  }\\n\\n  /// @notice Returns the most critical Lyra market trading parameters that determine pricing/slippage/trading restrictions\\n  function _getMarketParams() internal view returns (MarketParams memory) {\\n    OptionMarketPricer.PricingParameters memory pricingParams = optionPricer.getPricingParams();\\n    OptionMarketPricer.TradeLimitParameters memory tradeLimitParams = optionPricer.getTradeLimitParams();\\n    return\\n      MarketParams({\\n        standardSize: pricingParams.standardSize,\\n        skewAdjustmentParam: pricingParams.skewAdjustmentFactor,\\n        rateAndCarry: greekCache.getGreekCacheParams().rateAndCarry,\\n        deltaCutOff: tradeLimitParams.minDelta,\\n        tradingCutoff: tradeLimitParams.tradingCutoff,\\n        minForceCloseDelta: tradeLimitParams.minForceCloseDelta\\n      });\\n  }\\n\\n  /// @notice use latest optionMarket delta cutoff to determine whether trade delta is out of bounds\\n  function _isOutsideDeltaCutoff(uint strikeId) internal view returns (bool) {\\n    MarketParams memory marketParams = _getMarketParams();\\n    uint[] memory dynamicArray = new uint[](1);\\n    dynamicArray[0] = strikeId;\\n\\n    int callDelta = _getDeltas(dynamicArray)[0];\\n    return callDelta > (int(DecimalMath.UNIT) - marketParams.deltaCutOff) || callDelta < marketParams.deltaCutOff;\\n  }\\n\\n  /// @notice use latest optionMarket trading cutoff to determine whether trade is too close to expiry\\n  function _isWithinTradingCutoff(uint strikeId) internal view returns (bool) {\\n    MarketParams memory marketParams = _getMarketParams();\\n    uint[] memory dynamicArray = new uint[](1);\\n    dynamicArray[0] = strikeId;\\n\\n    Strike memory strike = _getStrikes(dynamicArray)[0];\\n    return strike.expiry - block.timestamp <= marketParams.tradingCutoff;\\n  }\\n\\n  ////////////////////////\\n  // Minimum Collateral //\\n  ////////////////////////\\n\\n  /// @notice Estimate minimum collateral required for given parameters\\n  /// @dev Position is liquidatable when position.collateral < minCollateral\\n  function _getMinCollateral(\\n    OptionType optionType,\\n    uint strikePrice,\\n    uint expiry,\\n    uint spotPrice,\\n    uint amount\\n  ) internal view returns (uint) {\\n    return\\n      greekCache.getMinCollateral(OptionMarket.OptionType(uint(optionType)), strikePrice, expiry, spotPrice, amount);\\n  }\\n\\n  /// @notice Estimate minimum collateral required for an existing position\\n  function _getMinCollateralForPosition(uint positionId) internal view returns (uint) {\\n    OptionToken.PositionWithOwner memory position = optionToken.getPositionWithOwner(positionId);\\n    if (_isLong(OptionType(uint(position.optionType)))) return 0;\\n\\n    uint strikePrice;\\n    uint expiry;\\n    (strikePrice, expiry) = optionMarket.getStrikeAndExpiry(position.strikeId);\\n\\n    return\\n      _getMinCollateral(\\n        OptionType(uint(position.optionType)),\\n        strikePrice,\\n        expiry,\\n        synthetixAdapter.getSpotPriceForMarket(address(optionMarket)),\\n        position.amount\\n      );\\n  }\\n\\n  /// @notice Estimate minimum collateral required for a given strike with manual amount\\n  function _getMinCollateralForStrike(\\n    OptionType optionType,\\n    uint strikeId,\\n    uint amount\\n  ) internal view returns (uint) {\\n    if (_isLong(optionType)) return 0;\\n\\n    uint strikePrice;\\n    uint expiry;\\n    (strikePrice, expiry) = optionMarket.getStrikeAndExpiry(strikeId);\\n\\n    return\\n      _getMinCollateral(\\n        optionType,\\n        strikePrice,\\n        expiry,\\n        synthetixAdapter.getSpotPriceForMarket(address(optionMarket)),\\n        amount\\n      );\\n  }\\n\\n  /////////////////\\n  // GWAV Oracle //\\n  /////////////////\\n\\n  /// @notice the `baseIv` GWAV for a given `boardId` with GWAV interval `secondsAgo`\\n  function _ivGWAV(uint boardId, uint secondsAgo) internal view returns (uint) {\\n    return gwavOracle.ivGWAV(boardId, secondsAgo);\\n  }\\n\\n  /// @notice the volatility `skew` GWAV for a given `strikeId` with GWAV interval `secondsAgo`\\n  function _skewGWAV(uint strikeId, uint secondsAgo) internal view returns (uint) {\\n    return gwavOracle.skewGWAV(strikeId, secondsAgo);\\n  }\\n\\n  /// @notice the resultant volatility =`skew` * 'baseIv'\\n  ///         for a given `strikeId` with GWAV interval `secondsAgo`\\n  function _volGWAV(uint strikeId, uint secondsAgo) internal view returns (uint) {\\n    return gwavOracle.volGWAV(strikeId, secondsAgo);\\n  }\\n\\n  /// @notice the delta GWAV for a given `strikeId` with GWAV interval `secondsAgo`\\n  function _deltaGWAV(uint strikeId, uint secondsAgo) internal view returns (int callDelta) {\\n    return gwavOracle.deltaGWAV(strikeId, secondsAgo);\\n  }\\n\\n  /// @notice the non-normalized vega GWAV for a given `strikeId` with GWAV interval `secondsAgo`\\n  function _vegaGWAV(uint strikeId, uint secondsAgo) internal view returns (uint) {\\n    return gwavOracle.vegaGWAV(strikeId, secondsAgo);\\n  }\\n\\n  /// @notice the option price GWAV for a given `strikeId` with GWAV interval `secondsAgo`\\n  function _optionPriceGWAV(uint strikeId, uint secondsAgo) external view returns (uint callPrice, uint putPrice) {\\n    return gwavOracle.optionPriceGWAV(strikeId, secondsAgo);\\n  }\\n\\n  //////////\\n  // Misc //\\n  //////////\\n\\n  /// @dev format all strike related params before input into BlackScholes\\n  function _getBsInput(uint strikeId) internal view returns (BlackScholes.BlackScholesInputs memory bsInput) {\\n    (OptionMarket.Strike memory strike, OptionMarket.OptionBoard memory board) = optionMarket.getStrikeAndBoard(\\n      strikeId\\n    );\\n    bsInput = BlackScholes.BlackScholesInputs({\\n      timeToExpirySec: board.expiry - block.timestamp,\\n      volatilityDecimal: board.iv.multiplyDecimal(strike.skew),\\n      spotDecimal: synthetixAdapter.getSpotPriceForMarket(address(optionMarket)),\\n      strikePriceDecimal: strike.strikePrice,\\n      rateDecimal: greekCache.getGreekCacheParams().rateAndCarry\\n    });\\n  }\\n\\n  /// @dev Check if position is long\\n  function _isLong(OptionType optionType) internal pure returns (bool) {\\n    return (optionType < OptionType.SHORT_CALL_BASE);\\n  }\\n\\n  /// @dev Convert LyraAdapter.TradeInputParameters into OptionMarket.TradeInputParameters\\n  function _convertParams(TradeInputParameters memory _params)\\n    internal\\n    pure\\n    returns (OptionMarket.TradeInputParameters memory)\\n  {\\n    return\\n      OptionMarket.TradeInputParameters({\\n        strikeId: _params.strikeId,\\n        positionId: _params.positionId,\\n        iterations: _params.iterations,\\n        optionType: OptionMarket.OptionType(uint(_params.optionType)),\\n        amount: _params.amount,\\n        setCollateralTo: _params.setCollateralTo,\\n        minTotalCost: _params.minTotalCost,\\n        maxTotalCost: _params.maxTotalCost\\n      });\\n  }\\n\\n  /// @dev get lyra market addresses from LyraRegistry\\n  function _assignLyraRegistryMarketAddresses() internal {\\n    LyraRegistry.OptionMarketAddresses memory addresses = lyraRegistry.getMarketAddresses(optionMarket);\\n\\n    liquidityPool = addresses.liquidityPool;\\n    greekCache = addresses.greekCache;\\n    optionPricer = addresses.optionMarketPricer;\\n    optionToken = addresses.optionToken;\\n    shortCollateral = addresses.shortCollateral;\\n    gwavOracle = addresses.gwavOracle;\\n    quoteAsset = addresses.quoteAsset;\\n    baseAsset = addresses.baseAsset;\\n  }\\n\\n  ////////////\\n  // Errors //\\n  ////////////\\n\\n  error ExchangerBaseReceivedTooLow(address thrower, uint baseExpected, uint baseReceived);\\n  error ExchangerQuoteReceivedTooLow(address thrower, uint quoteExpected, uint quoteReceived);\\n}\\n\",\"keccak256\":\"0x7228d4ce06897c6593171f22cc88886a6163819a55a46310c891bf35b3686b25\",\"license\":\"ISC\"},\"@lyrafinance/protocol/contracts/periphery/LyraRegistry.sol\":{\"content\":\"//SPDX-License-Identifier:ISC\\npragma solidity 0.8.9;\\n\\nimport \\\"../OptionMarket.sol\\\";\\nimport \\\"../libraries/BlackScholes.sol\\\";\\nimport \\\"../synthetix/DecimalMath.sol\\\";\\nimport \\\"../OptionToken.sol\\\";\\nimport \\\"../LiquidityPool.sol\\\";\\nimport \\\"../OptionGreekCache.sol\\\";\\nimport \\\"../OptionMarketPricer.sol\\\";\\nimport \\\"../SynthetixAdapter.sol\\\";\\nimport \\\"../synthetix/Owned.sol\\\";\\nimport \\\"./Wrapper/OptionMarketWrapper.sol\\\";\\nimport \\\"./OptionMarketViewer.sol\\\";\\nimport \\\"./GWAVOracle.sol\\\";\\n\\n/**\\n * @title OptionMarketViewer\\n * @author Lyra\\n * @dev Provides helpful functions to allow the dapp to operate more smoothly; logic in getPremiumForTrade is vital to\\n * ensuring accurate prices are provided to the user.\\n */\\ncontract LyraRegistry is Owned {\\n  struct OptionMarketAddresses {\\n    LiquidityPool liquidityPool;\\n    LiquidityToken liquidityToken;\\n    OptionGreekCache greekCache;\\n    OptionMarket optionMarket;\\n    OptionMarketPricer optionMarketPricer;\\n    OptionToken optionToken;\\n    PoolHedger poolHedger;\\n    ShortCollateral shortCollateral;\\n    GWAVOracle gwavOracle;\\n    IERC20 quoteAsset;\\n    IERC20 baseAsset;\\n  }\\n\\n  OptionMarket[] public optionMarkets;\\n  mapping(OptionMarket => OptionMarketAddresses) public marketAddresses;\\n  mapping(bytes32 => address) public globalAddresses;\\n\\n  constructor() Owned() {}\\n\\n  function getMarketAddresses(OptionMarket optionMarket) external view returns (OptionMarketAddresses memory) {\\n    OptionMarketAddresses memory addresses = marketAddresses[optionMarket];\\n    if (address(addresses.optionMarket) != address(0)) {\\n      return addresses;\\n    } else {\\n      revert NonExistentMarket(address(optionMarket));\\n    }\\n  }\\n\\n  function getGlobalAddress(bytes32 contractName) external view returns (address globalContract) {\\n    globalContract = globalAddresses[contractName];\\n    if (globalContract != address(0)) {\\n      return globalContract;\\n    } else {\\n      revert NonExistentGlobalContract(contractName);\\n    }\\n  }\\n\\n  function updateGlobalAddresses(bytes32[] memory names, address[] memory addresses) external onlyOwner {\\n    require(names.length == addresses.length, \\\"length mismatch\\\");\\n    for (uint i = 0; i < names.length; i++) {\\n      globalAddresses[names[i]] = addresses[i];\\n      emit GlobalAddressUpdated(names[i], addresses[i]);\\n    }\\n  }\\n\\n  function addMarket(OptionMarketAddresses memory newMarketAddresses) external onlyOwner {\\n    if (address(marketAddresses[newMarketAddresses.optionMarket].optionMarket) == address(0)) {\\n      optionMarkets.push(newMarketAddresses.optionMarket);\\n    }\\n    marketAddresses[newMarketAddresses.optionMarket] = newMarketAddresses;\\n    emit MarketUpdated(newMarketAddresses.optionMarket, newMarketAddresses);\\n  }\\n\\n  function removeMarket(OptionMarket market) external onlyOwner {\\n    _removeMarket(market);\\n  }\\n\\n  function _removeMarket(OptionMarket market) internal {\\n    // do something with marketAddresses ?\\n    uint index = 0;\\n    bool found = false;\\n    for (uint i = 0; i < optionMarkets.length; i++) {\\n      if (optionMarkets[i] == market) {\\n        index = i;\\n        found = true;\\n        break;\\n      }\\n    }\\n    if (!found) {\\n      revert RemovingInvalidMarket(address(this), address(market));\\n    }\\n    optionMarkets[index] = optionMarkets[optionMarkets.length - 1];\\n    optionMarkets.pop();\\n\\n    emit MarketRemoved(market);\\n    delete marketAddresses[market];\\n  }\\n\\n  /**\\n   * @dev Emitted when a global contract is added\\n   */\\n  event GlobalAddressUpdated(bytes32 indexed name, address addr);\\n\\n  /**\\n   * @dev Emitted when an optionMarket is updated\\n   */\\n  event MarketUpdated(OptionMarket indexed optionMarket, OptionMarketAddresses market);\\n\\n  /**\\n   * @dev Emitted when an optionMarket is removed\\n   */\\n  event MarketRemoved(OptionMarket indexed market);\\n\\n  ////////////\\n  // Errors //\\n  ////////////\\n\\n  error RemovingInvalidMarket(address thrower, address market);\\n\\n  error NonExistentMarket(address optionMarket);\\n\\n  error NonExistentGlobalContract(bytes32 contractName);\\n}\\n\",\"keccak256\":\"0x5e1268301edc5d5a1a73346db51c038d7b98a11e45ad467a295c1240916421c4\",\"license\":\"ISC\"},\"@lyrafinance/protocol/contracts/periphery/OptionMarketViewer.sol\":{\"content\":\"//SPDX-License-Identifier:ISC\\npragma solidity 0.8.9;\\n\\nimport \\\"../OptionMarket.sol\\\";\\nimport \\\"../libraries/BlackScholes.sol\\\";\\nimport \\\"../synthetix/DecimalMath.sol\\\";\\nimport \\\"../OptionToken.sol\\\";\\nimport \\\"../LiquidityPool.sol\\\";\\nimport \\\"../OptionGreekCache.sol\\\";\\nimport \\\"../OptionMarketPricer.sol\\\";\\nimport \\\"../SynthetixAdapter.sol\\\";\\n\\n// Inherited\\nimport \\\"../synthetix/Owned.sol\\\";\\n\\n/**\\n * @title OptionMarketViewer\\n * @author Lyra\\n * @dev Provides helpful functions to allow the dapp to operate more smoothly; logic in getPremiumForTrade is vital to\\n * ensuring accurate prices are provided to the user.\\n */\\ncontract OptionMarketViewer is Owned {\\n  struct MarketsView {\\n    IAddressResolver addressResolver;\\n    bool isPaused;\\n    MarketView[] markets;\\n  }\\n\\n  struct MarketView {\\n    bool isPaused;\\n    uint totalQueuedDeposits;\\n    uint totalQueuedWithdrawals;\\n    uint tokenPrice;\\n    OptionMarketAddresses marketAddresses;\\n    MarketParameters marketParameters;\\n    LiquidityPool.Liquidity liquidity;\\n    OptionGreekCache.NetGreeks globalNetGreeks;\\n    SynthetixAdapter.ExchangeParams exchangeParams;\\n  }\\n\\n  struct MarketViewWithBoards {\\n    bool isPaused;\\n    uint totalQueuedDeposits;\\n    uint totalQueuedWithdrawals;\\n    uint tokenPrice;\\n    OptionMarketAddresses marketAddresses;\\n    MarketParameters marketParameters;\\n    LiquidityPool.Liquidity liquidity;\\n    OptionGreekCache.NetGreeks globalNetGreeks;\\n    BoardView[] liveBoards;\\n    SynthetixAdapter.ExchangeParams exchangeParams;\\n  }\\n\\n  struct MarketParameters {\\n    OptionMarket.OptionMarketParameters optionMarketParams;\\n    LiquidityPool.LiquidityPoolParameters lpParams;\\n    OptionGreekCache.GreekCacheParameters greekCacheParams;\\n    OptionGreekCache.ForceCloseParameters forceCloseParams;\\n    OptionGreekCache.MinCollateralParameters minCollatParams;\\n    OptionMarketPricer.PricingParameters pricingParams;\\n    OptionMarketPricer.TradeLimitParameters tradeLimitParams;\\n    OptionMarketPricer.VarianceFeeParameters varianceFeeParams;\\n    OptionToken.PartialCollateralParameters partialCollatParams;\\n    PoolHedger.PoolHedgerParameters poolHedgerParams;\\n  }\\n\\n  struct StrikeView {\\n    uint strikeId;\\n    uint boardId;\\n    uint strikePrice;\\n    uint skew;\\n    uint forceCloseSkew;\\n    OptionGreekCache.StrikeGreeks cachedGreeks;\\n    uint baseReturnedRatio;\\n    uint longCallOpenInterest;\\n    uint longPutOpenInterest;\\n    uint shortCallBaseOpenInterest;\\n    uint shortCallQuoteOpenInterest;\\n    uint shortPutOpenInterest;\\n  }\\n\\n  struct BoardView {\\n    address market;\\n    uint boardId;\\n    uint expiry;\\n    uint baseIv;\\n    uint priceAtExpiry;\\n    bool isPaused;\\n    uint forceCloseGwavIV;\\n    OptionGreekCache.NetGreeks netGreeks;\\n    StrikeView[] strikes;\\n  }\\n\\n  struct MarketOptionPositions {\\n    address market;\\n    OptionToken.OptionPosition[] positions;\\n  }\\n\\n  struct OptionMarketAddresses {\\n    LiquidityPool liquidityPool;\\n    LiquidityToken liquidityToken;\\n    OptionGreekCache greekCache;\\n    OptionMarket optionMarket;\\n    OptionMarketPricer optionMarketPricer;\\n    OptionToken optionToken;\\n    ShortCollateral shortCollateral;\\n    PoolHedger poolHedger;\\n    IERC20 quoteAsset;\\n    IERC20 baseAsset;\\n  }\\n\\n  struct LiquidityBalanceAndAllowance {\\n    address token;\\n    uint balance;\\n    uint allowance;\\n  }\\n\\n  SynthetixAdapter public synthetixAdapter;\\n  bool public initialized = false;\\n  OptionMarket[] public optionMarkets;\\n  mapping(OptionMarket => OptionMarketAddresses) public marketAddresses;\\n\\n  constructor() Owned() {}\\n\\n  /**\\n   * @dev Initializes the contract\\n   * @param _synthetixAdapter SynthetixAdapter contract address\\n   */\\n  function init(SynthetixAdapter _synthetixAdapter) external {\\n    require(!initialized, \\\"already initialized\\\");\\n    synthetixAdapter = _synthetixAdapter;\\n    initialized = true;\\n  }\\n\\n  function addMarket(OptionMarketAddresses memory newMarketAddresses) external onlyOwner {\\n    optionMarkets.push(newMarketAddresses.optionMarket);\\n    marketAddresses[newMarketAddresses.optionMarket] = newMarketAddresses;\\n    emit MarketAdded(newMarketAddresses);\\n  }\\n\\n  function removeMarket(OptionMarket market) external onlyOwner {\\n    uint index = 0;\\n    bool found = false;\\n\\n    for (uint i = 0; i < optionMarkets.length; i++) {\\n      if (optionMarkets[i] == market) {\\n        index = i;\\n        found = true;\\n        break;\\n      }\\n    }\\n    if (!found) {\\n      revert RemovingInvalidMarket(address(this), address(market));\\n    }\\n    optionMarkets[index] = optionMarkets[optionMarkets.length - 1];\\n    optionMarkets.pop();\\n\\n    emit MarketRemoved(market);\\n    delete marketAddresses[market];\\n  }\\n\\n  function getMarketAddresses() external view returns (OptionMarketAddresses[] memory) {\\n    uint marketsLen = optionMarkets.length;\\n    OptionMarketAddresses[] memory allMarketAddresses = new OptionMarketAddresses[](marketsLen);\\n    for (uint i = 0; i < marketsLen; i++) {\\n      allMarketAddresses[i] = marketAddresses[optionMarkets[i]];\\n    }\\n    return allMarketAddresses;\\n  }\\n\\n  function getMarkets(OptionMarket[] memory markets) external view returns (MarketsView memory marketsView) {\\n    MarketView[] memory marketViews = new MarketView[](markets.length);\\n    bool isGlobalPaused = synthetixAdapter.isGlobalPaused();\\n    for (uint i = 0; i < markets.length; i++) {\\n      OptionMarketAddresses memory marketC = marketAddresses[markets[i]];\\n      marketViews[i] = _getMarket(marketC, isGlobalPaused);\\n    }\\n    return\\n      MarketsView({\\n        addressResolver: synthetixAdapter.addressResolver(),\\n        isPaused: isGlobalPaused,\\n        markets: marketViews\\n      });\\n  }\\n\\n  function getMarketForBaseKey(bytes32 baseKey) public view returns (MarketViewWithBoards memory market) {\\n    for (uint i = 0; i < optionMarkets.length; i++) {\\n      OptionMarketAddresses memory marketC = marketAddresses[optionMarkets[i]];\\n      bytes32 marketBaseKey = synthetixAdapter.baseKey(address(marketC.optionMarket));\\n      if (marketBaseKey == baseKey) {\\n        market = getMarket(marketC.optionMarket);\\n        break;\\n      }\\n    }\\n    require(address(market.marketAddresses.optionMarket) != address(0), \\\"No market for base key\\\");\\n    return market;\\n  }\\n\\n  function getMarket(OptionMarket market) public view returns (MarketViewWithBoards memory) {\\n    OptionMarketAddresses memory marketC = marketAddresses[market];\\n    MarketView memory marketView = _getMarket(marketC, synthetixAdapter.isGlobalPaused());\\n    return\\n      MarketViewWithBoards({\\n        marketAddresses: marketView.marketAddresses,\\n        isPaused: marketView.isPaused,\\n        liveBoards: getLiveBoards(marketC.optionMarket),\\n        marketParameters: marketView.marketParameters,\\n        totalQueuedDeposits: marketView.totalQueuedDeposits,\\n        totalQueuedWithdrawals: marketView.totalQueuedWithdrawals,\\n        tokenPrice: marketView.tokenPrice,\\n        liquidity: marketView.liquidity,\\n        globalNetGreeks: marketView.globalNetGreeks,\\n        exchangeParams: marketView.exchangeParams\\n      });\\n  }\\n\\n  function _getMarket(OptionMarketAddresses memory marketC, bool isGlobalPaused)\\n    internal\\n    view\\n    returns (MarketView memory)\\n  {\\n    OptionGreekCache.GlobalCache memory globalCache = marketC.greekCache.getGlobalCache();\\n    MarketParameters memory marketParameters = _getMarketParams(marketC);\\n    bool isMarketPaused = synthetixAdapter.isMarketPaused(address(marketC.optionMarket));\\n    if (!isMarketPaused && !isGlobalPaused) {\\n      SynthetixAdapter.ExchangeParams memory exchangeParams = synthetixAdapter.getExchangeParams(\\n        address(marketC.optionMarket)\\n      );\\n      return\\n        MarketView({\\n          marketAddresses: marketC,\\n          isPaused: isMarketPaused,\\n          marketParameters: marketParameters,\\n          totalQueuedDeposits: marketC.liquidityPool.totalQueuedDeposits(),\\n          totalQueuedWithdrawals: marketC.liquidityPool.totalQueuedWithdrawals(),\\n          tokenPrice: marketC.liquidityPool.getTokenPrice(),\\n          liquidity: marketC.liquidityPool.getLiquidity(exchangeParams.spotPrice),\\n          globalNetGreeks: globalCache.netGreeks,\\n          exchangeParams: exchangeParams\\n        });\\n    } else {\\n      return\\n        MarketView({\\n          marketAddresses: marketC,\\n          isPaused: isMarketPaused,\\n          marketParameters: marketParameters,\\n          totalQueuedDeposits: 0,\\n          totalQueuedWithdrawals: 0,\\n          tokenPrice: 0,\\n          liquidity: LiquidityPool.Liquidity({\\n            freeLiquidity: 0,\\n            burnableLiquidity: 0,\\n            usedCollatLiquidity: 0,\\n            pendingDeltaLiquidity: 0,\\n            usedDeltaLiquidity: 0,\\n            NAV: 0\\n          }),\\n          globalNetGreeks: globalCache.netGreeks,\\n          exchangeParams: SynthetixAdapter.ExchangeParams({\\n            spotPrice: 0,\\n            quoteKey: synthetixAdapter.quoteKey(address(marketC.optionMarket)),\\n            baseKey: synthetixAdapter.baseKey(address(marketC.optionMarket)),\\n            quoteBaseFeeRate: 0,\\n            baseQuoteFeeRate: 0\\n          })\\n        });\\n    }\\n  }\\n\\n  function _getMarketParams(OptionMarketAddresses memory marketC)\\n    internal\\n    view\\n    returns (MarketParameters memory params)\\n  {\\n    return\\n      MarketParameters({\\n        optionMarketParams: marketC.optionMarket.getOptionMarketParams(),\\n        lpParams: marketC.liquidityPool.getLpParams(),\\n        greekCacheParams: marketC.greekCache.getGreekCacheParams(),\\n        forceCloseParams: marketC.greekCache.getForceCloseParams(),\\n        minCollatParams: marketC.greekCache.getMinCollatParams(),\\n        pricingParams: marketC.optionMarketPricer.getPricingParams(),\\n        tradeLimitParams: marketC.optionMarketPricer.getTradeLimitParams(),\\n        varianceFeeParams: marketC.optionMarketPricer.getVarianceFeeParams(),\\n        partialCollatParams: marketC.optionToken.getPartialCollatParams(),\\n        poolHedgerParams: marketC.poolHedger.getPoolHedgerParams()\\n      });\\n  }\\n\\n  function getOwnerPositions(address account) external view returns (MarketOptionPositions[] memory) {\\n    MarketOptionPositions[] memory positions = new MarketOptionPositions[](optionMarkets.length);\\n    for (uint i = 0; i < optionMarkets.length; i++) {\\n      OptionMarketAddresses memory marketC = marketAddresses[optionMarkets[i]];\\n      positions[i].market = address(marketC.optionMarket);\\n      positions[i].positions = marketC.optionToken.getOwnerPositions(account);\\n    }\\n    return positions;\\n  }\\n\\n  function getOwnerPositionsInRange(\\n    OptionMarket market,\\n    address account,\\n    uint start,\\n    uint limit\\n  ) external view returns (OptionToken.OptionPosition[] memory) {\\n    OptionMarketAddresses memory marketC = marketAddresses[market];\\n    uint balance = marketC.optionToken.balanceOf(account);\\n    uint n = limit > balance - start ? balance - start : limit;\\n    OptionToken.OptionPosition[] memory result = new OptionToken.OptionPosition[](n);\\n    for (uint i = 0; i < n; i++) {\\n      result[i] = marketC.optionToken.getOptionPosition(marketC.optionToken.tokenOfOwnerByIndex(account, start + i));\\n    }\\n    return result;\\n  }\\n\\n  // Get live boards for the chosen market\\n  function getLiveBoards(OptionMarket market) public view returns (BoardView[] memory marketBoards) {\\n    OptionMarketAddresses memory marketC = marketAddresses[market];\\n    uint[] memory liveBoards = marketC.optionMarket.getLiveBoards();\\n    marketBoards = new BoardView[](liveBoards.length);\\n    for (uint i = 0; i < liveBoards.length; i++) {\\n      marketBoards[i] = _getBoard(marketC, liveBoards[i]);\\n    }\\n  }\\n\\n  // Get single board for market based on boardId\\n  function getBoard(OptionMarket market, uint boardId) external view returns (BoardView memory) {\\n    OptionMarketAddresses memory marketC = marketAddresses[market];\\n    return _getBoard(marketC, boardId);\\n  }\\n\\n  function getBoardForBaseKey(bytes32 baseKey, uint boardId) external view returns (BoardView memory) {\\n    MarketViewWithBoards memory marketView = getMarketForBaseKey(baseKey);\\n    return _getBoard(marketView.marketAddresses, boardId);\\n  }\\n\\n  function getBoardForStrikeId(OptionMarket market, uint strikeId) external view returns (BoardView memory) {\\n    OptionMarketAddresses memory marketC = marketAddresses[market];\\n    OptionMarket.Strike memory strike = marketC.optionMarket.getStrike(strikeId);\\n    return _getBoard(marketC, strike.boardId);\\n  }\\n\\n  function _getBoard(OptionMarketAddresses memory marketC, uint boardId) internal view returns (BoardView memory) {\\n    (\\n      OptionMarket.OptionBoard memory board,\\n      OptionMarket.Strike[] memory strikes,\\n      uint[] memory strikeToBaseReturnedRatios,\\n      uint priceAtExpiry\\n    ) = marketC.optionMarket.getBoardAndStrikeDetails(boardId);\\n    OptionGreekCache.BoardGreeksView memory boardGreeksView;\\n    if (priceAtExpiry == 0) {\\n      boardGreeksView = marketC.greekCache.getBoardGreeksView(boardId);\\n    }\\n    return\\n      BoardView({\\n        boardId: board.id,\\n        market: address(marketC.optionMarket),\\n        expiry: board.expiry,\\n        baseIv: board.iv,\\n        priceAtExpiry: priceAtExpiry,\\n        isPaused: board.frozen,\\n        forceCloseGwavIV: boardGreeksView.ivGWAV,\\n        strikes: _getStrikeViews(strikes, boardGreeksView, strikeToBaseReturnedRatios, priceAtExpiry),\\n        netGreeks: boardGreeksView.boardGreeks\\n      });\\n  }\\n\\n  function _getStrikeViews(\\n    OptionMarket.Strike[] memory strikes,\\n    OptionGreekCache.BoardGreeksView memory boardGreeksView,\\n    uint[] memory strikeToBaseReturnedRatios,\\n    uint priceAtExpiry\\n  ) internal pure returns (StrikeView[] memory strikeViews) {\\n    strikeViews = new StrikeView[](strikes.length);\\n\\n    for (uint i = 0; i < strikes.length; i++) {\\n      strikeViews[i] = StrikeView({\\n        strikePrice: strikes[i].strikePrice,\\n        skew: strikes[i].skew,\\n        forceCloseSkew: priceAtExpiry == 0 ? boardGreeksView.skewGWAVs[i] : 0,\\n        cachedGreeks: priceAtExpiry == 0\\n          ? boardGreeksView.strikeGreeks[i]\\n          : OptionGreekCache.StrikeGreeks(0, 0, 0, 0, 0),\\n        strikeId: strikes[i].id,\\n        boardId: strikes[i].boardId,\\n        longCallOpenInterest: strikes[i].longCall,\\n        longPutOpenInterest: strikes[i].longPut,\\n        shortCallBaseOpenInterest: strikes[i].shortCallBase,\\n        shortCallQuoteOpenInterest: strikes[i].shortCallQuote,\\n        shortPutOpenInterest: strikes[i].shortPut,\\n        baseReturnedRatio: strikeToBaseReturnedRatios[i]\\n      });\\n    }\\n  }\\n\\n  function getLiquidityBalancesAndAllowances(OptionMarket[] memory markets, address account)\\n    external\\n    view\\n    returns (LiquidityBalanceAndAllowance[] memory)\\n  {\\n    LiquidityBalanceAndAllowance[] memory balances = new LiquidityBalanceAndAllowance[](markets.length);\\n    for (uint i = 0; i < markets.length; i++) {\\n      OptionMarketAddresses memory marketC = marketAddresses[markets[i]];\\n      IERC20 liquidityToken = IERC20(marketC.liquidityToken);\\n      balances[i].balance = liquidityToken.balanceOf(account);\\n      balances[i].allowance = marketC.quoteAsset.allowance(account, address(marketC.liquidityPool));\\n      balances[i].token = address(marketC.liquidityPool);\\n    }\\n    return balances;\\n  }\\n\\n  /**\\n   * @dev Emitted when an optionMarket is added\\n   */\\n  event MarketAdded(OptionMarketAddresses market);\\n\\n  /**\\n   * @dev Emitted when an optionMarket is removed\\n   */\\n  event MarketRemoved(OptionMarket market);\\n\\n  ////////////\\n  // Errors //\\n  ////////////\\n  error RemovingInvalidMarket(address thrower, address market);\\n}\\n\",\"keccak256\":\"0x6644ad341b16a0583c375985dfa407f223b9e2d6a008e962befb2a48ce44c94c\",\"license\":\"ISC\"},\"@lyrafinance/protocol/contracts/periphery/Wrapper/OptionMarketWrapper.sol\":{\"content\":\"//SPDX-License-Identifier: ISC\\npragma solidity 0.8.9;\\n\\n// Inherited\\nimport \\\"./OptionMarketWrapperWithSwaps.sol\\\";\\n\\n/**\\n * @title CompressedOptionMarketWrapper\\n * @author Lyra\\n * @dev Allows users to open/close positions in any market with multiple stablecoins\\n */\\ncontract OptionMarketWrapper is OptionMarketWrapperWithSwaps {\\n  /////////////////////////////////////////////\\n  // Specific functions with packed calldata //\\n  /////////////////////////////////////////////\\n\\n  /**\\n   * @param params Is a compressed uint which contains the following fields:\\n   * loc | type   | name         | description\\n   * ------------------------------------------\\n   * 0   | uint8  | market       | Market id as set in `addMarket`\\n   * 8   | uint8  | inputAsset   | Asset the caller is sending to the contract\\n   * 16  | bool   | isCall       | Whether the purchased option is a call or put\\n   * 24  | uint8  | iterations   | Number of iterations for the trade to make. Avoid 3 due to rounding.\\n   * 32  | uint32 | strikeId     | The strikeId to be traded\\n   * 64  | uint32 | maxCost      | The maximum amount the user will pay for all the options purchased - there must have at least this much left over after a stable swap\\n   * 96  | uint32 | inputAmount  | The amount the user is sending into the contract (compressed to 1 d.p.)\\n   * 128 | uint64 | size         | The amount of options the user is purchasing (compressed to 8 d.p.)\\n   * Total 192 bits\\n   */\\n  function openLong(uint params) external returns (uint totalCost) {\\n    ERC20 inputAsset = idToERC[uint8(params >> 8)];\\n\\n    OptionPositionParams memory positionParams = OptionPositionParams({\\n      optionMarket: idToMarket[uint8(params)],\\n      strikeId: _parseUint32(params >> 32),\\n      positionId: 0,\\n      iterations: _parseUint8(params >> 24),\\n      currentCollateral: 0,\\n      setCollateralTo: 0,\\n      optionType: uint8(params >> 16) > 0 ? OptionMarket.OptionType.LONG_CALL : OptionMarket.OptionType.LONG_PUT,\\n      amount: _parseUint64Amount(params >> 128),\\n      minCost: 0,\\n      maxCost: _parseUint32Amount(params >> 64),\\n      inputAmount: _convertDecimal(_parseUint32(params >> 96), inputAsset),\\n      inputAsset: inputAsset\\n    });\\n\\n    ReturnDetails memory returnDetails = _openPosition(positionParams);\\n    totalCost = returnDetails.totalCost;\\n  }\\n\\n  /**\\n   * @param params Is a compressed uint which contains the following fields:\\n   * loc | type   | name         | description\\n   * ------------------------------------------\\n   * 0   | uint8  | market       | Market id as set in `addMarket`\\n   * 8   | uint8  | inputAsset   | Asset the caller is sending to the contract\\n   * 16  | uint8  | iterations   | Number of iterations for the trade to make. Avoid 3 due to rounding.\\n   * 24  | uint32 | positionId   | Increasing the size of this position id\\n   * 56  | uint32 | maxCost      | The maximum amount the user will pay for all the options purchased - there must have at least this much left over after a stable swap\\n   * 88  | uint32 | inputAmount  | The amount the user is sending into the contract (compressed to 1 d.p.)\\n   * 120 | uint64 | size         | The amount of options the user is adding to the position (compressed to 8 d.p.)\\n   * Total 184 bits\\n   */\\n  function addLong(uint params) external returns (uint totalCost) {\\n    OptionMarket optionMarket = idToMarket[uint8(params)];\\n    OptionMarketContracts memory c = marketContracts[optionMarket];\\n    OptionToken.PositionWithOwner memory position = c.optionToken.getPositionWithOwner(uint(uint32(params >> 24)));\\n    ERC20 inputAsset = idToERC[uint8(params >> 8)];\\n\\n    OptionPositionParams memory positionParams = OptionPositionParams({\\n      optionMarket: optionMarket,\\n      strikeId: position.strikeId,\\n      positionId: position.positionId,\\n      iterations: _parseUint8(params >> 16),\\n      currentCollateral: 0,\\n      setCollateralTo: 0,\\n      optionType: position.optionType,\\n      amount: _parseUint64Amount(params >> 120),\\n      minCost: 0,\\n      maxCost: _parseUint32Amount(params >> 56),\\n      inputAmount: _convertDecimal(_parseUint32(params >> 88), inputAsset),\\n      inputAsset: inputAsset\\n    });\\n\\n    ReturnDetails memory returnDetails = _openPosition(positionParams);\\n    totalCost = returnDetails.totalCost;\\n  }\\n\\n  /**\\n   * @param params Is a compressed uint which contains the following fields:\\n   * loc | type   | name         | description\\n   * ------------------------------------------\\n   * 0   | uint8  | market       | Market id as set in `addMarket`\\n   * 8   | uint8  | token        | InputAsset id as set in `addCurveStable` to be used\\n   * 16  | uint8  | iterations   | Number of iterations for the trade to make. Avoid 3 due to rounding.\\n   * 24  | bool   | isForceClose | Whether the size closed uses `forceClosePosition`\\n   * 32  | uint32 | positionId   | Decreasing the size of this position id\\n   * 64  | uint32 | inputAmount  | The amount the user is sending into the contract (compressed to 1 d.p.)\\n   * 96  | uint64 | size         | The amount of options the user is removing from the position (compressed to 8 d.p.)\\n   * 160 | uint32 | minReceived  | The minimum amount the user willing to receive for the options closed\\n   * Total 192 bits\\n   */\\n  function reduceLong(uint params) external returns (uint totalReceived) {\\n    OptionMarket optionMarket = idToMarket[uint8(params)];\\n    OptionMarketContracts memory c = marketContracts[optionMarket];\\n    OptionToken.PositionWithOwner memory position = c.optionToken.getPositionWithOwner(uint(uint32(params >> 32)));\\n    ERC20 inputAsset = idToERC[uint8(params >> 8)];\\n\\n    OptionPositionParams memory positionParams = OptionPositionParams({\\n      optionMarket: optionMarket,\\n      strikeId: position.strikeId,\\n      positionId: position.positionId,\\n      iterations: _parseUint8(params >> 16),\\n      currentCollateral: 0,\\n      setCollateralTo: 0,\\n      optionType: position.optionType,\\n      amount: _parseUint64Amount(params >> 96),\\n      minCost: _parseUint32Amount(params >> 160),\\n      maxCost: type(uint).max,\\n      inputAmount: _convertDecimal(_parseUint32(params >> 64), inputAsset),\\n      inputAsset: inputAsset\\n    });\\n\\n    ReturnDetails memory returnDetails = _closePosition(positionParams, (uint8(params >> 24) > 0));\\n    totalReceived = returnDetails.totalCost;\\n  }\\n\\n  /**\\n   * @param params Is a compressed uint which contains the following fields:\\n   * loc | type   | name         | description\\n   * ------------------------------------------\\n   * 0   | uint8  | market       | Market id as set in `addMarket`\\n   * 8   | uint8  | token        | InputAsset id as set in `addCurveStable` to be used\\n   * 16  | uint8  | iterations   | Number of iterations for the trade to make. Avoid 3 due to rounding.\\n   * 24  | bool   | isForceClose | Whether the position closed uses `forceClosePosition`\\n   * 32  | uint32 | positionId   | Closing this position id\\n   * 64  | uint32 | inputAmount  | The amount the user is sending into the contract (compressed to 1 d.p.)\\n   * 96  | uint32 | minReceived  | The minimum amount the user willing to receive for the options closed\\n   * Total 128 bits\\n   */\\n  function closeLong(uint params) external returns (uint totalReceived) {\\n    OptionMarket optionMarket = idToMarket[uint8(params)];\\n    OptionMarketContracts memory c = marketContracts[optionMarket];\\n    OptionToken.PositionWithOwner memory position = c.optionToken.getPositionWithOwner(uint(uint32(params >> 32)));\\n    ERC20 inputAsset = idToERC[uint8(params >> 8)];\\n\\n    OptionPositionParams memory positionParams = OptionPositionParams({\\n      optionMarket: optionMarket,\\n      strikeId: position.strikeId,\\n      positionId: position.positionId,\\n      iterations: _parseUint8(params >> 16),\\n      currentCollateral: 0,\\n      setCollateralTo: 0,\\n      optionType: position.optionType,\\n      amount: position.amount,\\n      minCost: _parseUint32Amount(params >> 96),\\n      maxCost: type(uint).max,\\n      inputAmount: _convertDecimal(_parseUint32(params >> 64), inputAsset),\\n      inputAsset: inputAsset\\n    });\\n\\n    ReturnDetails memory returnDetails = _closePosition(positionParams, (uint8(params >> 24) > 0));\\n    totalReceived = returnDetails.totalCost;\\n  }\\n\\n  /**\\n   * @param params Is a compressed uint which contains the following fields:\\n   * loc | type   | name         | description\\n   * ------------------------------------------\\n   * 0   | uint8  | market       | Market id as set in `addMarket`\\n   * 8   | uint8  | token        | InputAsset id as set in `addCurveStable` to be used\\n   * 16  | uint8  | optionType   | Type of short option to be traded defined in `OptionType` enum\\n   * 24  | uint8  | iterations   | Number of iterations for the trade to make. Avoid 3 due to rounding.\\n   * 32  | uint32 | strikeId     | The strikeId to be traded\\n   * 64  | uint32 | minReceived  | The minimum amount the user willing to receive for the options\\n   * 96  | uint32 | inputAmount  | The amount the user is sending into the contract (compressed to 1 d.p.)\\n   * 128 | uint64 | size         | The amount of options the user is purchasing (compressed to 8 d.p.)\\n   * 192 | uint64 | collateral   | The amount of collateral used for the position\\n   * Total 256 bits\\n   */\\n  function openShort(uint params) external returns (uint totalReceived) {\\n    ERC20 inputAsset = idToERC[uint8(params >> 8)];\\n\\n    OptionPositionParams memory positionParams = OptionPositionParams({\\n      optionMarket: idToMarket[uint8(params)],\\n      strikeId: uint(uint32(params >> 32)),\\n      positionId: 0,\\n      iterations: _parseUint8(params >> 24),\\n      currentCollateral: 0,\\n      setCollateralTo: _parseUint64Amount(params >> 192),\\n      optionType: OptionMarket.OptionType(uint8(params >> 16)),\\n      amount: _parseUint64Amount(params >> 128),\\n      minCost: _parseUint32Amount(params >> 64),\\n      maxCost: type(uint).max,\\n      inputAmount: _convertDecimal(_parseUint32(params >> 96), inputAsset),\\n      inputAsset: inputAsset\\n    });\\n\\n    if (_isLong(positionParams.optionType)) {\\n      revert OnlyShorts(address(this), positionParams.optionType);\\n    }\\n\\n    ReturnDetails memory returnDetails = _openPosition(positionParams);\\n    totalReceived = returnDetails.totalCost;\\n  }\\n\\n  /**\\n   * @param params Is a compressed uint which contains the following fields:\\n   * loc | type   | name         | description\\n   * ------------------------------------------\\n   * 0   | uint8  | market       | Market id as set in `addMarket`\\n   * 8   | uint8  | token        | InputAsset id as set in `addCurveStable` to be used\\n   * 16  | uint8  | iterations   | Number of iterations for the trade to make. Avoid 3 due to rounding.\\n   * 24  | uint32 | positionId   | Increasing the size of this position id\\n   * 56  | uint32 | inputAmount  | The amount the user is sending into the contract (compressed to 1 d.p.)\\n   * 88  | uint32 | minReceived  | The minimum amount the user willing to receive for the options\\n   * 120 | uint64 | size         | The amount of options the user is purchasing (compressed to 8 d.p.)\\n   * 184 | uint64 | collateral   | The amount of absolute collateral used for the total position\\n   * Total 248 bits\\n   */\\n  function addShort(uint params) external returns (uint totalReceived) {\\n    OptionMarket optionMarket = idToMarket[uint8(params)];\\n    OptionMarketContracts memory c = marketContracts[optionMarket];\\n    OptionToken.PositionWithOwner memory position = c.optionToken.getPositionWithOwner(uint(uint32(params >> 24)));\\n    ERC20 inputAsset = idToERC[uint8(params >> 8)];\\n\\n    OptionPositionParams memory positionParams = OptionPositionParams({\\n      optionMarket: optionMarket,\\n      strikeId: position.strikeId,\\n      positionId: position.positionId,\\n      iterations: _parseUint8(params >> 16),\\n      setCollateralTo: _parseUint64Amount(params >> 184),\\n      currentCollateral: position.collateral,\\n      optionType: position.optionType,\\n      amount: _parseUint64Amount(params >> 120),\\n      minCost: _parseUint32Amount(params >> 88),\\n      maxCost: type(uint).max,\\n      inputAmount: _convertDecimal(_parseUint32(params >> 56), inputAsset),\\n      inputAsset: inputAsset\\n    });\\n\\n    ReturnDetails memory returnDetails = _openPosition(positionParams);\\n    totalReceived = returnDetails.totalCost;\\n  }\\n\\n  /**\\n   * @param params Is a compressed uint which contains the following fields:\\n   * loc | type   | name         | description\\n   * ------------------------------------------\\n   * 0   | uint8  | market       | Market id as set in `addMarket`\\n   * 8   | uint8  | token        | InputAsset id as set in `addCurveStable` to be used\\n   * 16  | uint8  | iterations   | Number of iterations for the trade to make. Avoid 3 due to rounding.\\n   * 24  | bool   | isForceClose | Whether the size closed uses `forceClosePosition`\\n   * 32  | uint32 | positionId   | Decreasing the size of this position id\\n   * 64  | uint32 | inputAmount  | The amount the user is sending into the contract (compressed to 1 d.p.)\\n   * 96  | uint32 | maxCost      | The maximum amount the user will pay for all the options closed\\n   * 128 | uint64 | size         | The amount of options the user is purchasing (compressed to 8 d.p.)\\n   * 196 | uint64 | collateral   | The amount of absolute collateral used for the total position\\n   * Total 256 bits\\n   */\\n  function reduceShort(uint params) external returns (uint totalCost) {\\n    OptionMarket optionMarket = idToMarket[uint8(params)];\\n    OptionMarketContracts memory c = marketContracts[optionMarket];\\n    OptionToken.PositionWithOwner memory position = c.optionToken.getPositionWithOwner(uint(uint32(params >> 32)));\\n    ERC20 inputAsset = idToERC[uint8(params >> 8)];\\n\\n    OptionPositionParams memory positionParams = OptionPositionParams({\\n      optionMarket: optionMarket,\\n      strikeId: position.strikeId,\\n      positionId: position.positionId,\\n      iterations: _parseUint8(params >> 16),\\n      setCollateralTo: _parseUint64Amount(params >> 196),\\n      currentCollateral: position.collateral,\\n      optionType: position.optionType,\\n      amount: _parseUint64Amount(params >> 128),\\n      minCost: 0,\\n      maxCost: _parseUint32Amount(params >> 96),\\n      inputAmount: _convertDecimal(_parseUint32(params >> 64), inputAsset),\\n      inputAsset: inputAsset\\n    });\\n\\n    ReturnDetails memory returnDetails = _closePosition(positionParams, (uint8(params >> 24) > 0));\\n    totalCost = returnDetails.totalCost;\\n  }\\n\\n  /**\\n   * @param params Is a compressed uint which contains the following fields:\\n   * loc | type   | name         | description\\n   * ------------------------------------------\\n   * 0   | uint8  | market       | Market id as set in `addMarket`\\n   * 8   | uint8  | token        | InputAsset id as set in `addCurveStable` to be used\\n   * 16  | uint8  | iterations   | Number of iterations for the trade to make. Avoid 3 due to rounding.\\n   * 24  | bool   | isForceClose | Whether the position closed uses `forceClosePosition`\\n   * 32  | uint32 | positionId   | Closing this position id\\n   * 64  | uint32 | inputAmount  | The amount the user is sending into the contract (compressed to 1 d.p.)\\n   * 96  | uint32 | maxCost      | The maximum amount the user will pay for all the options closed\\n   * Total 128 bits\\n   */\\n  function closeShort(uint params) external returns (uint totalCost) {\\n    OptionMarket optionMarket = idToMarket[uint8(params)];\\n    OptionMarketContracts memory c = marketContracts[optionMarket];\\n    OptionToken.PositionWithOwner memory position = c.optionToken.getPositionWithOwner(uint(uint32(params >> 32)));\\n\\n    ERC20 inputAsset = idToERC[uint8(params >> 8)];\\n    OptionPositionParams memory positionParams = OptionPositionParams({\\n      optionMarket: optionMarket,\\n      strikeId: position.strikeId,\\n      positionId: position.positionId,\\n      iterations: _parseUint8(params >> 16),\\n      currentCollateral: position.collateral,\\n      setCollateralTo: 0,\\n      optionType: position.optionType,\\n      amount: position.amount,\\n      minCost: 0,\\n      maxCost: _parseUint32Amount(params >> 96),\\n      inputAmount: _convertDecimal(_parseUint32(params >> 64), inputAsset),\\n      inputAsset: inputAsset\\n    });\\n\\n    ReturnDetails memory returnDetails = _closePosition(positionParams, (uint8(params >> 24) > 0));\\n    totalCost = returnDetails.totalCost;\\n  }\\n\\n  ///////////\\n  // Utils //\\n  ///////////\\n\\n  function _parseUint8(uint inp) internal pure returns (uint) {\\n    return uint(uint8(inp));\\n  }\\n\\n  function _parseUint32Amount(uint inp) internal pure returns (uint) {\\n    return _parseUint32(inp) * 1e16;\\n  }\\n\\n  function _parseUint32(uint inp) internal pure returns (uint) {\\n    return uint(uint32(inp));\\n  }\\n\\n  function _parseUint64Amount(uint inp) internal pure returns (uint) {\\n    return uint(uint64(inp)) * 1e10;\\n  }\\n\\n  function _convertDecimal(uint amount, ERC20 inputAsset) internal view returns (uint newAmount) {\\n    newAmount = amount * (10**(cachedDecimals[inputAsset] - 2)); // 2 dp\\n  }\\n\\n  ////////////\\n  // Errors //\\n  ////////////\\n\\n  error OnlyShorts(address thrower, OptionMarket.OptionType optionType);\\n}\\n\",\"keccak256\":\"0x689d0cfcfae3c2e41dca54bcf6ff7a0bf4781043abafcb59f9afa34cc233e5fc\",\"license\":\"ISC\"},\"@lyrafinance/protocol/contracts/periphery/Wrapper/OptionMarketWrapperWithSwaps.sol\":{\"content\":\"//SPDX-License-Identifier: ISC\\npragma solidity 0.8.9;\\n\\n// Libraries\\nimport \\\"../../synthetix/DecimalMath.sol\\\";\\n\\n// Interfaces\\nimport \\\"openzeppelin-contracts-4.4.1/token/ERC20/ERC20.sol\\\";\\nimport \\\"../../OptionMarket.sol\\\";\\nimport \\\"../../OptionToken.sol\\\";\\nimport \\\"../../LiquidityPool.sol\\\";\\nimport \\\"../../LiquidityToken.sol\\\";\\nimport \\\"../../interfaces/ICurve.sol\\\";\\nimport \\\"../../interfaces/IFeeCounter.sol\\\";\\n\\n// Inherited\\nimport \\\"../../synthetix/Owned.sol\\\";\\n\\n/**\\n * @title OptionMarketWrapper\\n * @author Lyra\\n * @dev Allows users to open/close positions in any market with multiple stablecoins\\n */\\ncontract OptionMarketWrapperWithSwaps is Owned {\\n  using DecimalMath for uint;\\n\\n  ///////////////////\\n  // Internal Data //\\n  ///////////////////\\n\\n  struct OptionMarketContracts {\\n    ERC20 quoteAsset;\\n    ERC20 baseAsset;\\n    OptionToken optionToken;\\n    LiquidityPool liquidityPool;\\n    LiquidityToken liquidityToken;\\n  }\\n\\n  struct OptionPositionParams {\\n    OptionMarket optionMarket;\\n    uint strikeId; // The id of the relevant OptionListing\\n    uint positionId;\\n    uint iterations;\\n    uint setCollateralTo;\\n    uint currentCollateral;\\n    OptionMarket.OptionType optionType; // Is the trade a long/short & call/put?\\n    uint amount; // The amount the user has requested to close\\n    uint minCost; // Min amount for the cost of the trade\\n    uint maxCost; // Max amount for the cost of the trade\\n    uint inputAmount; // Amount of stable coins the user can use\\n    ERC20 inputAsset; // Address of coin user wants to open with\\n  }\\n\\n  struct ReturnDetails {\\n    address market;\\n    uint positionId;\\n    address owner;\\n    uint amount;\\n    uint totalCost;\\n    uint totalFee;\\n    int swapFee;\\n    address token;\\n  }\\n\\n  struct StableAssetView {\\n    uint8 id;\\n    address token;\\n    uint8 decimals;\\n    string symbol;\\n    uint balance;\\n    uint allowance;\\n  }\\n\\n  struct MarketAssetView {\\n    uint8 id;\\n    OptionMarket market;\\n    address token;\\n    uint8 decimals;\\n    string symbol;\\n    uint balance;\\n    uint allowance;\\n    bool isApprovedForAll;\\n  }\\n\\n  struct LiquidityBalanceAndAllowance {\\n    address token;\\n    uint balance;\\n    uint allowance;\\n  }\\n\\n  ///////////////\\n  // Variables //\\n  ///////////////\\n\\n  ICurve public curveSwap;\\n  SynthetixAdapter public synthetixAdapter;\\n  IFeeCounter public tradingRewards;\\n  uint public minReturnPercent = 9.8e17;\\n  uint8[] public ercIds;\\n  mapping(uint8 => ERC20) public idToERC;\\n  uint8[] public marketIds;\\n  mapping(uint8 => OptionMarket) public idToMarket;\\n  mapping(OptionMarket => OptionMarketContracts) public marketContracts;\\n\\n  // Assume these can't change, so if cached, assume value is correct\\n  mapping(ERC20 => uint8) internal cachedDecimals;\\n  mapping(ERC20 => string) internal cachedSymbol;\\n\\n  constructor() Owned() {}\\n\\n  /**\\n   * @dev Initialises the contract\\n   *\\n   * @param _curveSwap The Curve contract address\\n   */\\n  function updateContractParams(\\n    ICurve _curveSwap,\\n    SynthetixAdapter _synthetixAdapter,\\n    IFeeCounter _tradingRewards,\\n    uint _minReturnPercent\\n  ) external onlyOwner {\\n    curveSwap = _curveSwap;\\n    synthetixAdapter = _synthetixAdapter;\\n    tradingRewards = _tradingRewards;\\n    minReturnPercent = _minReturnPercent;\\n    emit WrapperParamsUpdated(_curveSwap, _synthetixAdapter, _tradingRewards, _minReturnPercent);\\n  }\\n\\n  /////////////////////\\n  // Admin functions //\\n  /////////////////////\\n\\n  /**\\n   * @dev Adds stablecoin with desired index reflected in the curve contract\\n   *\\n   * @param token Address of the stablecoin\\n   * @param id Desired id to set the stablecoin\\n   */\\n  function addCurveStable(ERC20 token, uint8 id) external onlyOwner {\\n    _approveAsset(token, address(curveSwap));\\n    for (uint i = 0; i < ercIds.length; i++) {\\n      if (idToERC[ercIds[i]] == token || ercIds[i] == id) {\\n        revert DuplicateEntry(address(this), id, address(token));\\n      }\\n    }\\n    ercIds.push(id);\\n    idToERC[id] = token;\\n\\n    cachedDecimals[token] = token.decimals();\\n    cachedSymbol[token] = token.symbol();\\n  }\\n\\n  function removeCurveStable(uint8 id) external onlyOwner {\\n    uint index = 0;\\n    bool found = false;\\n    for (uint i = 0; i < ercIds.length; i++) {\\n      if (ercIds[i] == id) {\\n        index = i;\\n        found = true;\\n        break;\\n      }\\n    }\\n    if (!found) {\\n      revert RemovingInvalidId(address(this), id);\\n    }\\n    ercIds[index] = ercIds[ercIds.length - 1];\\n    ercIds.pop();\\n    delete idToERC[id];\\n  }\\n\\n  function addMarket(\\n    OptionMarket optionMarket,\\n    uint8 id,\\n    OptionMarketContracts memory _marketContracts\\n  ) external onlyOwner {\\n    marketContracts[optionMarket] = _marketContracts;\\n\\n    _approveAsset(marketContracts[optionMarket].quoteAsset, address(optionMarket));\\n    _approveAsset(marketContracts[optionMarket].baseAsset, address(optionMarket));\\n\\n    for (uint i = 0; i < marketIds.length; i++) {\\n      if (idToMarket[marketIds[i]] == optionMarket || marketIds[i] == id) {\\n        revert DuplicateEntry(address(this), id, address(optionMarket));\\n      }\\n    }\\n\\n    cachedDecimals[_marketContracts.baseAsset] = _marketContracts.baseAsset.decimals();\\n    cachedSymbol[_marketContracts.baseAsset] = _marketContracts.baseAsset.symbol();\\n\\n    marketIds.push(id);\\n    idToMarket[id] = optionMarket;\\n  }\\n\\n  function removeMarket(uint8 id) external onlyOwner {\\n    uint index = 0;\\n    bool found = false;\\n    for (uint i = 0; i < marketIds.length; i++) {\\n      if (marketIds[i] == id) {\\n        index = i;\\n        found = true;\\n        break;\\n      }\\n    }\\n    if (!found) {\\n      revert RemovingInvalidId(address(this), id);\\n    }\\n    marketIds[index] = marketIds[marketIds.length - 1];\\n    marketIds.pop();\\n    delete marketContracts[idToMarket[id]];\\n    delete idToMarket[id];\\n  }\\n\\n  ////////////////////\\n  // User functions //\\n  ////////////////////\\n\\n  function openPosition(OptionPositionParams memory params) external returns (ReturnDetails memory returnDetails) {\\n    return _openPosition(params);\\n  }\\n\\n  function closePosition(OptionPositionParams memory params) external returns (ReturnDetails memory returnDetails) {\\n    return _closePosition(params, false);\\n  }\\n\\n  function forceClosePosition(OptionPositionParams memory params)\\n    external\\n    returns (ReturnDetails memory returnDetails)\\n  {\\n    return _closePosition(params, true);\\n  }\\n\\n  //////////////\\n  // Internal //\\n  //////////////\\n\\n  /**\\n   * @dev Attempts to open positions within bounds, reverts if the returned amount is outside of the accepted bounds.\\n   *\\n   * @param params The params required to open a position\\n   */\\n  function _openPosition(OptionPositionParams memory params) internal returns (ReturnDetails memory returnDetails) {\\n    OptionMarketContracts memory c = marketContracts[params.optionMarket];\\n    bool useOtherStable = params.inputAsset != c.quoteAsset;\\n    int swapFee = 0;\\n\\n    if (params.positionId != 0) {\\n      c.optionToken.transferFrom(msg.sender, address(this), params.positionId);\\n    }\\n\\n    _transferBaseCollateral(params.optionType, params.currentCollateral, params.setCollateralTo, c.baseAsset);\\n\\n    if (params.optionType != OptionMarket.OptionType.SHORT_CALL_BASE) {\\n      // You want to take outstanding collateral - minCost from user (should be inputAmount)\\n      _transferAsset(params.inputAsset, msg.sender, address(this), params.inputAmount);\\n\\n      if (useOtherStable && params.inputAmount != 0) {\\n        uint expected;\\n        if (!_isLong(params.optionType)) {\\n          uint collateralBalanceAfterTrade = params.currentCollateral + params.minCost;\\n          if (params.setCollateralTo > collateralBalanceAfterTrade) {\\n            expected = params.setCollateralTo - collateralBalanceAfterTrade;\\n          }\\n        } else {\\n          expected = params.maxCost;\\n        }\\n        if (expected > 0) {\\n          (, swapFee) = _swapWithCurve(params.inputAsset, c.quoteAsset, params.inputAmount, expected, address(this));\\n        }\\n      }\\n    }\\n\\n    // open position\\n    OptionMarket.TradeInputParameters memory tradeParameters = _composeTradeParams(params);\\n    OptionMarket.Result memory result = params.optionMarket.openPosition(tradeParameters);\\n\\n    // Increments trading rewards contract\\n    _incrementTradingRewards(\\n      address(params.optionMarket),\\n      msg.sender,\\n      tradeParameters.amount,\\n      result.totalCost,\\n      result.totalFee\\n    );\\n\\n    int addSwapFee = 0;\\n    (, addSwapFee) = _returnQuote(c.quoteAsset, params.inputAsset);\\n    swapFee += addSwapFee;\\n\\n    _returnBase(c.baseAsset, c.optionToken, result.positionId);\\n\\n    returnDetails = _getReturnDetails(params, result, swapFee);\\n    _emitEvent(returnDetails, true, _isLong(params.optionType));\\n  }\\n\\n  /**\\n   * @dev Attempts to close some amount of an open position within bounds, reverts if the returned amount is outside of\\n   * the accepted bounds.\\n   *\\n   * @param params The params required to open a position\\n   */\\n  function _closePosition(OptionPositionParams memory params, bool forceClose)\\n    internal\\n    returns (ReturnDetails memory returnDetails)\\n  {\\n    OptionMarketContracts memory c = marketContracts[params.optionMarket];\\n    bool useOtherStable = address(params.inputAsset) != address(c.quoteAsset);\\n    int swapFee = 0;\\n\\n    c.optionToken.transferFrom(msg.sender, address(this), params.positionId);\\n\\n    _transferBaseCollateral(params.optionType, params.currentCollateral, params.setCollateralTo, c.baseAsset);\\n\\n    if (!_isLong(params.optionType)) {\\n      _transferAsset(params.inputAsset, msg.sender, address(this), params.inputAmount);\\n\\n      if (useOtherStable) {\\n        uint expected = params.maxCost;\\n        if (params.optionType != OptionMarket.OptionType.SHORT_CALL_BASE) {\\n          uint collateralBalanceAfterTrade = params.maxCost > params.currentCollateral\\n            ? 0\\n            : params.currentCollateral - params.maxCost;\\n          if (params.setCollateralTo > collateralBalanceAfterTrade) {\\n            expected = params.setCollateralTo - collateralBalanceAfterTrade;\\n          } else if (!_isLong(params.optionType)) {\\n            expected = 0;\\n          }\\n        }\\n        if (expected > 0) {\\n          (, swapFee) = _swapWithCurve(params.inputAsset, c.quoteAsset, params.inputAmount, expected, address(this));\\n        }\\n      }\\n    }\\n\\n    OptionMarket.TradeInputParameters memory tradeParameters = _composeTradeParams(params);\\n    OptionMarket.Result memory result;\\n    if (forceClose) {\\n      result = params.optionMarket.forceClosePosition(tradeParameters);\\n    } else {\\n      result = params.optionMarket.closePosition(tradeParameters);\\n    }\\n\\n    // increments the fee counter for the user.\\n    _incrementTradingRewards(\\n      address(params.optionMarket),\\n      msg.sender,\\n      tradeParameters.amount,\\n      result.totalCost,\\n      result.totalFee\\n    );\\n\\n    int addSwapFee;\\n    (, addSwapFee) = _returnQuote(c.quoteAsset, params.inputAsset);\\n    swapFee += addSwapFee;\\n\\n    _returnBase(c.baseAsset, c.optionToken, result.positionId);\\n\\n    returnDetails = _getReturnDetails(params, result, swapFee);\\n    _emitEvent(returnDetails, false, _isLong(params.optionType));\\n  }\\n\\n  function _getReturnDetails(\\n    OptionPositionParams memory params,\\n    OptionMarket.Result memory result,\\n    int swapFee\\n  ) internal view returns (ReturnDetails memory) {\\n    return\\n      ReturnDetails({\\n        market: address(params.optionMarket),\\n        positionId: result.positionId,\\n        owner: msg.sender,\\n        amount: params.amount,\\n        totalCost: result.totalCost,\\n        totalFee: result.totalFee,\\n        swapFee: swapFee,\\n        token: address(params.inputAsset)\\n      });\\n  }\\n\\n  //////////\\n  // Misc //\\n  //////////\\n\\n  function getMarketAndErcIds() public view returns (uint8[] memory, uint8[] memory) {\\n    return (marketIds, ercIds);\\n  }\\n\\n  /**\\n   * @dev Returns addresses, balances and allowances of all supported tokens for a list of markets\\n   *\\n   * @param owner Owner of tokens\\n   */\\n  function getBalancesAndAllowances(address owner)\\n    external\\n    view\\n    returns (\\n      StableAssetView[] memory,\\n      MarketAssetView[] memory,\\n      LiquidityBalanceAndAllowance[] memory\\n    )\\n  {\\n    StableAssetView[] memory stableBalances = new StableAssetView[](ercIds.length);\\n    for (uint i = 0; i < ercIds.length; i++) {\\n      ERC20 token = idToERC[ercIds[i]];\\n      stableBalances[i] = StableAssetView({\\n        id: ercIds[i],\\n        decimals: cachedDecimals[token],\\n        symbol: cachedSymbol[token],\\n        token: address(token),\\n        balance: token.balanceOf(owner),\\n        allowance: token.allowance(owner, address(this))\\n      });\\n    }\\n    MarketAssetView[] memory marketBalances = new MarketAssetView[](marketIds.length);\\n    LiquidityBalanceAndAllowance[] memory liquidityTokenBalances = new LiquidityBalanceAndAllowance[](marketIds.length);\\n    for (uint i = 0; i < marketIds.length; i++) {\\n      OptionMarket market = idToMarket[marketIds[i]];\\n      OptionMarketContracts memory c = marketContracts[market];\\n      marketBalances[i] = MarketAssetView({\\n        id: marketIds[i],\\n        market: market,\\n        token: address(c.baseAsset),\\n        decimals: cachedDecimals[c.baseAsset],\\n        symbol: cachedSymbol[c.baseAsset],\\n        balance: c.baseAsset.balanceOf(owner),\\n        allowance: c.baseAsset.allowance(owner, address(this)),\\n        isApprovedForAll: c.optionToken.isApprovedForAll(owner, address(this))\\n      });\\n      liquidityTokenBalances[i].balance = c.liquidityToken.balanceOf(owner);\\n      liquidityTokenBalances[i].allowance = c.quoteAsset.allowance(owner, address(c.liquidityPool));\\n      liquidityTokenBalances[i].token = address(c.liquidityPool);\\n    }\\n    return (stableBalances, marketBalances, liquidityTokenBalances);\\n  }\\n\\n  /**\\n   * @dev Returns quote back in the desired stablecoin\\n   *\\n   * @param inputAsset Stablecoin to be returned\\n   */\\n  function _returnQuote(ERC20 quoteAsset, ERC20 inputAsset) internal returns (uint quoteBalance, int swapFee) {\\n    quoteBalance = quoteAsset.balanceOf(address(this));\\n\\n    if (quoteBalance > 0) {\\n      if (inputAsset != quoteAsset) {\\n        uint min = (minReturnPercent * 10**cachedDecimals[inputAsset]) / 10**cachedDecimals[quoteAsset];\\n        (, swapFee) = _swapWithCurve(\\n          quoteAsset,\\n          inputAsset,\\n          quoteBalance,\\n          quoteBalance.multiplyDecimal(min),\\n          address(this)\\n        );\\n        quoteBalance = inputAsset.balanceOf(address(this));\\n      }\\n      _transferAsset(inputAsset, address(this), msg.sender, quoteBalance);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns excess baseAsset back to user\\n   *\\n   * @param baseAsset Base asset to be returned\\n   * @param token OptionToken to check if active\\n   * @param positionId Is the positionId\\n   */\\n  function _returnBase(\\n    ERC20 baseAsset,\\n    OptionToken token,\\n    uint positionId\\n  ) internal {\\n    uint baseBalance = baseAsset.balanceOf(address(this));\\n    if (baseBalance > 0) {\\n      _transferAsset(baseAsset, address(this), msg.sender, baseBalance);\\n    }\\n\\n    if (token.getPositionState(positionId) == OptionToken.PositionState.ACTIVE) {\\n      token.transferFrom(address(this), msg.sender, positionId);\\n    }\\n  }\\n\\n  function _isLong(OptionMarket.OptionType optionType) internal pure returns (bool) {\\n    return (optionType < OptionMarket.OptionType.SHORT_CALL_BASE);\\n  }\\n\\n  /**\\n   * @dev Attempts to swap the input token with the desired stablecoin.\\n   *\\n   * @param from The token being swapped\\n   * @param to The token being received\\n   * @param amount Quantity of from being exchanged\\n   * @param expected Minimum quantity of to received in order for the transaction to succeed\\n   * @param receiver The receiving address of the tokens\\n   */\\n  function _swapWithCurve(\\n    ERC20 from,\\n    ERC20 to,\\n    uint amount,\\n    uint expected,\\n    // TODO: actually return directly to the user in some cases?\\n    address receiver\\n  ) internal returns (uint amountOut, int swapFee) {\\n    _checkValidStable(address(from));\\n    _checkValidStable(address(to));\\n\\n    uint8 toDec = cachedDecimals[to];\\n    uint8 fromDec = cachedDecimals[from];\\n    uint balStart = from.balanceOf(address(this));\\n\\n    amountOut = curveSwap.exchange_with_best_rate(address(from), address(to), amount, expected, receiver);\\n\\n    uint convertedAmtOut = amountOut;\\n    if (fromDec < toDec) {\\n      balStart = balStart * 10**(toDec - fromDec);\\n    } else if (fromDec > toDec) {\\n      convertedAmtOut = amountOut * 10**(fromDec - toDec);\\n    }\\n\\n    swapFee = SafeCast.toInt256(balStart) - SafeCast.toInt256(convertedAmtOut);\\n  }\\n\\n  /// @dev checks if the token is in the stablecoin mapping\\n  function _checkValidStable(address token) internal view returns (bool) {\\n    for (uint i = 0; i < ercIds.length; i++) {\\n      if (address(idToERC[ercIds[i]]) == token) {\\n        return true;\\n      }\\n    }\\n    revert UnsupportedToken(token);\\n  }\\n\\n  /// @dev returns amount of toToken after a swap\\n  /// @param amountIn the amount of input tokens for the swap\\n  /// @return pool the address of the swap pool\\n  /// @return amountOut the amount of output tokens for the swap\\n  function quoteCurveSwap(\\n    address fromToken,\\n    address toToken,\\n    uint amountIn\\n  ) external view returns (address pool, uint amountOut) {\\n    _checkValidStable(fromToken);\\n    _checkValidStable(toToken);\\n\\n    (pool, amountOut) = curveSwap.get_best_rate(fromToken, toToken, amountIn);\\n  }\\n\\n  function _transferBaseCollateral(\\n    OptionMarket.OptionType optionType,\\n    uint currentCollateral,\\n    uint setCollateralTo,\\n    ERC20 baseAsset\\n  ) internal {\\n    if (optionType == OptionMarket.OptionType.SHORT_CALL_BASE && setCollateralTo > currentCollateral) {\\n      _transferAsset(baseAsset, msg.sender, address(this), setCollateralTo - currentCollateral);\\n    }\\n  }\\n\\n  function _transferAsset(\\n    ERC20 asset,\\n    address from,\\n    address to,\\n    uint amount\\n  ) internal {\\n    bool success = false;\\n\\n    if (from == address(this)) {\\n      success = asset.transfer(to, amount);\\n    } else {\\n      success = asset.transferFrom(from, to, amount);\\n    }\\n\\n    if (!success) {\\n      revert AssetTransferFailed(address(this), asset, from, to, amount);\\n    }\\n  }\\n\\n  function _approveAsset(ERC20 asset, address approving) internal {\\n    // Some contracts require resetting approval to 0 first\\n    if (!asset.approve(approving, 0)) {\\n      revert ApprovalFailure(address(this), asset, approving, 0);\\n    }\\n    if (!asset.approve(approving, type(uint).max)) {\\n      revert ApprovalFailure(address(this), asset, approving, type(uint).max);\\n    }\\n  }\\n\\n  function _composeTradeParams(OptionPositionParams memory params)\\n    internal\\n    pure\\n    returns (OptionMarket.TradeInputParameters memory tradeParameters)\\n  {\\n    return\\n      OptionMarket.TradeInputParameters({\\n        strikeId: params.strikeId,\\n        positionId: params.positionId,\\n        iterations: params.iterations,\\n        optionType: params.optionType,\\n        amount: params.amount,\\n        setCollateralTo: params.setCollateralTo,\\n        minTotalCost: params.minCost,\\n        maxTotalCost: params.maxCost\\n      });\\n  }\\n\\n  function _emitEvent(\\n    ReturnDetails memory returnDetails,\\n    bool isOpen,\\n    bool isLong\\n  ) internal {\\n    emit PositionTraded(\\n      isOpen,\\n      isLong,\\n      returnDetails.market,\\n      returnDetails.positionId,\\n      returnDetails.owner,\\n      returnDetails.amount,\\n      returnDetails.totalCost,\\n      returnDetails.totalFee,\\n      returnDetails.swapFee,\\n      returnDetails.token\\n    );\\n  }\\n\\n  // @dev function increments the trading rewards contract.\\n  // makes a call to the trading rewards contract\\n  function _incrementTradingRewards(\\n    address market,\\n    address trader,\\n    uint amount,\\n    uint totalCost,\\n    uint totalFee\\n  ) internal {\\n    if (address(tradingRewards) != address(0)) {\\n      tradingRewards.trackFee(market, trader, amount, totalCost, totalFee);\\n    }\\n  }\\n\\n  ////////////\\n  // Events //\\n  ////////////\\n\\n  /**\\n   * @dev Emitted when a position is traded\\n   */\\n  event PositionTraded(\\n    bool isOpen,\\n    bool isLong,\\n    address indexed market,\\n    uint indexed positionId,\\n    address indexed owner,\\n    uint amount,\\n    uint totalCost,\\n    uint totalFee,\\n    int swapFee,\\n    address token\\n  );\\n\\n  /**\\n   * @dev Emitted when the contract parameters are updated\\n   */\\n  event WrapperParamsUpdated(\\n    ICurve curveSwap,\\n    SynthetixAdapter synthetixAdapter,\\n    IFeeCounter tradingRewards,\\n    uint minReturnPercent\\n  );\\n\\n  /**\\n   * @dev Emitted collateral is changed for a position\\n   */\\n  event SetCollateralTo(uint newCollateral);\\n\\n  ////////////\\n  // Errors //\\n  ////////////\\n\\n  error AssetTransferFailed(address thrower, ERC20 asset, address sender, address receiver, uint amount);\\n  error ApprovalFailure(address thrower, ERC20 asset, address approving, uint approvalAmount);\\n  error DuplicateEntry(address thrower, uint8 id, address addr);\\n  error RemovingInvalidId(address thrower, uint8 id);\\n  error UnsupportedToken(address asset);\\n}\\n\",\"keccak256\":\"0x0c2952b2859e7d101bb365b081b6327164430761cd743a852381aae70a97430f\",\"license\":\"ISC\"},\"@lyrafinance/protocol/contracts/synthetix/AbstractOwned.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\n//\\n//Copyright (c) 2019 Synthetix\\n//\\n//Permission is hereby granted, free of charge, to any person obtaining a copy\\n//of this software and associated documentation files (the \\\"Software\\\"), to deal\\n//in the Software without restriction, including without limitation the rights\\n//to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n//copies of the Software, and to permit persons to whom the Software is\\n//furnished to do so, subject to the following conditions:\\n//\\n//The above copyright notice and this permission notice shall be included in all\\n//copies or substantial portions of the Software.\\n//\\n//THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n//FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n//AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n//LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n//OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n//SOFTWARE.\\n\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title Owned\\n * @author Synthetix\\n * @dev Synthetix owned contract without constructor and custom errors\\n * @dev https://docs.synthetix.io/contracts/source/contracts/owned\\n */\\nabstract contract AbstractOwned {\\n  address public owner;\\n  address public nominatedOwner;\\n\\n  function nominateNewOwner(address _owner) external onlyOwner {\\n    nominatedOwner = _owner;\\n    emit OwnerNominated(_owner);\\n  }\\n\\n  function acceptOwnership() external {\\n    if (msg.sender != nominatedOwner) {\\n      revert OnlyNominatedOwner(address(this), msg.sender, nominatedOwner);\\n    }\\n    emit OwnerChanged(owner, nominatedOwner);\\n    owner = nominatedOwner;\\n    nominatedOwner = address(0);\\n  }\\n\\n  modifier onlyOwner() {\\n    _onlyOwner();\\n    _;\\n  }\\n\\n  function _onlyOwner() private view {\\n    if (msg.sender != owner) {\\n      revert OnlyOwner(address(this), msg.sender, owner);\\n    }\\n  }\\n\\n  event OwnerNominated(address newOwner);\\n  event OwnerChanged(address oldOwner, address newOwner);\\n\\n  ////////////\\n  // Errors //\\n  ////////////\\n  error OnlyOwner(address thrower, address caller, address owner);\\n  error OnlyNominatedOwner(address thrower, address caller, address nominatedOwner);\\n}\\n\",\"keccak256\":\"0x65a8b72ac2f352c2937de332355d7eb03efc7b6da78d42d3ae5d4fd6b0081ab6\",\"license\":\"MIT\"},\"@lyrafinance/protocol/contracts/synthetix/DecimalMath.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\n//\\n//Copyright (c) 2019 Synthetix\\n//\\n//Permission is hereby granted, free of charge, to any person obtaining a copy\\n//of this software and associated documentation files (the \\\"Software\\\"), to deal\\n//in the Software without restriction, including without limitation the rights\\n//to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n//copies of the Software, and to permit persons to whom the Software is\\n//furnished to do so, subject to the following conditions:\\n//\\n//The above copyright notice and this permission notice shall be included in all\\n//copies or substantial portions of the Software.\\n//\\n//THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n//FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n//AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n//LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n//OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n//SOFTWARE.\\n\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title DecimalMath\\n * @author Lyra\\n * @dev Modified synthetix SafeDecimalMath to include internal arithmetic underflow/overflow.\\n * @dev https://docs.synthetix.io/contracts/source/libraries/SafeDecimalMath/\\n */\\n\\nlibrary DecimalMath {\\n  /* Number of decimal places in the representations. */\\n  uint8 public constant decimals = 18;\\n  uint8 public constant highPrecisionDecimals = 27;\\n\\n  /* The number representing 1.0. */\\n  uint public constant UNIT = 10**uint(decimals);\\n\\n  /* The number representing 1.0 for higher fidelity numbers. */\\n  uint public constant PRECISE_UNIT = 10**uint(highPrecisionDecimals);\\n  uint private constant UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR = 10**uint(highPrecisionDecimals - decimals);\\n\\n  /**\\n   * @return Provides an interface to UNIT.\\n   */\\n  function unit() external pure returns (uint) {\\n    return UNIT;\\n  }\\n\\n  /**\\n   * @return Provides an interface to PRECISE_UNIT.\\n   */\\n  function preciseUnit() external pure returns (uint) {\\n    return PRECISE_UNIT;\\n  }\\n\\n  /**\\n   * @return The result of multiplying x and y, interpreting the operands as fixed-point\\n   * decimals.\\n   *\\n   * @dev A unit factor is divided out after the product of x and y is evaluated,\\n   * so that product must be less than 2**256. As this is an integer division,\\n   * the internal division always rounds down. This helps save on gas. Rounding\\n   * is more expensive on gas.\\n   */\\n  function multiplyDecimal(uint x, uint y) internal pure returns (uint) {\\n    /* Divide by UNIT to remove the extra factor introduced by the product. */\\n    return (x * y) / UNIT;\\n  }\\n\\n  /**\\n   * @return The result of safely multiplying x and y, interpreting the operands\\n   * as fixed-point decimals of the specified precision unit.\\n   *\\n   * @dev The operands should be in the form of a the specified unit factor which will be\\n   * divided out after the product of x and y is evaluated, so that product must be\\n   * less than 2**256.\\n   *\\n   * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\\n   * Rounding is useful when you need to retain fidelity for small decimal numbers\\n   * (eg. small fractions or percentages).\\n   */\\n  function _multiplyDecimalRound(\\n    uint x,\\n    uint y,\\n    uint precisionUnit\\n  ) private pure returns (uint) {\\n    /* Divide by UNIT to remove the extra factor introduced by the product. */\\n    uint quotientTimesTen = (x * y) / (precisionUnit / 10);\\n\\n    if (quotientTimesTen % 10 >= 5) {\\n      quotientTimesTen += 10;\\n    }\\n\\n    return quotientTimesTen / 10;\\n  }\\n\\n  /**\\n   * @return The result of safely multiplying x and y, interpreting the operands\\n   * as fixed-point decimals of a precise unit.\\n   *\\n   * @dev The operands should be in the precise unit factor which will be\\n   * divided out after the product of x and y is evaluated, so that product must be\\n   * less than 2**256.\\n   *\\n   * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\\n   * Rounding is useful when you need to retain fidelity for small decimal numbers\\n   * (eg. small fractions or percentages).\\n   */\\n  function multiplyDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\\n    return _multiplyDecimalRound(x, y, PRECISE_UNIT);\\n  }\\n\\n  /**\\n   * @return The result of safely multiplying x and y, interpreting the operands\\n   * as fixed-point decimals of a standard unit.\\n   *\\n   * @dev The operands should be in the standard unit factor which will be\\n   * divided out after the product of x and y is evaluated, so that product must be\\n   * less than 2**256.\\n   *\\n   * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\\n   * Rounding is useful when you need to retain fidelity for small decimal numbers\\n   * (eg. small fractions or percentages).\\n   */\\n  function multiplyDecimalRound(uint x, uint y) internal pure returns (uint) {\\n    return _multiplyDecimalRound(x, y, UNIT);\\n  }\\n\\n  /**\\n   * @return The result of safely dividing x and y. The return value is a high\\n   * precision decimal.\\n   *\\n   * @dev y is divided after the product of x and the standard precision unit\\n   * is evaluated, so the product of x and UNIT must be less than 2**256. As\\n   * this is an integer division, the result is always rounded down.\\n   * This helps save on gas. Rounding is more expensive on gas.\\n   */\\n  function divideDecimal(uint x, uint y) internal pure returns (uint) {\\n    /* Reintroduce the UNIT factor that will be divided out by y. */\\n    return (x * UNIT) / y;\\n  }\\n\\n  /**\\n   * @return The result of safely dividing x and y. The return value is as a rounded\\n   * decimal in the precision unit specified in the parameter.\\n   *\\n   * @dev y is divided after the product of x and the specified precision unit\\n   * is evaluated, so the product of x and the specified precision unit must\\n   * be less than 2**256. The result is rounded to the nearest increment.\\n   */\\n  function _divideDecimalRound(\\n    uint x,\\n    uint y,\\n    uint precisionUnit\\n  ) private pure returns (uint) {\\n    uint resultTimesTen = (x * (precisionUnit * 10)) / y;\\n\\n    if (resultTimesTen % 10 >= 5) {\\n      resultTimesTen += 10;\\n    }\\n\\n    return resultTimesTen / 10;\\n  }\\n\\n  /**\\n   * @return The result of safely dividing x and y. The return value is as a rounded\\n   * standard precision decimal.\\n   *\\n   * @dev y is divided after the product of x and the standard precision unit\\n   * is evaluated, so the product of x and the standard precision unit must\\n   * be less than 2**256. The result is rounded to the nearest increment.\\n   */\\n  function divideDecimalRound(uint x, uint y) internal pure returns (uint) {\\n    return _divideDecimalRound(x, y, UNIT);\\n  }\\n\\n  /**\\n   * @return The result of safely dividing x and y. The return value is as a rounded\\n   * high precision decimal.\\n   *\\n   * @dev y is divided after the product of x and the high precision unit\\n   * is evaluated, so the product of x and the high precision unit must\\n   * be less than 2**256. The result is rounded to the nearest increment.\\n   */\\n  function divideDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\\n    return _divideDecimalRound(x, y, PRECISE_UNIT);\\n  }\\n\\n  /**\\n   * @dev Convert a standard decimal representation to a high precision one.\\n   */\\n  function decimalToPreciseDecimal(uint i) internal pure returns (uint) {\\n    return i * UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR;\\n  }\\n\\n  /**\\n   * @dev Convert a high precision decimal to a standard decimal representation.\\n   */\\n  function preciseDecimalToDecimal(uint i) internal pure returns (uint) {\\n    uint quotientTimesTen = i / (UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR / 10);\\n\\n    if (quotientTimesTen % 10 >= 5) {\\n      quotientTimesTen += 10;\\n    }\\n\\n    return quotientTimesTen / 10;\\n  }\\n}\\n\",\"keccak256\":\"0x03f58e91e4df7956ec2b2ae893fa20bf0784ea9e03afbf3f76e514175a3a90b2\",\"license\":\"MIT\"},\"@lyrafinance/protocol/contracts/synthetix/Owned.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\n//\\n//Copyright (c) 2019 Synthetix\\n//\\n//Permission is hereby granted, free of charge, to any person obtaining a copy\\n//of this software and associated documentation files (the \\\"Software\\\"), to deal\\n//in the Software without restriction, including without limitation the rights\\n//to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n//copies of the Software, and to permit persons to whom the Software is\\n//furnished to do so, subject to the following conditions:\\n//\\n//The above copyright notice and this permission notice shall be included in all\\n//copies or substantial portions of the Software.\\n//\\n//THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n//FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n//AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n//LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n//OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n//SOFTWARE.\\n\\npragma solidity ^0.8.9;\\n\\nimport \\\"./AbstractOwned.sol\\\";\\n\\n/**\\n * @title Owned\\n * @author Synthetix\\n * @dev Slightly modified Synthetix owned contract, so that first owner is msg.sender\\n * @dev https://docs.synthetix.io/contracts/source/contracts/owned\\n */\\ncontract Owned is AbstractOwned {\\n  constructor() {\\n    owner = msg.sender;\\n    emit OwnerChanged(address(0), msg.sender);\\n  }\\n}\\n\",\"keccak256\":\"0x6db7bcf05e088a9474773d2c1da20be364aac72cea20bbce4e54d4086de6719a\",\"license\":\"MIT\"},\"@lyrafinance/protocol/contracts/synthetix/OwnedUpgradeable.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\n\\nimport \\\"openzeppelin-contracts-upgradeable-4.5.1/proxy/utils/Initializable.sol\\\";\\nimport \\\"./AbstractOwned.sol\\\";\\n\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title OwnedUpgradeable\\n * @author Lyra\\n * @dev Modified owned contract to allow for the owner to be initialised by the calling proxy\\n * @dev https://docs.synthetix.io/contracts/source/contracts/owned\\n */\\ncontract OwnedUpgradeable is AbstractOwned, Initializable {\\n  /**\\n   * @dev Initializes the contract setting the deployer as the initial owner.\\n   */\\n  function __Ownable_init() internal onlyInitializing {\\n    owner = msg.sender;\\n  }\\n}\\n\",\"keccak256\":\"0x4ec205a87d561fe22980727b604491d554477f558db78b34c394ac1a99913667\",\"license\":\"MIT\"},\"@lyrafinance/protocol/contracts/synthetix/SignedDecimalMath.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\n//\\n//Copyright (c) 2019 Synthetix\\n//\\n//Permission is hereby granted, free of charge, to any person obtaining a copy\\n//of this software and associated documentation files (the \\\"Software\\\"), to deal\\n//in the Software without restriction, including without limitation the rights\\n//to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n//copies of the Software, and to permit persons to whom the Software is\\n//furnished to do so, subject to the following conditions:\\n//\\n//The above copyright notice and this permission notice shall be included in all\\n//copies or substantial portions of the Software.\\n//\\n//THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n//FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n//AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n//LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n//OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n//SOFTWARE.\\n\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title SignedDecimalMath\\n * @author Lyra\\n * @dev Modified synthetix SafeSignedDecimalMath to include internal arithmetic underflow/overflow.\\n * @dev https://docs.synthetix.io/contracts/source/libraries/safedecimalmath\\n */\\nlibrary SignedDecimalMath {\\n  /* Number of decimal places in the representations. */\\n  uint8 public constant decimals = 18;\\n  uint8 public constant highPrecisionDecimals = 27;\\n\\n  /* The number representing 1.0. */\\n  int public constant UNIT = int(10**uint(decimals));\\n\\n  /* The number representing 1.0 for higher fidelity numbers. */\\n  int public constant PRECISE_UNIT = int(10**uint(highPrecisionDecimals));\\n  int private constant UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR = int(10**uint(highPrecisionDecimals - decimals));\\n\\n  /**\\n   * @return Provides an interface to UNIT.\\n   */\\n  function unit() external pure returns (int) {\\n    return UNIT;\\n  }\\n\\n  /**\\n   * @return Provides an interface to PRECISE_UNIT.\\n   */\\n  function preciseUnit() external pure returns (int) {\\n    return PRECISE_UNIT;\\n  }\\n\\n  /**\\n   * @dev Rounds an input with an extra zero of precision, returning the result without the extra zero.\\n   * Half increments round away from zero; positive numbers at a half increment are rounded up,\\n   * while negative such numbers are rounded down. This behaviour is designed to be consistent with the\\n   * unsigned version of this library (SafeDecimalMath).\\n   */\\n  function _roundDividingByTen(int valueTimesTen) private pure returns (int) {\\n    int increment;\\n    if (valueTimesTen % 10 >= 5) {\\n      increment = 10;\\n    } else if (valueTimesTen % 10 <= -5) {\\n      increment = -10;\\n    }\\n    return (valueTimesTen + increment) / 10;\\n  }\\n\\n  /**\\n   * @return The result of multiplying x and y, interpreting the operands as fixed-point\\n   * decimals.\\n   *\\n   * @dev A unit factor is divided out after the product of x and y is evaluated,\\n   * so that product must be less than 2**256. As this is an integer division,\\n   * the internal division always rounds down. This helps save on gas. Rounding\\n   * is more expensive on gas.\\n   */\\n  function multiplyDecimal(int x, int y) internal pure returns (int) {\\n    /* Divide by UNIT to remove the extra factor introduced by the product. */\\n    return (x * y) / UNIT;\\n  }\\n\\n  /**\\n   * @return The result of safely multiplying x and y, interpreting the operands\\n   * as fixed-point decimals of the specified precision unit.\\n   *\\n   * @dev The operands should be in the form of a the specified unit factor which will be\\n   * divided out after the product of x and y is evaluated, so that product must be\\n   * less than 2**256.\\n   *\\n   * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\\n   * Rounding is useful when you need to retain fidelity for small decimal numbers\\n   * (eg. small fractions or percentages).\\n   */\\n  function _multiplyDecimalRound(\\n    int x,\\n    int y,\\n    int precisionUnit\\n  ) private pure returns (int) {\\n    /* Divide by UNIT to remove the extra factor introduced by the product. */\\n    int quotientTimesTen = (x * y) / (precisionUnit / 10);\\n    return _roundDividingByTen(quotientTimesTen);\\n  }\\n\\n  /**\\n   * @return The result of safely multiplying x and y, interpreting the operands\\n   * as fixed-point decimals of a precise unit.\\n   *\\n   * @dev The operands should be in the precise unit factor which will be\\n   * divided out after the product of x and y is evaluated, so that product must be\\n   * less than 2**256.\\n   *\\n   * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\\n   * Rounding is useful when you need to retain fidelity for small decimal numbers\\n   * (eg. small fractions or percentages).\\n   */\\n  function multiplyDecimalRoundPrecise(int x, int y) internal pure returns (int) {\\n    return _multiplyDecimalRound(x, y, PRECISE_UNIT);\\n  }\\n\\n  /**\\n   * @return The result of safely multiplying x and y, interpreting the operands\\n   * as fixed-point decimals of a standard unit.\\n   *\\n   * @dev The operands should be in the standard unit factor which will be\\n   * divided out after the product of x and y is evaluated, so that product must be\\n   * less than 2**256.\\n   *\\n   * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\\n   * Rounding is useful when you need to retain fidelity for small decimal numbers\\n   * (eg. small fractions or percentages).\\n   */\\n  function multiplyDecimalRound(int x, int y) internal pure returns (int) {\\n    return _multiplyDecimalRound(x, y, UNIT);\\n  }\\n\\n  /**\\n   * @return The result of safely dividing x and y. The return value is a high\\n   * precision decimal.\\n   *\\n   * @dev y is divided after the product of x and the standard precision unit\\n   * is evaluated, so the product of x and UNIT must be less than 2**256. As\\n   * this is an integer division, the result is always rounded down.\\n   * This helps save on gas. Rounding is more expensive on gas.\\n   */\\n  function divideDecimal(int x, int y) internal pure returns (int) {\\n    /* Reintroduce the UNIT factor that will be divided out by y. */\\n    return (x * UNIT) / y;\\n  }\\n\\n  /**\\n   * @return The result of safely dividing x and y. The return value is as a rounded\\n   * decimal in the precision unit specified in the parameter.\\n   *\\n   * @dev y is divided after the product of x and the specified precision unit\\n   * is evaluated, so the product of x and the specified precision unit must\\n   * be less than 2**256. The result is rounded to the nearest increment.\\n   */\\n  function _divideDecimalRound(\\n    int x,\\n    int y,\\n    int precisionUnit\\n  ) private pure returns (int) {\\n    int resultTimesTen = (x * (precisionUnit * 10)) / y;\\n    return _roundDividingByTen(resultTimesTen);\\n  }\\n\\n  /**\\n   * @return The result of safely dividing x and y. The return value is as a rounded\\n   * standard precision decimal.\\n   *\\n   * @dev y is divided after the product of x and the standard precision unit\\n   * is evaluated, so the product of x and the standard precision unit must\\n   * be less than 2**256. The result is rounded to the nearest increment.\\n   */\\n  function divideDecimalRound(int x, int y) internal pure returns (int) {\\n    return _divideDecimalRound(x, y, UNIT);\\n  }\\n\\n  /**\\n   * @return The result of safely dividing x and y. The return value is as a rounded\\n   * high precision decimal.\\n   *\\n   * @dev y is divided after the product of x and the high precision unit\\n   * is evaluated, so the product of x and the high precision unit must\\n   * be less than 2**256. The result is rounded to the nearest increment.\\n   */\\n  function divideDecimalRoundPrecise(int x, int y) internal pure returns (int) {\\n    return _divideDecimalRound(x, y, PRECISE_UNIT);\\n  }\\n\\n  /**\\n   * @dev Convert a standard decimal representation to a high precision one.\\n   */\\n  function decimalToPreciseDecimal(int i) internal pure returns (int) {\\n    return i * UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR;\\n  }\\n\\n  /**\\n   * @dev Convert a high precision decimal to a standard decimal representation.\\n   */\\n  function preciseDecimalToDecimal(int i) internal pure returns (int) {\\n    int quotientTimesTen = i / (UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR / 10);\\n    return _roundDividingByTen(quotientTimesTen);\\n  }\\n}\\n\",\"keccak256\":\"0x7fac134730ad054cfa9f7a512bb3e54459fd9cf55f3cac1a3f0aefb5695a8cfc\",\"license\":\"MIT\"},\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0x24e0364e503a9bbde94c715d26573a76f14cd2a202d45f96f52134ab806b67b9\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() initializer {}\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\\n        // contract may have been reentered.\\n        require(_initializing ? _isConstructor() : !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} modifier, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    function _isConstructor() private view returns (bool) {\\n        return !Address.isContract(address(this));\\n    }\\n}\\n\",\"keccak256\":\"0x4823752b07b8ea4ca971b217e39457930e7cb103c2c91e2a29729e5ca907e4f0\",\"license\":\"MIT\"},\"@openzeppelin/contracts/security/ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\",\"keccak256\":\"0x0e9621f60b2faabe65549f7ed0f24e8853a45c1b7990d47e8160e523683f3935\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, _allowances[owner][spender] + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = _allowances[owner][spender];\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n        }\\n        _balances[to] += amount;\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Spend `amount` form the allowance of `owner` toward `spender`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\",\"keccak256\":\"0xdadd41acb749920eccf40aeaa8d291adf9751399a7343561bad13e7a8d99be0b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0xbbc8ac883ac3c0078ce5ad3e288fbb3ffcc8a30c3a98c0fda0114d64fc44fca2\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x8de418a5503946cabe331f35fe242d3201a73f67f77aaeb7110acb1f30423aca\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xc3d946432c0ddbb1f846a0d3985be71299df331b91d06732152117f62f0be2b5\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x2ccf9d2313a313d41a791505f2b5abfdc62191b5d4334f7f7a82691c088a1c87\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xa2f576be637946f767aa56601c26d717f48a0aff44f82e46f13807eea1009a21\",\"license\":\"MIT\"},\"contracts/core/BaseVault.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {SafeERC20} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport {ReentrancyGuard} from \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport {ERC20} from \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport {Initializable} from \\\"@openzeppelin/contracts/proxy/utils/Initializable.sol\\\";\\n\\nimport {Vault} from \\\"../libraries/Vault.sol\\\";\\nimport {VaultLifecycle} from \\\"../libraries/VaultLifecycle.sol\\\";\\nimport {ShareMath} from \\\"../libraries/ShareMath.sol\\\";\\n\\ncontract BaseVault is ReentrancyGuard, Ownable, ERC20, Initializable {\\n  using SafeERC20 for IERC20;\\n  using ShareMath for Vault.DepositReceipt;\\n\\n  /************************************************\\n   *  NON UPGRADEABLE STORAGE\\n   ***********************************************/\\n\\n  /// @notice Stores the user's pending deposit for the round\\n  mapping(address => Vault.DepositReceipt) public depositReceipts;\\n\\n  /// @notice On every round's close, the pricePerShare value of an rTHETA token is stored\\n  /// This is used to determine the number of shares to be returned\\n  /// to a user with their DepositReceipt.depositAmount\\n  mapping(uint => uint) public roundPricePerShare;\\n\\n  /// @notice Stores pending user withdrawals\\n  mapping(address => Vault.Withdrawal) public withdrawals;\\n\\n  /// @notice Vault's parameters like cap, decimals\\n  Vault.VaultParams public vaultParams;\\n\\n  /// @notice Vault's lifecycle state like round and locked amounts\\n  Vault.VaultState public vaultState;\\n\\n  /// @notice Fee recipient for the performance and management fees\\n  address public feeRecipient;\\n\\n  /// @notice Performance fee charged on premiums earned in rollToNextOption. Only charged when there is no loss.\\n  uint public performanceFee;\\n\\n  /// @notice Management fee charged on entire AUM in rollToNextOption. Only charged when there is no loss.\\n  uint public managementFee;\\n\\n  // Gap is left to avoid storage collisions. Though RibbonVault is not upgradeable, we add this as a safety measure.\\n  uint[30] private ____gap;\\n\\n  // *IMPORTANT* NO NEW STORAGE VARIABLES SHOULD BE ADDED HERE\\n  // This is to prevent storage collisions. All storage variables should be appended to RibbonThetaVaultStorage\\n  // or RibbonDeltaVaultStorage instead. Read this documentation to learn more:\\n  // https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#modifying-your-contracts\\n\\n  /************************************************\\n   *  IMMUTABLES & CONSTANTS\\n   ***********************************************/\\n\\n  // Round per year scaled up FEE_MULTIPLIER\\n  uint private immutable roundPerYear;\\n\\n  /************************************************\\n   *  EVENTS\\n   ***********************************************/\\n\\n  event Deposit(address indexed account, uint amount, uint round);\\n\\n  event InitiateWithdraw(address indexed account, uint shares, uint round);\\n\\n  event Redeem(address indexed account, uint share, uint round);\\n\\n  event ManagementFeeSet(uint managementFee, uint newManagementFee);\\n\\n  event PerformanceFeeSet(uint performanceFee, uint newPerformanceFee);\\n\\n  event CapSet(uint oldCap, uint newCap, address manager);\\n\\n  event Withdraw(address indexed account, uint amount, uint shares);\\n\\n  event CollectVaultFees(uint performanceFee, uint vaultFee, uint round, address indexed feeRecipient);\\n\\n  /************************************************\\n   *  CONSTRUCTOR & INITIALIZATION\\n   ***********************************************/\\n\\n  /**\\n   * @notice Initializes the contract with immutable variables\\n   */\\n  constructor(\\n    address _feeRecipient,\\n    uint _roundDuration,\\n    string memory _tokenName,\\n    string memory _tokenSymbol,\\n    Vault.VaultParams memory _vaultParams\\n  ) ERC20(_tokenName, _tokenSymbol) {\\n    feeRecipient = _feeRecipient;\\n    uint _roundPerYear = (uint(365 days) * Vault.FEE_MULTIPLIER) / _roundDuration;\\n    roundPerYear = _roundPerYear;\\n    vaultParams = _vaultParams;\\n\\n    uint assetBalance = IERC20(vaultParams.asset).balanceOf(address(this));\\n    ShareMath.assertUint104(assetBalance);\\n    vaultState.lastLockedAmount = uint104(assetBalance);\\n    vaultState.round = 1;\\n  }\\n\\n  /************************************************\\n   *  SETTERS\\n   ***********************************************/\\n\\n  /**\\n   * @notice Sets the new fee recipient\\n   * @param newFeeRecipient is the address of the new fee recipient\\n   */\\n  function setFeeRecipient(address newFeeRecipient) external onlyOwner {\\n    require(newFeeRecipient != address(0), \\\"!newFeeRecipient\\\");\\n    require(newFeeRecipient != feeRecipient, \\\"Must be new feeRecipient\\\");\\n    feeRecipient = newFeeRecipient;\\n  }\\n\\n  /**\\n   * @notice Sets the management fee for the vault\\n   * @param newManagementFee is the management fee (6 decimals). ex: 2 * 10 ** 6 = 2%\\n   */\\n  function setManagementFee(uint newManagementFee) external onlyOwner {\\n    require(newManagementFee < 100 * Vault.FEE_MULTIPLIER, \\\"Invalid management fee\\\");\\n\\n    emit ManagementFeeSet(managementFee, newManagementFee);\\n\\n    // We are dividing annualized management fee by number of rounds in a year\\n    managementFee = (newManagementFee * Vault.FEE_MULTIPLIER) / roundPerYear;\\n  }\\n\\n  /**\\n   * @notice Sets the performance fee for the vault\\n   * @param newPerformanceFee is the performance fee (6 decimals). ex: 20 * 10 ** 6 = 20%\\n   */\\n  function setPerformanceFee(uint newPerformanceFee) external onlyOwner {\\n    require(newPerformanceFee < 100 * Vault.FEE_MULTIPLIER, \\\"Invalid performance fee\\\");\\n\\n    emit PerformanceFeeSet(performanceFee, newPerformanceFee);\\n\\n    performanceFee = newPerformanceFee;\\n  }\\n\\n  /**\\n   * @notice Sets a new cap for deposits\\n   * @param newCap is the new cap for deposits\\n   */\\n  function setCap(uint newCap) external onlyOwner {\\n    require(newCap > 0, \\\"!newCap\\\");\\n\\n    emit CapSet(vaultParams.cap, newCap, msg.sender);\\n\\n    ShareMath.assertUint104(newCap);\\n    vaultParams.cap = uint104(newCap);\\n  }\\n\\n  /************************************************\\n   *  DEPOSIT & WITHDRAWALS\\n   ***********************************************/\\n\\n  /**\\n   * @notice Deposits the `asset` from msg.sender.\\n   * @param amount is the amount of `asset` to deposit\\n   */\\n  function deposit(uint amount) external nonReentrant {\\n    require(amount > 0, \\\"!amount\\\");\\n\\n    _depositFor(amount, msg.sender);\\n\\n    // An approve() by the msg.sender is required beforehand\\n    IERC20(vaultParams.asset).safeTransferFrom(msg.sender, address(this), amount);\\n  }\\n\\n  /**\\n   * @notice Deposits the `asset` from msg.sender added to `creditor`'s deposit.\\n   * @notice Used for vault -> vault deposits on the user's behalf\\n   * @param amount is the amount of `asset` to deposit\\n   * @param creditor is the address that can claim/withdraw deposited amount\\n   */\\n  function depositFor(uint amount, address creditor) external nonReentrant {\\n    require(amount > 0, \\\"!amount\\\");\\n    require(creditor != address(0), \\\"!creditor\\\");\\n\\n    _depositFor(amount, creditor);\\n\\n    // An approve() by the msg.sender is required beforehand\\n    IERC20(vaultParams.asset).safeTransferFrom(msg.sender, address(this), amount);\\n  }\\n\\n  /**\\n   * @notice Mints the vault shares to the creditor\\n   * @param amount is the amount of `asset` deposited\\n   * @param creditor is the address to receieve the deposit\\n   */\\n  function _depositFor(uint amount, address creditor) private {\\n    uint currentRound = vaultState.round;\\n    uint totalWithDepositedAmount = totalBalance() + amount;\\n\\n    require(totalWithDepositedAmount <= vaultParams.cap, \\\"Exceed cap\\\");\\n\\n    emit Deposit(creditor, amount, currentRound);\\n\\n    Vault.DepositReceipt memory depositReceipt = depositReceipts[creditor];\\n\\n    // process unprocessed pending deposit from the previous rounds\\n    uint unredeemedShares = depositReceipt.getSharesFromReceipt(\\n      currentRound,\\n      roundPricePerShare[depositReceipt.round],\\n      vaultParams.decimals\\n    );\\n\\n    uint depositAmount = amount;\\n\\n    // If we have a pending deposit in the current round, we add on to the pending deposit\\n    if (currentRound == depositReceipt.round) {\\n      uint newAmount = uint(depositReceipt.amount) + amount;\\n      depositAmount = newAmount;\\n    }\\n\\n    ShareMath.assertUint104(depositAmount);\\n\\n    depositReceipts[creditor] = Vault.DepositReceipt({\\n      round: uint16(currentRound),\\n      amount: uint104(depositAmount),\\n      unredeemedShares: uint128(unredeemedShares)\\n    });\\n\\n    uint newTotalPending = uint(vaultState.totalPending) + amount;\\n    ShareMath.assertUint128(newTotalPending);\\n\\n    vaultState.totalPending = uint128(newTotalPending);\\n  }\\n\\n  /**\\n   * @notice Initiates a withdrawal that can be processed once the round completes\\n   * @param numShares is the number of shares to withdraw\\n   */\\n  function initiateWithdraw(uint numShares) external nonReentrant {\\n    require(numShares > 0, \\\"!numShares\\\");\\n\\n    // We do a max redeem before initiating a withdrawal\\n    // But we check if they must first have unredeemed shares\\n    if (depositReceipts[msg.sender].amount > 0 || depositReceipts[msg.sender].unredeemedShares > 0) {\\n      _redeem(0, true);\\n    }\\n\\n    // This caches the `round` variable used in shareBalances\\n    uint currentRound = vaultState.round;\\n    Vault.Withdrawal storage withdrawal = withdrawals[msg.sender];\\n\\n    bool withdrawalIsSameRound = withdrawal.round == currentRound;\\n\\n    emit InitiateWithdraw(msg.sender, numShares, currentRound);\\n\\n    uint existingShares = uint(withdrawal.shares);\\n\\n    uint withdrawalShares;\\n    if (withdrawalIsSameRound) {\\n      withdrawalShares = existingShares + numShares;\\n    } else {\\n      require(existingShares == 0, \\\"Existing withdraw\\\");\\n      withdrawalShares = numShares;\\n      withdrawals[msg.sender].round = uint16(currentRound);\\n    }\\n\\n    ShareMath.assertUint128(withdrawalShares);\\n    withdrawals[msg.sender].shares = uint128(withdrawalShares);\\n\\n    uint newQueuedWithdrawShares = uint(vaultState.queuedWithdrawShares) + numShares;\\n    ShareMath.assertUint128(newQueuedWithdrawShares);\\n    vaultState.queuedWithdrawShares = uint128(newQueuedWithdrawShares);\\n\\n    _transfer(msg.sender, address(this), numShares);\\n  }\\n\\n  /**\\n   * @notice Completes a scheduled withdrawal from a past round. Uses finalized pps for the round\\n   */\\n  function completeWithdraw() external nonReentrant {\\n    Vault.Withdrawal storage withdrawal = withdrawals[msg.sender];\\n\\n    uint withdrawalShares = withdrawal.shares;\\n    uint withdrawalRound = withdrawal.round;\\n\\n    // This checks if there is a withdrawal\\n    require(withdrawalShares > 0, \\\"Not initiated\\\");\\n\\n    require(withdrawalRound < vaultState.round, \\\"Round in progress\\\");\\n\\n    // We leave the round number as non-zero to save on gas for subsequent writes\\n    withdrawals[msg.sender].shares = 0;\\n    vaultState.queuedWithdrawShares = uint128(uint(vaultState.queuedWithdrawShares) - withdrawalShares);\\n\\n    uint withdrawAmount = ShareMath.sharesToAsset(\\n      withdrawalShares,\\n      roundPricePerShare[withdrawalRound],\\n      vaultParams.decimals\\n    );\\n\\n    emit Withdraw(msg.sender, withdrawAmount, withdrawalShares);\\n\\n    _burn(address(this), withdrawalShares);\\n\\n    require(withdrawAmount > 0, \\\"!withdrawAmount\\\");\\n\\n    _transferAsset(msg.sender, withdrawAmount);\\n  }\\n\\n  /**\\n   * @notice Redeems shares that are owed to the account\\n   * @param numShares is the number of shares to redeem\\n   */\\n  function redeem(uint numShares) external nonReentrant {\\n    require(numShares > 0, \\\"!numShares\\\");\\n    _redeem(numShares, false);\\n  }\\n\\n  /**\\n   * @notice Redeems the entire unredeemedShares balance that is owed to the account\\n   */\\n  function maxRedeem() external nonReentrant {\\n    _redeem(0, true);\\n  }\\n\\n  /**\\n   * @notice Redeems shares that are owed to the account\\n   * @param numShares is the number of shares to redeem, could be 0 when isMax=true\\n   * @param isMax is flag for when callers do a max redemption\\n   */\\n  function _redeem(uint numShares, bool isMax) internal {\\n    Vault.DepositReceipt memory depositReceipt = depositReceipts[msg.sender];\\n\\n    // This handles the null case when depositReceipt.round = 0\\n    // Because we start with round = 1 at `initialize`\\n    uint currentRound = vaultState.round;\\n\\n    uint unredeemedShares = depositReceipt.getSharesFromReceipt(\\n      currentRound,\\n      roundPricePerShare[depositReceipt.round],\\n      vaultParams.decimals\\n    );\\n\\n    numShares = isMax ? unredeemedShares : numShares;\\n    if (numShares == 0) {\\n      return;\\n    }\\n    require(numShares <= unredeemedShares, \\\"Exceeds available\\\");\\n\\n    // If we have a depositReceipt on the same round, BUT we have some unredeemed shares\\n    // we debit from the unredeemedShares, but leave the amount field intact\\n    // If the round has past, with no new deposits, we just zero it out for new deposits.\\n    depositReceipts[msg.sender].amount = depositReceipt.round < currentRound ? 0 : depositReceipt.amount;\\n\\n    ShareMath.assertUint128(numShares);\\n    depositReceipts[msg.sender].unredeemedShares = uint128(unredeemedShares - numShares);\\n\\n    emit Redeem(msg.sender, numShares, depositReceipt.round);\\n\\n    _transfer(address(this), msg.sender, numShares);\\n  }\\n\\n  /************************************************\\n   *  VAULT OPERATIONS\\n   ***********************************************/\\n\\n  /*\\n   * @notice Helper function that performs most administrative tasks\\n   * such as setting next option, minting new shares, getting vault fees, etc.\\n   * @param lastQueuedWithdrawAmount is old queued withdraw amount\\n   * @return lockedBalance is the new balance used to calculate next option purchase size or collateral size\\n   * @return queuedWithdrawAmount is the new queued withdraw amount for this round\\n   */\\n  function _rollToNextRound(uint lastQueuedWithdrawAmount) internal returns (uint, uint) {\\n    (uint lockedBalance, uint queuedWithdrawAmount, uint newPricePerShare, uint mintShares) = VaultLifecycle.rollover(\\n      totalSupply(),\\n      vaultParams.asset,\\n      vaultParams.decimals,\\n      uint(vaultState.totalPending),\\n      vaultState.queuedWithdrawShares\\n    );\\n\\n    // Finalize the pricePerShare at the end of the round\\n    uint currentRound = vaultState.round;\\n    roundPricePerShare[currentRound] = newPricePerShare;\\n\\n    uint withdrawAmountDiff = queuedWithdrawAmount > lastQueuedWithdrawAmount\\n      ? queuedWithdrawAmount - lastQueuedWithdrawAmount\\n      : 0;\\n\\n    // Take management / performance fee from previous round and deduct\\n    lockedBalance = lockedBalance - _collectVaultFees(lockedBalance + withdrawAmountDiff);\\n\\n    // update round info\\n    vaultState.totalPending = 0;\\n    vaultState.round = uint16(currentRound + 1);\\n\\n    _mint(address(this), mintShares);\\n\\n    return (lockedBalance, queuedWithdrawAmount);\\n  }\\n\\n  /*\\n   * @notice Helper function that transfers management fees and performance fees from previous round.\\n   * @param pastWeekBalance is the balance we are about to lock for next round\\n   * @return vaultFee is the fee deducted\\n   */\\n  function _collectVaultFees(uint pastWeekBalance) internal returns (uint) {\\n    (uint performanceFeeInAsset, , uint vaultFee) = VaultLifecycle.getVaultFees(\\n      vaultState,\\n      pastWeekBalance,\\n      performanceFee,\\n      managementFee\\n    );\\n\\n    if (vaultFee > 0) {\\n      _transferAsset(payable(feeRecipient), vaultFee);\\n      emit CollectVaultFees(performanceFeeInAsset, vaultFee, vaultState.round, feeRecipient);\\n    }\\n\\n    return vaultFee;\\n  }\\n\\n  /**\\n   * @notice Helper function to make either an ETH transfer or ERC20 transfer\\n   * @param recipient is the receiving address\\n   * @param amount is the transfer amount\\n   */\\n  function _transferAsset(address recipient, uint amount) internal {\\n    address asset = vaultParams.asset;\\n    IERC20(asset).safeTransfer(recipient, amount);\\n  }\\n\\n  /************************************************\\n   *  GETTERS\\n   ***********************************************/\\n\\n  /**\\n   * @notice Returns the asset balance held on the vault for the account\\n   * @param account is the address to lookup balance for\\n   * @return the amount of `asset` custodied by the vault for the user\\n   */\\n  function accountVaultBalance(address account) external view returns (uint) {\\n    uint _decimals = vaultParams.decimals;\\n    uint assetPerShare = ShareMath.pricePerShare(totalSupply(), totalBalance(), vaultState.totalPending, _decimals);\\n    return ShareMath.sharesToAsset(shares(account), assetPerShare, _decimals);\\n  }\\n\\n  /**\\n   * @notice Getter for returning the account's share balance including unredeemed shares\\n   * @param account is the account to lookup share balance for\\n   * @return the share balance\\n   */\\n  function shares(address account) public view returns (uint) {\\n    (uint heldByAccount, uint heldByVault) = shareBalances(account);\\n    return heldByAccount + heldByVault;\\n  }\\n\\n  /**\\n   * @notice Getter for returning the account's share balance split between account and vault holdings\\n   * @param account is the account to lookup share balance for\\n   * @return heldByAccount is the shares held by account\\n   * @return heldByVault is the shares held on the vault (unredeemedShares)\\n   */\\n  function shareBalances(address account) public view returns (uint heldByAccount, uint heldByVault) {\\n    Vault.DepositReceipt memory depositReceipt = depositReceipts[account];\\n\\n    if (depositReceipt.round == 0) {\\n      return (balanceOf(account), 0);\\n    }\\n\\n    uint unredeemedShares = depositReceipt.getSharesFromReceipt(\\n      vaultState.round,\\n      roundPricePerShare[depositReceipt.round],\\n      vaultParams.decimals\\n    );\\n\\n    return (balanceOf(account), unredeemedShares);\\n  }\\n\\n  /**\\n   * @notice The price of a unit of share denominated in the `asset`\\n   */\\n  function pricePerShare() external view returns (uint) {\\n    return ShareMath.pricePerShare(totalSupply(), totalBalance(), vaultState.totalPending, vaultParams.decimals);\\n  }\\n\\n  /**\\n   * @notice Returns the vault's total balance, including the amounts locked into a short position\\n   * @return total balance of the vault, including the amounts locked in third party protocols\\n   */\\n  function totalBalance() public view returns (uint) {\\n    return\\n      uint(vaultState.lockedAmount - vaultState.lockedAmountLeft) + IERC20(vaultParams.asset).balanceOf(address(this));\\n  }\\n\\n  /**\\n   * @notice Returns the token decimals\\n   */\\n  function decimals() public view override returns (uint8) {\\n    return vaultParams.decimals;\\n  }\\n}\\n\",\"keccak256\":\"0x161bb74ce2ab4b7d7fc490678875f527b92eca9fbb9fc0a8e66c91d8ea674e0f\",\"license\":\"MIT\"},\"contracts/core/LyraVault.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport {BaseVault} from \\\"./BaseVault.sol\\\";\\nimport {Vault} from \\\"../libraries/Vault.sol\\\";\\n\\nimport {IStrategy} from \\\"../interfaces/IStrategy.sol\\\";\\n\\n/// @notice LyraVault help users run option-selling strategies on Lyra AMM.\\ncontract LyraVault is Ownable, BaseVault {\\n  IERC20 public immutable premiumAsset;\\n  IERC20 public immutable collateralAsset;\\n\\n  IStrategy public strategy;\\n  address public lyraRewardRecipient;\\n\\n  // Amount locked for scheduled withdrawals last week;\\n  uint public lastQueuedWithdrawAmount;\\n  // % of funds to be used for weekly option purchase\\n  uint public optionAllocation;\\n\\n  event StrategyUpdated(address strategy);\\n\\n  event Trade(address user, uint positionId, uint premium, uint capitalUsed);\\n\\n  event RoundStarted(uint16 roundId, uint104 lockAmount);\\n\\n  event RoundClosed(uint16 roundId, uint104 lockAmount);\\n\\n  constructor(\\n    address _susd,\\n    address _feeRecipient,\\n    uint _roundDuration,\\n    string memory _tokenName,\\n    string memory _tokenSymbol,\\n    Vault.VaultParams memory _vaultParams\\n  ) BaseVault(_feeRecipient, _roundDuration, _tokenName, _tokenSymbol, _vaultParams) {\\n    premiumAsset = IERC20(_susd);\\n    collateralAsset = IERC20(_vaultParams.asset);\\n  }\\n\\n  /// @dev set strategy contract. This function can only be called by owner.\\n  /// @param _strategy new strategy contract address\\n  function setStrategy(address _strategy) external onlyOwner {\\n    if (address(strategy) != address(0)) {\\n      collateralAsset.approve(address(strategy), 0);\\n    }\\n\\n    strategy = IStrategy(_strategy);\\n    collateralAsset.approve(_strategy, type(uint).max);\\n    emit StrategyUpdated(_strategy);\\n  }\\n\\n  /// @dev anyone can trigger a trade\\n  /// @param strikeId the strike id to sell\\n  function trade(uint strikeId) external {\\n    require(vaultState.roundInProgress, \\\"round closed\\\");\\n    // perform trade through strategy\\n    (uint positionId, uint premiumReceived, uint capitalUsed) = strategy.doTrade(strikeId, lyraRewardRecipient);\\n\\n    // update the remaining locked amount\\n    vaultState.lockedAmountLeft = vaultState.lockedAmountLeft - capitalUsed;\\n\\n    // todo: udpate events\\n    emit Trade(msg.sender, positionId, premiumReceived, capitalUsed);\\n  }\\n\\n  /// @dev anyone close part of the position with premium made by the strategy if a position is dangerous\\n  /// @param positionId the positiion to close\\n  function reducePosition(uint positionId, uint closeAmount) external {\\n    strategy.reducePosition(positionId, closeAmount, lyraRewardRecipient);\\n  }\\n\\n  /// @dev close the current round, enable user to deposit for the next round\\n  function closeRound() external {\\n    require(strategy.activeExpiry() < block.timestamp, \\\"cannot close round if board not expired\\\");\\n    require(vaultState.roundInProgress, \\\"round closed\\\");\\n\\n    uint104 lockAmount = vaultState.lockedAmount;\\n    vaultState.lastLockedAmount = lockAmount;\\n    vaultState.lockedAmountLeft = 0;\\n    vaultState.lockedAmount = 0;\\n    vaultState.nextRoundReadyTimestamp = block.timestamp + Vault.ROUND_DELAY;\\n    vaultState.roundInProgress = false;\\n\\n    // won't be able to close if positions are not settled\\n    strategy.returnFundsAndClearStrikes();\\n\\n    emit RoundClosed(vaultState.round, lockAmount);\\n  }\\n\\n  /// @dev Close the current round, enable user to deposit for the next round\\n  //       Can call multiple times before round starts to close all positions\\n  function emergencyCloseRound() external onlyOwner {\\n    require(vaultState.roundInProgress, \\\"round closed\\\");\\n\\n    uint104 lockAmount = vaultState.lockedAmount;\\n    vaultState.lastLockedAmount = lockAmount;\\n    vaultState.lockedAmountLeft = 0;\\n    vaultState.lockedAmount = 0;\\n    vaultState.nextRoundReadyTimestamp = block.timestamp + Vault.ROUND_DELAY;\\n    vaultState.roundInProgress = false;\\n\\n    strategy.emergencyCloseAll(lyraRewardRecipient);\\n    emit RoundClosed(vaultState.round, lockAmount);\\n  }\\n\\n  /// @notice start the next round\\n  /// @param boardId board id (asset + expiry) for next round.\\n  function startNextRound(uint boardId) external onlyOwner {\\n    require(!vaultState.roundInProgress, \\\"round in progress\\\");\\n    require(block.timestamp > vaultState.nextRoundReadyTimestamp, \\\"CD\\\");\\n\\n    strategy.setBoard(boardId);\\n\\n    (uint lockedBalance, uint queuedWithdrawAmount) = _rollToNextRound(lastQueuedWithdrawAmount);\\n\\n    vaultState.lockedAmount = uint104(lockedBalance);\\n    vaultState.lockedAmountLeft = lockedBalance;\\n    vaultState.roundInProgress = true;\\n    lastQueuedWithdrawAmount = queuedWithdrawAmount;\\n\\n    emit RoundStarted(vaultState.round, uint104(lockedBalance));\\n  }\\n\\n  /// @notice set set new address to receive Lyra trading reward on behalf of the vault\\n  /// @param recipient recipient address\\n  function setLyraRewardRecipient(address recipient) external onlyOwner {\\n    lyraRewardRecipient = recipient;\\n  }\\n}\\n\",\"keccak256\":\"0xd8e852661d5547ba00b4335d1236b12508b32835fac46107c7c635b1c40b0359\",\"license\":\"MIT\"},\"contracts/interfaces/IERC20Detailed.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IERC20Detailed is IERC20 {\\n  function decimals() external view returns (uint8);\\n\\n  function symbol() external view returns (string calldata);\\n\\n  function name() external view returns (string calldata);\\n}\\n\",\"keccak256\":\"0x98fdc868b087fd38e413b31c1687bb9a3ed756d975795e259ba066ff4a1ac3b8\",\"license\":\"MIT\"},\"contracts/interfaces/IStrategy.sol\":{\"content\":\"//SPDX-License-Identifier:MIT\\npragma solidity ^0.8.9;\\n\\ninterface IStrategy {\\n  function activeExpiry() external returns (uint);\\n\\n  function setBoard(uint boardId) external;\\n\\n  function doTrade(uint strikeId, address rewardRecipient)\\n    external\\n    returns (\\n      uint positionId,\\n      uint premium,\\n      uint collateralAdded\\n    );\\n\\n  function reducePosition(\\n    uint positionId,\\n    uint closeAmount,\\n    address rewardRecipient\\n  ) external;\\n\\n  function emergencyCloseAll(address lyraRewardRecipient) external;\\n\\n  function returnFundsAndClearStrikes() external;\\n}\\n\",\"keccak256\":\"0x924ce8d0f4b7047484cb610d6016f39ce953dc898ec68cf1f1cf3aef78c19925\",\"license\":\"MIT\"},\"contracts/libraries/ShareMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport {Vault} from \\\"./Vault.sol\\\";\\n\\nlibrary ShareMath {\\n  function assetToShares(\\n    uint assetAmount,\\n    uint assetPerShare,\\n    uint decimals\\n  ) internal pure returns (uint) {\\n    // If this throws, it means that vault's roundPricePerShare[currentRound] has not been set yet\\n    // which should never happen.\\n    require(assetPerShare > 0, \\\"Invalid assetPerShare\\\");\\n\\n    return (assetAmount * (10**decimals)) / (assetPerShare);\\n  }\\n\\n  function sharesToAsset(\\n    uint shares,\\n    uint assetPerShare,\\n    uint decimals\\n  ) internal pure returns (uint) {\\n    // If this throws, it means that vault's roundPricePerShare[currentRound] has not been set yet\\n    // which should never happen.\\n    require(assetPerShare > 0, \\\"Invalid assetPerShare\\\");\\n\\n    return (shares * assetPerShare) / (10**decimals);\\n  }\\n\\n  /**\\n   * @notice Returns the shares unredeemed by the user given their DepositReceipt\\n   * @param depositReceipt is the user's deposit receipt\\n   * @param currentRound is the `round` stored on the vault\\n   * @param assetPerShare is the price in asset per share\\n   * @param decimals is the number of decimals the asset/shares use\\n   * @return unredeemedShares is the user's virtual balance of shares that are owed\\n   */\\n  function getSharesFromReceipt(\\n    Vault.DepositReceipt memory depositReceipt,\\n    uint currentRound,\\n    uint assetPerShare,\\n    uint decimals\\n  ) internal pure returns (uint unredeemedShares) {\\n    if (depositReceipt.round > 0 && depositReceipt.round < currentRound) {\\n      uint sharesFromRound = assetToShares(depositReceipt.amount, assetPerShare, decimals);\\n\\n      return uint(depositReceipt.unredeemedShares) + sharesFromRound;\\n    }\\n    return depositReceipt.unredeemedShares;\\n  }\\n\\n  function pricePerShare(\\n    uint totalSupply,\\n    uint totalBalance,\\n    uint pendingAmount,\\n    uint decimals\\n  ) internal pure returns (uint) {\\n    uint singleShare = 10**decimals;\\n    return totalSupply > 0 ? (singleShare * (totalBalance - pendingAmount)) / (totalSupply) : singleShare;\\n  }\\n\\n  /************************************************\\n   *  HELPERS\\n   ***********************************************/\\n\\n  function assertUint104(uint num) internal pure {\\n    require(num <= type(uint104).max, \\\"Overflow uint104\\\");\\n  }\\n\\n  function assertUint128(uint num) internal pure {\\n    require(num <= type(uint128).max, \\\"Overflow uint128\\\");\\n  }\\n}\\n\",\"keccak256\":\"0xa4bc80db31e67f2b3695c1e0ff2130b71ba7b5ab45cf760a0574a12a079a6b70\",\"license\":\"MIT\"},\"contracts/libraries/Vault.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nlibrary Vault {\\n  /************************************************\\n   *  IMMUTABLES & CONSTANTS\\n   ***********************************************/\\n\\n  // Fees are 6-decimal places. For example: 20 * 10**6 = 20%\\n  uint internal constant FEE_MULTIPLIER = 10**6;\\n\\n  uint internal constant ROUND_DELAY = 1 days;\\n\\n  struct VaultParams {\\n    // Token decimals for vault shares\\n    uint8 decimals;\\n    // Vault cap\\n    uint104 cap;\\n    // Asset used in Theta / Delta Vault\\n    address asset;\\n  }\\n\\n  struct VaultState {\\n    // 32 byte slot 1\\n    //  Current round number. `round` represents the number of `period`s elapsed.\\n    uint16 round;\\n    // Amount that is currently locked for the strategy\\n    uint104 lockedAmount;\\n    // Amount that was locked for strategy in the previous round\\n    // used for calculating performance fee deduction\\n    uint104 lastLockedAmount;\\n    // locked amount left to be used for collateral;\\n    uint lockedAmountLeft;\\n    // 32 byte slot 2\\n    // Stores the total tally of how much of `asset` there is\\n    // to be used to mint rTHETA tokens\\n    uint128 totalPending;\\n    // Amount locked for scheduled withdrawals;\\n    uint128 queuedWithdrawShares;\\n    // The timestamp next round will be ready to start\\n    uint nextRoundReadyTimestamp;\\n    // true if the current round is in progress, false if the round is idle\\n    bool roundInProgress;\\n  }\\n\\n  struct DepositReceipt {\\n    // Maximum of 65535 rounds. Assuming 1 round is 7 days, maximum is 1256 years.\\n    uint16 round;\\n    // Deposit amount, max 20,282,409,603,651 or 20 trillion ETH deposit\\n    uint104 amount;\\n    // Unredeemed shares balance\\n    uint128 unredeemedShares;\\n  }\\n\\n  struct Withdrawal {\\n    // Maximum of 65535 rounds. Assuming 1 round is 7 days, maximum is 1256 years.\\n    uint16 round;\\n    // Number of shares withdrawn\\n    uint128 shares;\\n  }\\n}\\n\",\"keccak256\":\"0x8da4207bd6804b6d00e2dc8913218297a725525c55138afdf5ee7c41404516e1\",\"license\":\"MIT\"},\"contracts/libraries/VaultLifecycle.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport {SafeMath} from \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {Vault} from \\\"./Vault.sol\\\";\\nimport {ShareMath} from \\\"./ShareMath.sol\\\";\\n\\nimport {IERC20Detailed} from \\\"../interfaces/IERC20Detailed.sol\\\";\\nimport {SafeERC20} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n\\nimport \\\"hardhat/console.sol\\\";\\n\\n/**\\n * @dev copied from Ribbon's VaultLifeCycle, changed to internal library for gas optimization\\n */\\nlibrary VaultLifecycle {\\n  using SafeMath for uint;\\n  using SafeERC20 for IERC20;\\n\\n  /**\\n   * @notice Calculate the shares to mint, new price per share,\\n   *         and amount of funds to re-allocate as collateral for the new round\\n   * @param currentShareSupply is the total supply of shares\\n   * @param asset is the address of the vault's asset\\n   * @param decimals is the decimals of the asset\\n   * @param pendingAmount is the amount of funds pending from recent deposits\\n   * @return newLockedAmount is the amount of funds to allocate for the new round\\n   * @return queuedWithdrawAmount is the amount of funds set aside for withdrawal\\n   * @return newPricePerShare is the price per share of the new round\\n   * @return mintShares is the amount of shares to mint from deposits\\n   */\\n  function rollover(\\n    uint currentShareSupply,\\n    address asset,\\n    uint decimals,\\n    uint pendingAmount,\\n    uint queuedWithdrawShares\\n  )\\n    internal\\n    view\\n    returns (\\n      uint newLockedAmount,\\n      uint queuedWithdrawAmount,\\n      uint newPricePerShare,\\n      uint mintShares\\n    )\\n  {\\n    uint currentBalance = IERC20(asset).balanceOf(address(this));\\n\\n    newPricePerShare = ShareMath.pricePerShare(currentShareSupply, currentBalance, pendingAmount, decimals);\\n\\n    // After closing the short, if the options expire in-the-money\\n    // vault pricePerShare would go down because vault's asset balance decreased.\\n    // This ensures that the newly-minted shares do not take on the loss.\\n    uint _mintShares = ShareMath.assetToShares(pendingAmount, newPricePerShare, decimals);\\n\\n    uint newSupply = currentShareSupply.add(_mintShares);\\n\\n    uint queuedWithdraw = newSupply > 0 ? ShareMath.sharesToAsset(queuedWithdrawShares, newPricePerShare, decimals) : 0;\\n\\n    return (currentBalance.sub(queuedWithdraw), queuedWithdraw, newPricePerShare, _mintShares);\\n  }\\n\\n  /**\\n   * @notice Calculates the performance and management fee for this week's round\\n   * @param vaultState is the struct with vault accounting state\\n   * @param currentLockedBalance is the amount of funds currently locked in opyn\\n   * @param performanceFeePercent is the performance fee pct.\\n   * @param managementFeePercent is the management fee pct.\\n   * @return performanceFeeInAsset is the performance fee\\n   * @return managementFeeInAsset is the management fee\\n   * @return vaultFee is the total fees\\n   */\\n  function getVaultFees(\\n    Vault.VaultState storage vaultState,\\n    uint currentLockedBalance,\\n    uint performanceFeePercent,\\n    uint managementFeePercent\\n  )\\n    internal\\n    view\\n    returns (\\n      uint performanceFeeInAsset,\\n      uint managementFeeInAsset,\\n      uint vaultFee\\n    )\\n  {\\n    uint prevLockedAmount = vaultState.lastLockedAmount;\\n\\n    uint lockedBalanceSansPending = currentLockedBalance.sub(vaultState.totalPending);\\n\\n    uint _performanceFeeInAsset;\\n    uint _managementFeeInAsset;\\n    uint _vaultFee;\\n\\n    // Take performance fee and management fee ONLY if difference between\\n    // last week and this week's vault deposits, taking into account pending\\n    // deposits and withdrawals, is positive. If it is negative, last week's\\n    // option expired ITM past breakeven, and the vault took a loss so we\\n    // do not collect performance fee for last week\\n\\n    // todo: update management fee to exclude profit?\\n    if (lockedBalanceSansPending > prevLockedAmount) {\\n      _performanceFeeInAsset = performanceFeePercent > 0\\n        ? lockedBalanceSansPending.sub(prevLockedAmount).mul(performanceFeePercent).div(100 * Vault.FEE_MULTIPLIER)\\n        : 0;\\n      _managementFeeInAsset = managementFeePercent > 0\\n        ? lockedBalanceSansPending.mul(managementFeePercent).div(100 * Vault.FEE_MULTIPLIER)\\n        : 0;\\n\\n      _vaultFee = _performanceFeeInAsset.add(_managementFeeInAsset);\\n    }\\n\\n    return (_performanceFeeInAsset, _managementFeeInAsset, _vaultFee);\\n  }\\n}\\n\",\"keccak256\":\"0x1f90ddf54d54c3828fb077d0eec47b940d3fdca21a52ddc7e50935f4dc5404fc\",\"license\":\"MIT\"},\"contracts/strategies/DeltaShortStrategy.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n// Hardhat\\nimport \\\"hardhat/console.sol\\\";\\n\\n// standard strategy interface\\nimport \\\"../interfaces/IStrategy.sol\\\";\\n\\n// Libraries\\nimport {Vault} from \\\"../libraries/Vault.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {LyraVault} from \\\"../core/LyraVault.sol\\\";\\nimport {DecimalMath} from \\\"@lyrafinance/protocol/contracts/synthetix/DecimalMath.sol\\\";\\nimport {SignedDecimalMath} from \\\"@lyrafinance/protocol/contracts/synthetix/SignedDecimalMath.sol\\\";\\n\\n// StrategyBase to inherit\\nimport {StrategyBase} from \\\"./StrategyBase.sol\\\";\\n\\ncontract DeltaShortStrategy is StrategyBase, IStrategy {\\n  using DecimalMath for uint;\\n  using SignedDecimalMath for int;\\n\\n  // example strategy detail\\n  struct DeltaShortStrategyDetail {\\n    uint minTimeToExpiry; // minimum board expiry\\n    uint maxTimeToExpiry; // maximum board expiry\\n    int targetDelta; // ideal option delta to trade\\n    uint maxDeltaGap; // max diff between targetDelta and option delta\\n    uint minVol; // min option volatility required\\n    uint maxVol; // max option volatility required\\n    uint size; // amount of options to sell per LyraVault.trade()\\n    uint minTradeInterval; // min seconds between LyraVault.trade() calls\\n    uint maxVolVariance; // max deviation from GWAV vol and option volatility\\n    uint gwavPeriod; // gwav period used when calculating GWAV vol\\n    uint collatBuffer; // multiple of vaultAdapter.minCollateral(): 1.1 -> 110% * minCollat\\n    uint collatPercent; // partial collateral: 0.9 -> 90% * fullCollat\\n  }\\n\\n  DeltaShortStrategyDetail public strategyDetail;\\n  uint public activeExpiry;\\n\\n  ///////////\\n  // ADMIN //\\n  ///////////\\n\\n  constructor(LyraVault _vault, OptionType _optionType) StrategyBase(_vault, _optionType) {}\\n\\n  /**\\n   * @dev update the strategy detail for the new round.\\n   */\\n  function setStrategyDetail(DeltaShortStrategyDetail memory _deltaStrategy) external onlyOwner {\\n    (, , , , , , , bool roundInProgress) = vault.vaultState();\\n    require(!roundInProgress, \\\"cannot change strategy if round is active\\\");\\n    strategyDetail = _deltaStrategy;\\n  }\\n\\n  /**\\n   * @dev set the board id that will be traded for the next round\\n   * @param boardId lyra board Id.\\n   */\\n  function setBoard(uint boardId) external onlyVault {\\n    Board memory board = _getBoard(boardId);\\n    require(_isValidExpiry(board.expiry), \\\"invalid board\\\");\\n    activeExpiry = board.expiry;\\n  }\\n\\n  ///////////////////\\n  // VAULT ACTIONS //\\n  ///////////////////\\n\\n  /**\\n   * @dev convert premium in quote asset into collateral asset and send it back to the vault.\\n   */\\n  function returnFundsAndClearStrikes() external onlyVault {\\n    // exchange asset back to collateral asset and send it back to the vault\\n    _returnFundsToVault();\\n\\n    // keep internal storage data on old strikes and positions ids\\n    _clearAllActiveStrikes();\\n  }\\n\\n  /**\\n   * @notice sell a fix aomunt of options and collect premium\\n   * @dev the vault should pass in a strike id, and the strategy would verify if the strike is valid on-chain.\\n   * @param strikeId lyra strikeId to trade\\n   * @param lyraRewardRecipient address to receive trading reward. This need to be whitelisted\\n   * @return positionId\\n   * @return premiumReceived\\n   */\\n  function doTrade(uint strikeId, address lyraRewardRecipient)\\n    external\\n    onlyVault\\n    returns (\\n      uint positionId,\\n      uint premiumReceived,\\n      uint collateralToAdd\\n    )\\n  {\\n    // validate trade\\n    require(\\n      lastTradeTimestamp[strikeId] + strategyDetail.minTradeInterval <= block.timestamp,\\n      \\\"min time interval not passed\\\"\\n    );\\n    require(_isValidVolVariance(strikeId), \\\"vol variance exceeded\\\");\\n\\n    Strike memory strike = _getStrikes(_toDynamic(strikeId))[0];\\n    require(isValidStrike(strike), \\\"invalid strike\\\");\\n\\n    uint setCollateralTo;\\n    (collateralToAdd, setCollateralTo) = getRequiredCollateral(strike);\\n\\n    require(\\n      collateralAsset.transferFrom(address(vault), address(this), collateralToAdd),\\n      \\\"collateral transfer from vault failed\\\"\\n    );\\n\\n    (positionId, premiumReceived) = _sellStrike(strike, setCollateralTo, lyraRewardRecipient);\\n  }\\n\\n  /**\\n   * @dev calculate required collateral to add in the next trade.\\n   * sell size is fixed as strategyDetail.size\\n   * only add collateral if the additional sell will make the position out of buffer range\\n   * never remove collateral from an existing position\\n   */\\n  function getRequiredCollateral(Strike memory strike)\\n    public\\n    view\\n    returns (uint collateralToAdd, uint setCollateralTo)\\n  {\\n    uint sellAmount = strategyDetail.size;\\n    ExchangeRateParams memory exchangeParams = _getExchangeParams();\\n\\n    // get existing position info if active\\n    uint existingAmount = 0;\\n    uint existingCollateral = 0;\\n    if (_isActiveStrike(strike.id)) {\\n      OptionPosition memory position = _getPositions(_toDynamic(strikeToPositionId[strike.id]))[0];\\n      existingCollateral = position.collateral;\\n      existingAmount = position.amount;\\n    }\\n\\n    // gets minBufferCollat for the whole position\\n    uint minBufferCollateral = _getBufferCollateral(\\n      strike.strikePrice,\\n      strike.expiry,\\n      exchangeParams.spotPrice,\\n      existingAmount + sellAmount\\n    );\\n\\n    // get targetCollat for this trade instance\\n    // prevents vault from adding excess collat just to meet targetCollat\\n    uint targetCollat = existingCollateral +\\n      _getFullCollateral(strike.strikePrice, sellAmount).multiplyDecimal(strategyDetail.collatPercent);\\n\\n    // if excess collateral, keep in position to encourage more option selling\\n    setCollateralTo = _max(_max(minBufferCollateral, targetCollat), existingCollateral);\\n\\n    // existingCollateral is never > setCollateralTo\\n    collateralToAdd = setCollateralTo - existingCollateral;\\n  }\\n\\n  /**\\n   * @dev perform the trade\\n   * @param strike strike detail\\n   * @param setCollateralTo target collateral amount\\n   * @param lyraRewardRecipient address to receive lyra trading reward\\n   * @return positionId\\n   * @return premiumReceived\\n   */\\n  function _sellStrike(\\n    Strike memory strike,\\n    uint setCollateralTo,\\n    address lyraRewardRecipient\\n  ) internal returns (uint, uint) {\\n    // get minimum expected premium based on minIv\\n    uint minExpectedPremium = _getPremiumLimit(strike, strategyDetail.minVol, strategyDetail.size);\\n    // perform trade\\n    TradeResult memory result = _openPosition(\\n      TradeInputParameters({\\n        strikeId: strike.id,\\n        positionId: strikeToPositionId[strike.id],\\n        iterations: 3,\\n        optionType: optionType,\\n        amount: strategyDetail.size,\\n        setCollateralTo: setCollateralTo,\\n        minTotalCost: minExpectedPremium,\\n        maxTotalCost: type(uint).max,\\n        rewardRecipient: lyraRewardRecipient // set to zero address if don't want to wait for whitelist\\n      })\\n    );\\n    lastTradeTimestamp[strike.id] = block.timestamp;\\n\\n    // update active strikes\\n    _addActiveStrike(strike.id, result.positionId);\\n\\n    require(result.totalCost >= minExpectedPremium, \\\"premium received is below min expected premium\\\");\\n\\n    return (result.positionId, result.totalCost);\\n  }\\n\\n  /**\\n   * @dev use premium in strategy to reduce position size if collateral ratio is out of range\\n   */\\n  function reducePosition(\\n    uint positionId,\\n    uint closeAmount,\\n    address lyraRewardRecipient\\n  ) external onlyVault {\\n    OptionPosition memory position = _getPositions(_toDynamic(positionId))[0];\\n    Strike memory strike = _getStrikes(_toDynamic(position.strikeId))[0];\\n    require(strikeToPositionId[position.strikeId] == positionId, \\\"invalid positionId\\\");\\n\\n    // only allows closing if collat < minBuffer\\n    require(\\n      closeAmount <= getAllowedCloseAmount(position, strike.strikePrice, strike.expiry),\\n      \\\"amount exceeds allowed close amount\\\"\\n    );\\n\\n    // closes excess position with premium balance\\n    uint maxExpectedPremium = _getPremiumLimit(strike, strategyDetail.maxVol, strategyDetail.size);\\n    _formatedCloseOrForceClosePosition(position, closeAmount, 0, maxExpectedPremium, lyraRewardRecipient);\\n\\n    // return closed collateral amount\\n    if (_isBaseCollat()) {\\n      uint currentBal = baseAsset.balanceOf(address(this));\\n      baseAsset.transfer(address(vault), currentBal);\\n    } else {\\n      // quote collateral\\n      quoteAsset.transfer(address(vault), closeAmount);\\n    }\\n  }\\n\\n  /**\\n   * @dev close all outstanding positions regardless of collat and send funds back to vault\\n   */\\n  function emergencyCloseAll(address lyraRewardRecipient) external onlyVault {\\n    // the vault might not hold enough sUSD to close all positions, will need someone to tapup before doing so.\\n    for (uint i = 0; i < activeStrikeIds.length; i++) {\\n      uint strikeId = activeStrikeIds[i];\\n      OptionPosition memory position = _getPositions(_toDynamic(strikeToPositionId[strikeId]))[0];\\n      // revert if position state is not settled\\n      _formatedCloseOrForceClosePosition(position, position.amount, 0, type(uint).max, lyraRewardRecipient);\\n      delete strikeToPositionId[strikeId];\\n      delete lastTradeTimestamp[strikeId];\\n    }\\n\\n    _returnFundsToVault();\\n  }\\n\\n  /**\\n   * @dev calculates the position amount required to stay above the buffer collateral\\n   */\\n  function getAllowedCloseAmount(\\n    OptionPosition memory position,\\n    uint strikePrice,\\n    uint strikeExpiry\\n  ) public view returns (uint closeAmount) {\\n    ExchangeRateParams memory exchangeParams = _getExchangeParams();\\n    uint minCollatPerAmount = _getBufferCollateral(strikePrice, strikeExpiry, exchangeParams.spotPrice, 1e18);\\n\\n    closeAmount = position.collateral < minCollatPerAmount.multiplyDecimal(position.amount)\\n      ? position.amount - position.collateral.divideDecimal(minCollatPerAmount)\\n      : 0;\\n  }\\n\\n  /////////////////////////////\\n  // Trade Parameter Helpers //\\n  /////////////////////////////\\n\\n  function _getFullCollateral(uint strikePrice, uint amount) internal view returns (uint fullCollat) {\\n    // calculate required collat based on collatBuffer and collatPercent\\n    fullCollat = _isBaseCollat() ? amount : amount.multiplyDecimal(strikePrice);\\n  }\\n\\n  /**\\n   * @dev get amount of collateral needed for shorting {amount} of strike, according to the strategy\\n   */\\n  function _getBufferCollateral(\\n    uint strikePrice,\\n    uint expiry,\\n    uint spotPrice,\\n    uint amount\\n  ) internal view returns (uint) {\\n    uint minCollat = _getMinCollateral(optionType, strikePrice, expiry, spotPrice, amount);\\n    uint minCollatWithBuffer = minCollat.multiplyDecimal(strategyDetail.collatBuffer);\\n\\n    uint fullCollat = _getFullCollateral(strikePrice, amount);\\n\\n    return _min(minCollatWithBuffer, fullCollat);\\n  }\\n\\n  /////////////////\\n  // Validation ///\\n  /////////////////\\n\\n  /**\\n   * @dev verify if the strike is valid for the strategy\\n   * @return isValid true if vol is withint [minVol, maxVol] and delta is within targetDelta +- maxDeltaGap\\n   */\\n  function isValidStrike(Strike memory strike) public view returns (bool isValid) {\\n    if (activeExpiry != strike.expiry) {\\n      return false;\\n    }\\n\\n    uint[] memory strikeId = _toDynamic(strike.id);\\n    uint vol = _getVols(strikeId)[0];\\n    int callDelta = _getDeltas(strikeId)[0];\\n    int delta = _isCall() ? callDelta : callDelta - SignedDecimalMath.UNIT;\\n    uint deltaGap = _abs(strategyDetail.targetDelta - delta);\\n    return vol >= strategyDetail.minVol && vol <= strategyDetail.maxVol && deltaGap < strategyDetail.maxDeltaGap;\\n  }\\n\\n  /**\\n   * @dev check if the vol variance for the given strike is within certain range\\n   */\\n  function _isValidVolVariance(uint strikeId) internal view returns (bool isValid) {\\n    uint volGWAV = _volGWAV(strikeId, strategyDetail.gwavPeriod);\\n    uint volSpot = _getVols(_toDynamic(strikeId))[0];\\n\\n    uint volDiff = (volGWAV >= volSpot) ? volGWAV - volSpot : volSpot - volGWAV;\\n\\n    return isValid = volDiff < strategyDetail.maxVolVariance;\\n  }\\n\\n  /**\\n   * @dev check if the expiry of the board is valid according to the strategy\\n   */\\n  function _isValidExpiry(uint expiry) public view returns (bool isValid) {\\n    uint secondsToExpiry = _getSecondsToExpiry(expiry);\\n    isValid = (secondsToExpiry >= strategyDetail.minTimeToExpiry && secondsToExpiry <= strategyDetail.maxTimeToExpiry);\\n  }\\n}\\n\",\"keccak256\":\"0x5a45dca7ef0083c330c8dcb8dcde1af23a9919dd32a7a0b64507da221094c2de\",\"license\":\"MIT\"},\"contracts/strategies/StrategyBase.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n// Hardhat\\nimport \\\"hardhat/console.sol\\\";\\n\\n// Lyra\\nimport {LyraAdapter} from \\\"@lyrafinance/protocol/contracts/periphery/LyraAdapter.sol\\\";\\n\\n// Libraries\\nimport {Vault} from \\\"../libraries/Vault.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {LyraVault} from \\\"../core/LyraVault.sol\\\";\\nimport {DecimalMath} from \\\"@lyrafinance/protocol/contracts/synthetix/DecimalMath.sol\\\";\\nimport {SignedDecimalMath} from \\\"@lyrafinance/protocol/contracts/synthetix/SignedDecimalMath.sol\\\";\\n\\ncontract StrategyBase is LyraAdapter {\\n  using DecimalMath for uint;\\n  using SignedDecimalMath for int;\\n\\n  LyraVault public immutable vault;\\n  OptionType public immutable optionType;\\n\\n  /// @dev asset used as collateral in AMM to sell. Should be the same as vault asset\\n  IERC20 public collateralAsset;\\n\\n  mapping(uint => uint) public lastTradeTimestamp;\\n\\n  uint[] public activeStrikeIds;\\n  mapping(uint => uint) public strikeToPositionId;\\n\\n  ///////////\\n  // ADMIN //\\n  ///////////\\n\\n  modifier onlyVault() virtual {\\n    require(msg.sender == address(vault), \\\"only Vault\\\");\\n    _;\\n  }\\n\\n  constructor(LyraVault _vault, OptionType _optionType) LyraAdapter() {\\n    vault = _vault;\\n    optionType = _optionType;\\n  }\\n\\n  function initAdapter(\\n    address _lyraRegistry,\\n    address _optionMarket,\\n    address _curveSwap,\\n    address _feeCounter\\n  ) external onlyOwner {\\n    // set addresses for LyraAdapter\\n    setLyraAddresses(_lyraRegistry, _optionMarket, _curveSwap, _feeCounter);\\n\\n    quoteAsset.approve(address(vault), type(uint).max);\\n    baseAsset.approve(address(vault), type(uint).max);\\n    collateralAsset = _isBaseCollat() ? IERC20(address(baseAsset)) : IERC20(address(quoteAsset));\\n  }\\n\\n  ///////////////////\\n  // VAULT ACTIONS //\\n  ///////////////////\\n\\n  /**\\n   * @dev exchange asset back to collateral asset and send it back to the vault\\n   * @dev override this function if you want to customize asset management flow\\n   */\\n  function _returnFundsToVault() internal virtual {\\n    ExchangeRateParams memory exchangeParams = _getExchangeParams();\\n    uint quoteBal = quoteAsset.balanceOf(address(this));\\n\\n    if (_isBaseCollat()) {\\n      // exchange quote asset to base asset, and send base asset back to vault\\n      uint baseBal = baseAsset.balanceOf(address(this));\\n      uint minQuoteExpected = quoteBal.divideDecimal(exchangeParams.spotPrice).multiplyDecimal(\\n        DecimalMath.UNIT - exchangeParams.baseQuoteFeeRate\\n      );\\n      uint baseReceived = _exchangeFromExactQuote(quoteBal, minQuoteExpected);\\n      require(baseAsset.transfer(address(vault), baseBal + baseReceived), \\\"failed to return funds from strategy\\\");\\n    } else {\\n      // send quote balance directly\\n      require(quoteAsset.transfer(address(vault), quoteBal), \\\"failed to return funds from strategy\\\");\\n    }\\n  }\\n\\n  /////////////////////////////\\n  // Trade Parameter Helpers //\\n  /////////////////////////////\\n\\n  /**\\n   * @dev Automatically decide between close and forceClose\\n   * depending on whether deltaCutoff or tradingCutoff are crossed\\n   */\\n\\n  function _formatedCloseOrForceClosePosition(\\n    OptionPosition memory position,\\n    uint closeAmount,\\n    uint minTotalCost,\\n    uint maxTotalCost,\\n    address lyraRewardRecipient\\n  ) internal {\\n    // closes excess position with premium balance\\n\\n    // if it's a full close, take out our collateral as well.\\n    uint setCollateralTo = position.amount == closeAmount ? 0 : position.collateral;\\n\\n    TradeInputParameters memory tradeParams = TradeInputParameters({\\n      strikeId: position.strikeId,\\n      positionId: position.positionId,\\n      iterations: 3,\\n      optionType: optionType,\\n      amount: closeAmount,\\n      setCollateralTo: setCollateralTo,\\n      minTotalCost: minTotalCost,\\n      maxTotalCost: maxTotalCost,\\n      rewardRecipient: lyraRewardRecipient // set to zero address if don't want to wait for whitelist\\n    });\\n\\n    // if forceClosed, will pay less competitive price to close position but bypasses Lyra delta/trading cutoffs\\n    TradeResult memory result = _closeOrForceClosePosition(tradeParams);\\n    require(result.totalCost <= maxTotalCost, \\\"premium paid is above max expected premium\\\");\\n  }\\n\\n  /**\\n   * @dev get minimum premium that the vault should receive.\\n   * param listingId lyra option listing id\\n   * param size size of trade in Lyra standard sizes\\n   */\\n  function _getPremiumLimit(\\n    Strike memory strike,\\n    uint vol,\\n    uint size\\n  ) internal view returns (uint limitPremium) {\\n    ExchangeRateParams memory exchangeParams = _getExchangeParams();\\n    (uint callPremium, uint putPremium) = _getPurePremium(\\n      _getSecondsToExpiry(strike.expiry),\\n      vol,\\n      exchangeParams.spotPrice,\\n      strike.strikePrice\\n    );\\n\\n    limitPremium = _isCall() ? callPremium.multiplyDecimal(size) : putPremium.multiplyDecimal(size);\\n  }\\n\\n  //////////////////////////////\\n  // Active Strike Management //\\n  //////////////////////////////\\n\\n  /**\\n   * @dev add strike id to activeStrikeIds array\\n   */\\n  function _addActiveStrike(uint strikeId, uint tradedPositionId) internal {\\n    if (!_isActiveStrike(strikeId)) {\\n      strikeToPositionId[strikeId] = tradedPositionId;\\n      activeStrikeIds.push(strikeId);\\n    }\\n  }\\n\\n  /**\\n   * @dev add the last traded timestamp for a specific strike.\\n   */\\n  function _setLastTradedAt(uint strikeId, uint timestamp) internal {\\n    lastTradeTimestamp[strikeId] = timestamp;\\n  }\\n\\n  /**\\n   * @dev remove position data opened in the current round.\\n   * this can only be called after the position is settled by lyra\\n   **/\\n  function _clearAllActiveStrikes() internal {\\n    if (activeStrikeIds.length != 0) {\\n      for (uint i = 0; i < activeStrikeIds.length; i++) {\\n        uint strikeId = activeStrikeIds[i];\\n        OptionPosition memory position = _getPositions(_toDynamic(strikeToPositionId[strikeId]))[0];\\n        // revert if position state is not settled\\n        require(position.state != PositionState.ACTIVE, \\\"cannot clear active position\\\");\\n        delete strikeToPositionId[strikeId];\\n        delete lastTradeTimestamp[strikeId];\\n      }\\n      delete activeStrikeIds;\\n    }\\n  }\\n\\n  function _isActiveStrike(uint strikeId) internal view returns (bool isActive) {\\n    isActive = strikeToPositionId[strikeId] != 0;\\n  }\\n\\n  //////////\\n  // Misc //\\n  //////////\\n\\n  function _isBaseCollat() internal view returns (bool isBase) {\\n    isBase = (optionType == OptionType.SHORT_CALL_BASE) ? true : false;\\n  }\\n\\n  function _isCall() internal view returns (bool isCall) {\\n    isCall = (optionType == OptionType.SHORT_PUT_QUOTE || optionType == OptionType.LONG_PUT) ? false : true;\\n  }\\n\\n  function _getSecondsToExpiry(uint expiry) internal view returns (uint) {\\n    require(block.timestamp <= expiry, \\\"timestamp expired\\\");\\n    return expiry - block.timestamp;\\n  }\\n\\n  function _abs(int val) internal pure returns (uint) {\\n    return val >= 0 ? uint(val) : uint(-val);\\n  }\\n\\n  function _min(uint x, uint y) internal pure returns (uint) {\\n    return (x < y) ? x : y;\\n  }\\n\\n  function _max(uint x, uint y) internal pure returns (uint) {\\n    return (x > y) ? x : y;\\n  }\\n\\n  // temporary fix - eth core devs promised Q2 2022 fix\\n  function _toDynamic(uint val) internal pure returns (uint[] memory dynamicArray) {\\n    dynamicArray = new uint[](1);\\n    dynamicArray[0] = val;\\n  }\\n}\\n\",\"keccak256\":\"0x70c95a28c029e82253286bcea725c233ebfc07be9c033ce9e07d329243374c39\",\"license\":\"MIT\"},\"hardhat/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.4.22 <0.9.0;\\n\\nlibrary console {\\n\\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n\\tfunction _sendLogPayload(bytes memory payload) private view {\\n\\t\\tuint256 payloadLength = payload.length;\\n\\t\\taddress consoleAddress = CONSOLE_ADDRESS;\\n\\t\\tassembly {\\n\\t\\t\\tlet payloadStart := add(payload, 32)\\n\\t\\t\\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction log() internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n\\t}\\n\\n\\tfunction logInt(int p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(int)\\\", p0));\\n\\t}\\n\\n\\tfunction logUint(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction logString(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction logBool(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction logAddress(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes(bytes memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes1(bytes1 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes2(bytes2 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes3(bytes3 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes4(bytes4 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes5(bytes5 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes6(bytes6 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes7(bytes7 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes8(bytes8 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes9(bytes9 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes10(bytes10 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes11(bytes11 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes12(bytes12 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes13(bytes13 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes14(bytes14 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes15(bytes15 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes16(bytes16 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes17(bytes17 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes18(bytes18 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes19(bytes19 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes20(bytes20 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes21(bytes21 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes22(bytes22 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes23(bytes23 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes24(bytes24 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes25(bytes25 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes26(bytes26 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes27(bytes27 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes28(bytes28 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes29(bytes29 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes30(bytes30 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes31(bytes31 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes32(bytes32 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction log(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction log(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction log(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n}\\n\",\"keccak256\":\"0x72b6a1d297cd3b033d7c2e4a7e7864934bb767db6453623f1c3082c6534547f4\",\"license\":\"MIT\"},\"openzeppelin-contracts-4.4.1/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0x24e0364e503a9bbde94c715d26573a76f14cd2a202d45f96f52134ab806b67b9\",\"license\":\"MIT\"},\"openzeppelin-contracts-4.4.1/security/ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\",\"keccak256\":\"0x0e9621f60b2faabe65549f7ed0f24e8853a45c1b7990d47e8160e523683f3935\",\"license\":\"MIT\"},\"openzeppelin-contracts-4.4.1/token/ERC20/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n\\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\\n        require(currentAllowance >= amount, \\\"ERC20: transfer amount exceeds allowance\\\");\\n        unchecked {\\n            _approve(sender, _msgSender(), currentAllowance - amount);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        uint256 senderBalance = _balances[sender];\\n        require(senderBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[sender] = senderBalance - amount;\\n        }\\n        _balances[recipient] += amount;\\n\\n        emit Transfer(sender, recipient, amount);\\n\\n        _afterTokenTransfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\",\"keccak256\":\"0xd1d8caaeb45f78e0b0715664d56c220c283c89bf8b8c02954af86404d6b367f8\",\"license\":\"MIT\"},\"openzeppelin-contracts-4.4.1/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0x61437cb513a887a1bbad006e7b1c8b414478427d33de47c5600af3c748f108da\",\"license\":\"MIT\"},\"openzeppelin-contracts-4.4.1/token/ERC20/extensions/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x8de418a5503946cabe331f35fe242d3201a73f67f77aaeb7110acb1f30423aca\",\"license\":\"MIT\"},\"openzeppelin-contracts-4.4.1/token/ERC721/ERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/ERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC721.sol\\\";\\nimport \\\"./IERC721Receiver.sol\\\";\\nimport \\\"./extensions/IERC721Metadata.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"../../utils/Strings.sol\\\";\\nimport \\\"../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\\n * {ERC721Enumerable}.\\n */\\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\\n    using Address for address;\\n    using Strings for uint256;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Mapping from token ID to owner address\\n    mapping(uint256 => address) private _owners;\\n\\n    // Mapping owner address to token count\\n    mapping(address => uint256) private _balances;\\n\\n    // Mapping from token ID to approved address\\n    mapping(uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IERC721).interfaceId ||\\n            interfaceId == type(IERC721Metadata).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\n        require(owner != address(0), \\\"ERC721: balance query for the zero address\\\");\\n        return _balances[owner];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        address owner = _owners[tokenId];\\n        require(owner != address(0), \\\"ERC721: owner query for nonexistent token\\\");\\n        return owner;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI query for nonexistent token\\\");\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, can be overriden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = ERC721.ownerOf(tokenId);\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n        require(\\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\\n            \\\"ERC721: approve caller is not owner nor approved for all\\\"\\n        );\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\n        require(_exists(tokenId), \\\"ERC721: approved query for nonexistent token\\\");\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        _setApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        //solhint-disable-next-line max-line-length\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) public virtual override {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n        _safeTransfer(from, to, tokenId, _data);\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) internal virtual {\\n        _transfer(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return _owners[tokenId] != address(0);\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\\n        require(_exists(tokenId), \\\"ERC721: operator query for nonexistent token\\\");\\n        address owner = ERC721.ownerOf(tokenId);\\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\\n    }\\n\\n    /**\\n     * @dev Safely mints `tokenId` and transfers it to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeMint(\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) internal virtual {\\n        _mint(to, tokenId);\\n        require(\\n            _checkOnERC721Received(address(0), to, tokenId, _data),\\n            \\\"ERC721: transfer to non ERC721Receiver implementer\\\"\\n        );\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 tokenId) internal virtual {\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        _beforeTokenTransfer(address(0), to, tokenId);\\n\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(address(0), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        address owner = ERC721.ownerOf(tokenId);\\n\\n        _beforeTokenTransfer(owner, address(0), tokenId);\\n\\n        // Clear approvals\\n        _approve(address(0), tokenId);\\n\\n        _balances[owner] -= 1;\\n        delete _owners[tokenId];\\n\\n        emit Transfer(owner, address(0), tokenId);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {\\n        require(ERC721.ownerOf(tokenId) == from, \\\"ERC721: transfer of token that is not own\\\");\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, tokenId);\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId);\\n\\n        _balances[from] -= 1;\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits a {Approval} event.\\n     */\\n    function _approve(address to, uint256 tokenId) internal virtual {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `operator` to operate on all of `owner` tokens\\n     *\\n     * Emits a {ApprovalForAll} event.\\n     */\\n    function _setApprovalForAll(\\n        address owner,\\n        address operator,\\n        bool approved\\n    ) internal virtual {\\n        require(owner != operator, \\\"ERC721: approve to caller\\\");\\n        _operatorApprovals[owner][operator] = approved;\\n        emit ApprovalForAll(owner, operator, approved);\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param _data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) private returns (bool) {\\n        if (to.isContract()) {\\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\\n                return retval == IERC721Receiver.onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert(\\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n                } else {\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {}\\n}\\n\",\"keccak256\":\"0x81c02855bc239e16ec09eee000a8bec691424c715188d6d881037e69c45414c4\",\"license\":\"MIT\"},\"openzeppelin-contracts-4.4.1/token/ERC721/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\",\"keccak256\":\"0x516a22876c1fab47f49b1bc22b4614491cd05338af8bd2e7b382da090a079990\",\"license\":\"MIT\"},\"openzeppelin-contracts-4.4.1/token/ERC721/IERC721Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0xd5fa74b4fb323776fa4a8158800fec9d5ac0fec0d6dd046dd93798632ada265f\",\"license\":\"MIT\"},\"openzeppelin-contracts-4.4.1/token/ERC721/extensions/ERC721Enumerable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721Enumerable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC721.sol\\\";\\nimport \\\"./IERC721Enumerable.sol\\\";\\n\\n/**\\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\\n * enumerability of all the token ids in the contract as well as all token ids owned by each\\n * account.\\n */\\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\\n    // Mapping from owner to list of owned token IDs\\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\\n\\n    // Mapping from token ID to index of the owner tokens list\\n    mapping(uint256 => uint256) private _ownedTokensIndex;\\n\\n    // Array with all token ids, used for enumeration\\n    uint256[] private _allTokens;\\n\\n    // Mapping from token id to position in the allTokens array\\n    mapping(uint256 => uint256) private _allTokensIndex;\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\\n        require(index < ERC721.balanceOf(owner), \\\"ERC721Enumerable: owner index out of bounds\\\");\\n        return _ownedTokens[owner][index];\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _allTokens.length;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-tokenByIndex}.\\n     */\\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\\n        require(index < ERC721Enumerable.totalSupply(), \\\"ERC721Enumerable: global index out of bounds\\\");\\n        return _allTokens[index];\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual override {\\n        super._beforeTokenTransfer(from, to, tokenId);\\n\\n        if (from == address(0)) {\\n            _addTokenToAllTokensEnumeration(tokenId);\\n        } else if (from != to) {\\n            _removeTokenFromOwnerEnumeration(from, tokenId);\\n        }\\n        if (to == address(0)) {\\n            _removeTokenFromAllTokensEnumeration(tokenId);\\n        } else if (to != from) {\\n            _addTokenToOwnerEnumeration(to, tokenId);\\n        }\\n    }\\n\\n    /**\\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\\n     * @param to address representing the new owner of the given token ID\\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\\n     */\\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\\n        uint256 length = ERC721.balanceOf(to);\\n        _ownedTokens[to][length] = tokenId;\\n        _ownedTokensIndex[tokenId] = length;\\n    }\\n\\n    /**\\n     * @dev Private function to add a token to this extension's token tracking data structures.\\n     * @param tokenId uint256 ID of the token to be added to the tokens list\\n     */\\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\\n        _allTokensIndex[tokenId] = _allTokens.length;\\n        _allTokens.push(tokenId);\\n    }\\n\\n    /**\\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\\n     * @param from address representing the previous owner of the given token ID\\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\\n     */\\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\\n        // then delete the last slot (swap and pop).\\n\\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\\n\\n        // When the token to delete is the last token, the swap operation is unnecessary\\n        if (tokenIndex != lastTokenIndex) {\\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\\n\\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\\n        }\\n\\n        // This also deletes the contents at the last position of the array\\n        delete _ownedTokensIndex[tokenId];\\n        delete _ownedTokens[from][lastTokenIndex];\\n    }\\n\\n    /**\\n     * @dev Private function to remove a token from this extension's token tracking data structures.\\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\\n     */\\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\\n        // then delete the last slot (swap and pop).\\n\\n        uint256 lastTokenIndex = _allTokens.length - 1;\\n        uint256 tokenIndex = _allTokensIndex[tokenId];\\n\\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\\n\\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\\n\\n        // This also deletes the contents at the last position of the array\\n        delete _allTokensIndex[tokenId];\\n        _allTokens.pop();\\n    }\\n}\\n\",\"keccak256\":\"0x0a79511df8151b10b0a0004d6a76ad956582d32824af4c0f4886bdbdfe5746e5\",\"license\":\"MIT\"},\"openzeppelin-contracts-4.4.1/token/ERC721/extensions/IERC721Enumerable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Enumerable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x483f88fbbb1d6d75000fbe8ce14279b5e6121cd5a29ff5f1b91fed407735a6c3\",\"license\":\"MIT\"},\"openzeppelin-contracts-4.4.1/token/ERC721/extensions/IERC721Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0x75b829ff2f26c14355d1cba20e16fe7b29ca58eb5fef665ede48bc0f9c6c74b9\",\"license\":\"MIT\"},\"openzeppelin-contracts-4.4.1/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x51b758a8815ecc9596c66c37d56b1d33883a444631a3f916b9fe65cb863ef7c4\",\"license\":\"MIT\"},\"openzeppelin-contracts-4.4.1/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"openzeppelin-contracts-4.4.1/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\",\"keccak256\":\"0x32c202bd28995dd20c4347b7c6467a6d3241c74c8ad3edcbb610cd9205916c45\",\"license\":\"MIT\"},\"openzeppelin-contracts-4.4.1/utils/introspection/ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\",\"keccak256\":\"0xd10975de010d89fd1c78dc5e8a9a7e7f496198085c151648f20cba166b32582b\",\"license\":\"MIT\"},\"openzeppelin-contracts-4.4.1/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"openzeppelin-contracts-4.4.1/utils/math/SafeCast.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeCast.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128) {\\n        require(value >= type(int128).min && value <= type(int128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return int128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64) {\\n        require(value >= type(int64).min && value <= type(int64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return int64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32) {\\n        require(value >= type(int32).min && value <= type(int32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return int32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16) {\\n        require(value >= type(int16).min && value <= type(int16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return int16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8) {\\n        require(value >= type(int8).min && value <= type(int8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return int8(value);\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\",\"keccak256\":\"0x5c6caab697d302ad7eb59c234a4d2dbc965c1bae87709bd2850060b7695b28c7\",\"license\":\"MIT\"},\"openzeppelin-contracts-upgradeable-4.5.1/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() initializer {}\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\\n        // contract may have been reentered.\\n        require(_initializing ? _isConstructor() : !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} modifier, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    function _isConstructor() private view returns (bool) {\\n        return !AddressUpgradeable.isContract(address(this));\\n    }\\n}\\n\",\"keccak256\":\"0x372b0bc04e3b4c074559bbbfb1317afddb56de5504158ca25a7f9cd403980445\",\"license\":\"MIT\"},\"openzeppelin-contracts-upgradeable-4.5.1/utils/AddressUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x55cf2bd9fc76704ddcdc19834cd288b7de00fc0f298a40ea16a954ae8991db2d\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60c06040523480156200001157600080fd5b5060405162004c1838038062004c188339810160408190526200003491620000d8565b8181620000413362000088565b6001600160a01b03821660805280600481111562000063576200006362000125565b60a08160048111156200007a576200007a62000125565b81525050505050506200013b565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b60008060408385031215620000ec57600080fd5b82516001600160a01b03811681146200010457600080fd5b6020840151909250600581106200011a57600080fd5b809150509250929050565b634e487b7160e01b600052602160045260246000fd5b60805160a051614a32620001e66000396000818161054301528181611d7701528181611db20152818161215401528181612211015281816124e80152612af60152600081816104f60152818161079501528181610954015281816109fb01528181610c1901528181610e5a01528181610f0501528181610fd1015281816110d40152818161113f015281816112c8015281816113e10152818161278801526128640152614a326000f3fe608060405234801561001057600080fd5b50600436106101b75760003560e01c806303c4d3d6146101bc578063131b2f86146101d85780632a37ad5a146101f85780632bab754b1461028757806338b74054146102a7578063478620c0146102ba57806354f1e01f146102dd57806357949815146103055780635a3c76ab146103185780635cf035491461032d578063619a84cc14610340578063621318cd14610348578063665a11ca1461035b5780637083a9041461036e578063715018a6146103815780637dd0db1b1461038957806383cea5421461039c578063870dcaeb146103a45780638da5cb5b146103b7578063a65be9ba146103bf578063a8c379c2146103d2578063aabaecd614610400578063ae74fc4d14610413578063b5ca94a014610426578063bb4a9f8814610439578063bc4e44051461044c578063cae1c5821461045f578063cdf456e114610472578063d4aaa9eb14610485578063d8fca1ac146104a5578063dffcf353146104b8578063ee9e0e6a146104cb578063f2fde38b146104de578063fbfa77cf146104f1578063fdf262b714610518578063ffcd00ac1461052b578063ffd9eedb1461053e575b600080fd5b6101c5601e5481565b6040519081526020015b60405180910390f35b6101c56101e6366004613aff565b600f6020526000908152604090205481565b601254601354601454601554601654601754601854601954601a54601b54601c54601d5461022e9b9a999897969594939291908c565b604080519c8d5260208d019b909b52998b019890985260608a0196909652608089019490945260a088019290925260c087015260e0860152610100850152610120840152610140830152610160820152610180016101cf565b60045461029a906001600160a01b031681565b6040516101cf9190613b18565b60095461029a906001600160a01b031681565b6102cd6102c8366004613c48565b610572565b60405190151581526020016101cf565b6102f06102eb366004613c48565b61065f565b604080519283526020830191909152016101cf565b600d5461029a906001600160a01b031681565b61032b610326366004613c98565b610759565b005b61032b61033b366004613d4c565b6108f1565b61032b610aca565b6102cd610356366004613aff565b610be4565b60055461029a906001600160a01b031681565b61032b61037c366004613da8565b610c0e565b61032b610f8b565b61032b610397366004613de1565b610fc6565b61032b6110c9565b60065461029a906001600160a01b031681565b61029a611121565b60075461029a906001600160a01b031681565b6103e56103e0366004613dfe565b611130565b604080519384526020840192909252908201526060016101cf565b600e5461029a906001600160a01b031681565b61032b610421366004613aff565b6113d6565b61032b610434366004613d4c565b61147e565b60035461029a906001600160a01b031681565b6101c561045a366004613aff565b6118dd565b60085461029a906001600160a01b031681565b600b5461029a906001600160a01b031681565b6101c5610493366004613aff565b60116020526000908152604090205481565b600c5461029a906001600160a01b031681565b6102f06104c6366004613e2e565b6118fe565b60015461029a906001600160a01b031681565b61032b6104ec366004613de1565b611990565b61029a7f000000000000000000000000000000000000000000000000000000000000000081565b600a5461029a906001600160a01b031681565b6101c5610539366004613e6a565b611a2d565b6105657f000000000000000000000000000000000000000000000000000000000000000081565b6040516101cf9190613f2b565b60008160200151601e541461058957506000919050565b60006105988360000151611aa6565b905060006105a582611aed565b6000815181106105b7576105b7613f3e565b6020026020010151905060006105cc83611c40565b6000815181106105de576105de613f3e565b6020026020010151905060006105f2611d71565b610611576106026012600a61404e565b61060c908361405a565b610613565b815b905060006106308260126002015461062b919061405a565b611df4565b601654909150841080159061064757506017548411155b8015610654575060155481105b979650505050505050565b601854600090819081610670611e14565b8551600090815260116020526040812054919250908190156106db5786516000908152601160205260408120546106af906106aa90611aa6565b611ee7565b6000815181106106c1576106c1613f3e565b602002602001015190508060800151915080606001519250505b600061070088604001518960200151866000015188876106fb9190614099565b61214c565b905060006107216012600b015461071b8b60400151896121b6565b906121d3565b61072b9084614099565b905061074061073a83836121f5565b846121f5565b965061074c83886140b1565b9750505050505050915091565b33610762611121565b6001600160a01b0316146107915760405162461bcd60e51b8152600401610788906140c8565b60405180910390fd5b60007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316632728f3336040518163ffffffff1660e01b81526004016101006040518083038186803b1580156107ed57600080fd5b505afa158015610801573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610825919061413b565b975050505050505050801561088e5760405162461bcd60e51b815260206004820152602960248201527f63616e6e6f74206368616e676520737472617465677920696620726f756e642060448201526869732061637469766560b81b6064820152608401610788565b508051601255602081015160135560408101516014556060810151601555608081015160165560a081015160175560c081015160185560e0810151601955610100810151601a55610120810151601b55610140810151601c556101600151601d55565b336108fa611121565b6001600160a01b0316146109205760405162461bcd60e51b8152600401610788906140c8565b61092c8484848461147e565b600a5460405163095ea7b360e01b81526001600160a01b039091169063095ea7b390610980907f000000000000000000000000000000000000000000000000000000000000000090600019906004016141cd565b602060405180830381600087803b15801561099a57600080fd5b505af11580156109ae573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109d291906141e6565b50600b5460405163095ea7b360e01b81526001600160a01b039091169063095ea7b390610a27907f000000000000000000000000000000000000000000000000000000000000000090600019906004016141cd565b602060405180830381600087803b158015610a4157600080fd5b505af1158015610a55573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a7991906141e6565b50610a8261220b565b610a9757600a546001600160a01b0316610aa4565b600b546001600160a01b03165b600e80546001600160a01b0319166001600160a01b039290921691909117905550505050565b33610ad3611121565b6001600160a01b031614610af95760405162461bcd60e51b8152600401610788906140c8565b600260009054906101000a90046001600160a01b03166001600160a01b0316633535c97b6040518163ffffffff1660e01b815260040160206040518083038186803b158015610b4757600080fd5b505afa158015610b5b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b7f9190614201565b60025460405163447fbc6360e01b81526001600160a01b039283169263447fbc6392610bb092911690600401613b18565b600060405180830381600087803b158015610bca57600080fd5b505af1158015610bde573d6000803e3d6000fd5b50505050565b600080610bf083612252565b6012549091508110801590610c0757506013548111155b9392505050565b336001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614610c565760405162461bcd60e51b81526004016107889061421e565b6000610c646106aa85611aa6565b600081518110610c7657610c76613f3e565b602002602001015190506000610c97610c928360200151611aa6565b6122a2565b600081518110610ca957610ca9613f3e565b602002602001015190508460116000846020015181526020019081526020016000205414610d0e5760405162461bcd60e51b81526020600482015260126024820152711a5b9d985b1a59081c1bdcda5d1a5bdb925960721b6044820152606401610788565b610d218282604001518360200151611a2d565b841115610d7c5760405162461bcd60e51b815260206004820152602360248201527f616d6f756e74206578636565647320616c6c6f77656420636c6f736520616d6f6044820152621d5b9d60ea1b6064820152608401610788565b6000610d9382601260050154601260060154612448565b9050610da38386600084886124a1565b610dab61220b565b15610edd57600b546040516370a0823160e01b81526000916001600160a01b0316906370a0823190610de1903090600401613b18565b60206040518083038186803b158015610df957600080fd5b505afa158015610e0d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e319190614242565b600b5460405163a9059cbb60e01b81529192506001600160a01b03169063a9059cbb90610e84907f00000000000000000000000000000000000000000000000000000000000000009085906004016141cd565b602060405180830381600087803b158015610e9e57600080fd5b505af1158015610eb2573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ed691906141e6565b5050610f83565b600a5460405163a9059cbb60e01b81526001600160a01b039091169063a9059cbb90610f2f907f00000000000000000000000000000000000000000000000000000000000000009089906004016141cd565b602060405180830381600087803b158015610f4957600080fd5b505af1158015610f5d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f8191906141e6565b505b505050505050565b33610f94611121565b6001600160a01b031614610fba5760405162461bcd60e51b8152600401610788906140c8565b610fc460006125c2565b565b336001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000161461100e5760405162461bcd60e51b81526004016107889061421e565b60005b6010548110156110bd5760006010828154811061103057611030613f3e565b90600052602060002001549050600061105e6106aa6011600085815260200190815260200160002054611aa6565b60008151811061107057611070613f3e565b6020026020010151905061108e8182606001516000600019886124a1565b506000908152601160209081526040808320839055600f909152812055806110b58161425b565b915050611011565b506110c6612612565b50565b336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146111115760405162461bcd60e51b81526004016107889061421e565b611119612612565b610fc4612900565b6000546001600160a01b031690565b60008080336001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000161461117c5760405162461bcd60e51b81526004016107889061421e565b6019546000868152600f6020526040902054429161119991614099565b11156111e65760405162461bcd60e51b815260206004820152601c60248201527b1b5a5b881d1a5b59481a5b9d195c9d985b081b9bdd081c185cdcd95960221b6044820152606401610788565b6111ef85612a26565b6112335760405162461bcd60e51b81526020600482015260156024820152741d9bdb081d985c9a585b98d948195e18d959591959605a1b6044820152606401610788565b6000611241610c9287611aa6565b60008151811061125357611253613f3e565b6020026020010151905061126681610572565b6112a35760405162461bcd60e51b815260206004820152600e60248201526d696e76616c696420737472696b6560901b6044820152606401610788565b60006112ae8261065f565b600e546040516323b872dd60e01b81526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000811660048301523060248301526044820185905293965091935091909116906323b872dd90606401602060405180830381600087803b15801561132957600080fd5b505af115801561133d573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061136191906141e6565b6113bb5760405162461bcd60e51b815260206004820152602560248201527f636f6c6c61746572616c207472616e736665722066726f6d207661756c742066604482015264185a5b195960da1b6064820152608401610788565b6113c6828288612a99565b9098909750929550919350505050565b336001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000161461141e5760405162461bcd60e51b81526004016107889061421e565b600061142982612bff565b90506114388160200151610be4565b6114745760405162461bcd60e51b815260206004820152600d60248201526c1a5b9d985b1a5908189bd85c99609a1b6044820152606401610788565b60200151601e5550565b33611487611121565b6001600160a01b0316146114ad5760405162461bcd60e51b8152600401610788906140c8565b600a546001600160a01b03161561154957600a5460035460405163095ea7b360e01b81526001600160a01b039283169263095ea7b3926114f5929116906000906004016141cd565b602060405180830381600087803b15801561150f57600080fd5b505af1158015611523573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061154791906141e6565b505b600b546001600160a01b0316156115e557600b5460035460405163095ea7b360e01b81526001600160a01b039283169263095ea7b392611591929116906000906004016141cd565b602060405180830381600087803b1580156115ab57600080fd5b505af11580156115bf573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115e391906141e6565b505b600380546001600160a01b038581166001600160a01b031992831617909255600180549287169290911682179055604051623f970360e91b81527029aca72a2422aa24ac2fa0a220a82a22a960791b6004820152637f2e06009060240160206040518083038186803b15801561165a57600080fd5b505afa15801561166e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906116929190614201565b600280546001600160a01b0319166001600160a01b03929092169190911790556116ba612cde565b600c80546001600160a01b038085166001600160a01b031992831617909255600d8054848416921691909117905560025460408051633535c97b60e01b815290519190921691633535c97b916004808301926020929190829003018186803b15801561172557600080fd5b505afa158015611739573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061175d9190614201565b60025460405163447fbc6360e01b81526001600160a01b039283169263447fbc639261178e92911690600401613b18565b600060405180830381600087803b1580156117a857600080fd5b505af11580156117bc573d6000803e3d6000fd5b5050600a5460035460405163095ea7b360e01b81526001600160a01b03928316945063095ea7b393506117f99290911690600019906004016141cd565b602060405180830381600087803b15801561181357600080fd5b505af1158015611827573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061184b91906141e6565b50600b5460035460405163095ea7b360e01b81526001600160a01b039283169263095ea7b39261188492911690600019906004016141cd565b602060405180830381600087803b15801561189e57600080fd5b505af11580156118b2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906118d691906141e6565b5050505050565b601081815481106118ed57600080fd5b600091825260209091200154905081565b60075460405163ca4ca66760e01b8152600481018490526024810183905260009182916001600160a01b039091169063ca4ca66790604401604080518083038186803b15801561194d57600080fd5b505afa158015611961573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119859190614276565b915091509250929050565b33611999611121565b6001600160a01b0316146119bf5760405162461bcd60e51b8152600401610788906140c8565b6001600160a01b038116611a245760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b6064820152608401610788565b6110c6816125c2565b600080611a38611e14565b90506000611a5485858460000151670de0b6b3a764000061214c565b9050611a6d8660600151826121d390919063ffffffff16565b866080015110611a7e576000611a9c565b6080860151611a8d9082612e18565b8660600151611a9c91906140b1565b9695505050505050565b604080516001808252818301909252606091602080830190803683370190505090508181600081518110611adc57611adc613f3e565b602002602001018181525050919050565b606081516001600160401b03811115611b0857611b08613b2c565b604051908082528060200260200182016040528015611b31578160200160208202803683370190505b50905060005b8251811015611c3a57600354835160009182916001600160a01b039091169063c4c4a0d090879086908110611b6e57611b6e613f3e565b60200260200101516040518263ffffffff1660e01b8152600401611b9491815260200190565b60006040518083038186803b158015611bac57600080fd5b505afa158015611bc0573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052611be89190810190614405565b91509150611c07826040015182604001516121d390919063ffffffff16565b848481518110611c1957611c19613f3e565b60200260200101818152505050508080611c329061425b565b915050611b37565b50919050565b606081516001600160401b03811115611c5b57611c5b613b2c565b604051908082528060200260200182016040528015611c84578160200160208202803683370190505b50905060005b8251811015611c3a576000611cb7848381518110611caa57611caa613f3e565b6020026020010151612e31565b604051634698f9d560e11b815290915073EAB60138D1C2160062bbcD881D153961865aA51090638d31f3aa90611cf1908490600401614456565b604080518083038186803b158015611d0857600080fd5b505af4158015611d1c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d409190614276565b50838381518110611d5357611d53613f3e565b60209081029190910101525080611d698161425b565b915050611c8a565b600060047f00000000000000000000000000000000000000000000000000000000000000006004811115611da757611da7613ef7565b1480611de4575060017f00000000000000000000000000000000000000000000000000000000000000006004811115611de257611de2613ef7565b145b611dee5750600190565b50600090565b600080821215611e0c57611e0782614490565b611e0e565b815b92915050565b611e3860405180606001604052806000815260200160008152602001600081525090565b6002546003546040516333ef9fd160e21b81526000926001600160a01b039081169263cfbe7f4492611e709290911690600401613b18565b60a06040518083038186803b158015611e8857600080fd5b505afa158015611e9c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ec091906144ad565b60408051606080820183528351825283015160208201526080909201519082015292915050565b600480546040516323d3547760e01b81526060926000926001600160a01b0316916323d3547791611f1a918791016144fd565b60006040518083038186803b158015611f3257600080fd5b505afa158015611f46573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052611f6e9190810190614541565b9050600081516001600160401b03811115611f8b57611f8b613b2c565b604051908082528060200260200182016040528015611fc457816020015b611fb16139fa565b815260200190600190039081611fa95790505b50905060005b8251811015612144576040518060c00160405280848381518110611ff057611ff0613f3e565b602002602001015160000151815260200184838151811061201357612013613f3e565b602002602001015160200151815260200184838151811061203657612036613f3e565b602002602001015160400151600481111561205357612053613ef7565b600481111561206457612064613ef7565b600481111561207557612075613ef7565b815260200184838151811061208c5761208c613f3e565b60200260200101516060015181526020018483815181106120af576120af613f3e565b60200260200101516080015181526020018483815181106120d2576120d2613f3e565b602002602001015160a0015160058111156120ef576120ef613ef7565b600581111561210057612100613ef7565b600581111561211157612111613ef7565b81525082828151811061212657612126613f3e565b6020026020010181905250808061213c9061425b565b915050611fca565b509392505050565b60008061217c7f000000000000000000000000000000000000000000000000000000000000000087878787613058565b601c549091506000906121909083906121d3565b9050600061219e88866121b6565b90506121aa8282613103565b98975050505050505050565b60006121c061220b565b611c3a576121ce82846121d3565b610c07565b60006121e16012600a61404e565b6121eb838561462e565b610c07919061464d565b60008183116122045781610c07565b5090919050565b600060027f0000000000000000000000000000000000000000000000000000000000000000600481111561224157612241613ef7565b1461224c5750600090565b50600190565b6000814211156122985760405162461bcd60e51b81526020600482015260116024820152701d1a5b595cdd185b5c08195e1c1a5c9959607a1b6044820152606401610788565b611e0e42836140b1565b606081516001600160401b038111156122bd576122bd613b2c565b60405190808252806020026020018201604052801561232057816020015b61230d6040518060a0016040528060008152602001600081526020016000815260200160008152602001600081525090565b8152602001906001900390816122db5790505b50905060005b8251811015611c3a57600354835160009182916001600160a01b039091169063c4c4a0d09087908690811061235d5761235d613f3e565b60200260200101516040518263ffffffff1660e01b815260040161238391815260200190565b60006040518083038186803b15801561239b57600080fd5b505afa1580156123af573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526123d79190810190614405565b915091506040518060a0016040528083600001518152602001826020015181526020018360200151815260200183604001518152602001826040015181525084848151811061242857612428613f3e565b6020026020010181905250505080806124409061425b565b915050612326565b600080612453611e14565b90506000806124786124688860200151612252565b8785600001518a60400151613112565b91509150612484611d71565b6124975761249281866121d3565b610654565b61065482866121d3565b6000848660600151146124b85785608001516124bb565b60005b905060006040518061012001604052808860200151815260200188600001518152602001600381526020017f0000000000000000000000000000000000000000000000000000000000000000600481111561251857612518613ef7565b8152602001878152602001838152602001868152602001858152602001846001600160a01b03168152509050600061254f8261325f565b905084816020015111156125b85760405162461bcd60e51b815260206004820152602a60248201527f7072656d69756d20706169642069732061626f7665206d6178206578706563746044820152696564207072656d69756d60b01b6064820152608401610788565b5050505050505050565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b600061261c611e14565b600a546040516370a0823160e01b81529192506000916001600160a01b03909116906370a0823190612652903090600401613b18565b60206040518083038186803b15801561266a57600080fd5b505afa15801561267e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906126a29190614242565b90506126ac61220b565b1561283c57600b546040516370a0823160e01b81526000916001600160a01b0316906370a08231906126e2903090600401613b18565b60206040518083038186803b1580156126fa57600080fd5b505afa15801561270e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906127329190614242565b60408401519091506000906127649061274d6012600a61404e565b61275791906140b1565b855161071b908690612e18565b9050600061277284836132a3565b600b549091506001600160a01b031663a9059cbb7f00000000000000000000000000000000000000000000000000000000000000006127b18487614099565b6040518363ffffffff1660e01b81526004016127ce9291906141cd565b602060405180830381600087803b1580156127e857600080fd5b505af11580156127fc573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061282091906141e6565b6118d65760405162461bcd60e51b81526004016107889061466f565b600a5460405163a9059cbb60e01b81526001600160a01b039091169063a9059cbb9061288e907f00000000000000000000000000000000000000000000000000000000000000009085906004016141cd565b602060405180830381600087803b1580156128a857600080fd5b505af11580156128bc573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906128e091906141e6565b6128fc5760405162461bcd60e51b81526004016107889061466f565b5050565b60105415610fc45760005b601054811015612a195760006010828154811061292a5761292a613f3e565b9060005260206000200154905060006129586106aa6011600085815260200190815260200160002054611aa6565b60008151811061296a5761296a613f3e565b602002602001015190506001600581111561298757612987613ef7565b8160a00151600581111561299d5761299d613ef7565b14156129ea5760405162461bcd60e51b815260206004820152601c60248201527b31b0b73737ba1031b632b0b91030b1ba34bb32903837b9b4ba34b7b760211b6044820152606401610788565b506000908152601160209081526040808320839055600f90915281205580612a118161425b565b91505061290b565b50610fc460106000613a51565b600080612a3883601260090154613362565b90506000612a4d612a4885611aa6565b611aed565b600081518110612a5f57612a5f613f3e565b60200260200101519050600081831015612a8257612a7d83836140b1565b612a8c565b612a8c82846140b1565b601a541195945050505050565b6000806000612ab386601260040154601260060154612448565b90506000612b5c60405180610120016040528089600001518152602001601160008b600001518152602001908152602001600020548152602001600381526020017f00000000000000000000000000000000000000000000000000000000000000006004811115612b2657612b26613ef7565b815260200160126006015481526020018881526020018481526020016000198152602001876001600160a01b03168152506133e6565b87516000908152600f6020526040902042905587518151919250612b7f91613561565b8181602001511015612bea5760405162461bcd60e51b815260206004820152602e60248201527f7072656d69756d2072656365697665642069732062656c6f77206d696e20657860448201526d706563746564207072656d69756d60901b6064820152608401610788565b80516020909101519097909650945050505050565b612c2a6040518060800160405280600081526020016000815260200160008152602001606081525090565b60035460405163016a54f560e41b8152600481018490526000916001600160a01b0316906316a54f509060240160006040518083038186803b158015612c6f57600080fd5b505afa158015612c83573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052612cab91908101906146b3565b60408051608080820183528351825260208085015190830152828401519282019290925291015160608201529392505050565b60015460035460405163c4158a5160e01b81526000926001600160a01b039081169263c4158a5192612d169290911690600401613b18565b6101606040518083038186803b158015612d2f57600080fd5b505afa158015612d43573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612d6791906146fa565b8051600580546001600160a01b03199081166001600160a01b03938416179091556040830151600980548316918416919091179055608083015160088054831691841691909117905560a083015160048054831691841691909117905560e0830151600680548316918416919091179055610100830151600780548316918416919091179055610120830151600a8054831691841691909117905561014090920151600b8054909316911617905550565b600081612e276012600a61404e565b6121eb908561462e565b612e636040518060a0016040528060008152602001600081526020016000815260200160008152602001600081525090565b600354604051630c4c4a0d60e41b81526004810184905260009182916001600160a01b039091169063c4c4a0d09060240160006040518083038186803b158015612eac57600080fd5b505afa158015612ec0573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052612ee89190810190614405565b915091506040518060a00160405280428360200151612f0791906140b1565b8152602001612f27846040015184604001516121d390919063ffffffff16565b8152600254600354604051630fb75cc960e31b81526020909301926001600160a01b0392831692637dbae64892612f6392911690600401613b18565b60206040518083038186803b158015612f7b57600080fd5b505afa158015612f8f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612fb39190614242565b815260200183602001518152602001600960009054906101000a90046001600160a01b03166001600160a01b031663f369f2ac6040518163ffffffff1660e01b81526004016101406040518083038186803b15801561301157600080fd5b505afa158015613025573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061304991906147d4565b61012001519052949350505050565b6009546000906001600160a01b031663a57ce68287600481111561307e5761307e613ef7565b600481111561308f5761308f613ef7565b878787876040518663ffffffff1660e01b81526004016130b395949392919061485b565b60206040518083038186803b1580156130cb57600080fd5b505afa1580156130df573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a9c9190614242565b60008183106122045781610c07565b60008060006040518060a00160405280888152602001878152602001868152602001858152602001600960009054906101000a90046001600160a01b03166001600160a01b031663f369f2ac6040518163ffffffff1660e01b81526004016101406040518083038186803b15801561318957600080fd5b505afa15801561319d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906131c191906147d4565b6101200151905260405163b6e62e5960e01b815290915073EAB60138D1C2160062bbcD881D153961865aA5109063b6e62e5990613202908490600401614456565b604080518083038186803b15801561321957600080fd5b505af415801561322d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906132519190614276565b909890975095505050505050565b613267613a6f565b8151613272906135b7565b1580156132875750815161328590613668565b155b1561329557611e0e82613700565b611e0e82613725565b919050565b60025460035460405163ae58cf0b60e01b81526000926001600160a01b039081169263ae58cf0b926132dd929091169087906004016141cd565b602060405180830381600087803b1580156132f757600080fd5b505af115801561330b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061332f9190614242565b905081811015611e0e57604051633c4976f160e21b81523060048201526024810183905260448101829052606401610788565b6007546040516339a427f160e01b815260048101849052602481018390526000916001600160a01b0316906339a427f19060440160206040518083038186803b1580156133ae57600080fd5b505afa1580156133c2573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c079190614242565b6133ee613a6f565b6003546000906001600160a01b03166237f2bc61340a85613746565b6040518263ffffffff1660e01b81526004016134269190614889565b606060405180830381600087803b15801561344057600080fd5b505af1158015613454573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061347891906148ed565b6101008401519091506001600160a01b03161561353b57600d546003546101008501516001600160a01b039283169263a4ed57819216906134b887613746565b60800151602086015160408088015190516001600160e01b031960e088901b1681526001600160a01b03958616600482015294909316602485015260448401919091526064830152608482015260a401600060405180830381600087803b15801561352257600080fd5b505af1158015613536573d6000803e3d6000fd5b505050505b604080516060810182528251815260208084015190820152918101519082015292915050565b6000828152601160205260409020546128fc576000828152601160205260408120919091556010805460018101825591527f1b6847dc741a1b0cd08d278845f9d819d87b734759afb55fe2de5cb82a9ae6720155565b6000806135c26137e2565b604080516001808252818301909252919250600091906020808301908036833701905050905083816000815181106135fc576135fc613f3e565b602002602001018181525050600061361382611c40565b60008151811061362557613625613f3e565b602002602001015190508260600151601260ff16600a613645919061404e565b61364f919061405a565b81138061365f5750826060015181125b95945050505050565b6000806136736137e2565b604080516001808252818301909252919250600091906020808301908036833701905050905083816000815181106136ad576136ad613f3e565b60200260200101818152505060006136c4826122a2565b6000815181106136d6576136d6613f3e565b6020026020010151905082608001514282602001516136f591906140b1565b111595945050505050565b613708613a6f565b6003546000906001600160a01b03166392b4632c61340a85613746565b61372d613a6f565b6003546000906001600160a01b031663e4e83e3d61340a855b61374e613a90565b6040518061010001604052808360000151815260200183602001518152602001836040015181526020018360600151600481111561378e5761378e613ef7565b600481111561379f5761379f613ef7565b60048111156137b0576137b0613ef7565b8152602001836080015181526020018360a0015181526020018360c0015181526020018360e001518152509050919050565b61381b6040518060c001604052806000815260200160008152602001600081526020016000815260200160008152602001600081525090565b6008546040805163da53763160e01b815290516000926001600160a01b03169163da53763191600480830192610120929190829003018186803b15801561386157600080fd5b505afa158015613875573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906138999190614948565b90506000600860009054906101000a90046001600160a01b03166001600160a01b031663ffae4b366040518163ffffffff1660e01b81526004016101806040518083038186803b1580156138ec57600080fd5b505afa158015613900573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906139249190614965565b90506040518060c001604052808360e0015181526020018361010001518152602001600960009054906101000a90046001600160a01b03166001600160a01b031663f369f2ac6040518163ffffffff1660e01b81526004016101406040518083038186803b15801561399557600080fd5b505afa1580156139a9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906139cd91906147d4565b61012001518152602001826000015181526020018260400151815260200182602001518152509250505090565b6040518060c00160405280600081526020016000815260200160006004811115613a2657613a26613ef7565b8152602001600081526020016000815260200160006005811115613a4c57613a4c613ef7565b905290565b50805460008255906000526020600020908101906110c69190613ae6565b60405180606001604052806000815260200160008152602001600081525090565b60405180610100016040528060008152602001600081526020016000815260200160006004811115613ac457613ac4613ef7565b8152602001600081526020016000815260200160008152602001600081525090565b5b80821115613afb5760008155600101613ae7565b5090565b600060208284031215613b1157600080fd5b5035919050565b6001600160a01b0391909116815260200190565b634e487b7160e01b600052604160045260246000fd5b60405160a081016001600160401b0381118282101715613b6457613b64613b2c565b60405290565b60405161018081016001600160401b0381118282101715613b6457613b64613b2c565b60405160c081016001600160401b0381118282101715613b6457613b64613b2c565b60405161012081016001600160401b0381118282101715613b6457613b64613b2c565b60405161016081016001600160401b0381118282101715613b6457613b64613b2c565b60405161014081016001600160401b0381118282101715613b6457613b64613b2c565b604051601f8201601f191681016001600160401b0381118282101715613c4057613c40613b2c565b604052919050565b600060a08284031215613c5a57600080fd5b613c62613b42565b82358152602083013560208201526040830135604082015260608301356060820152608083013560808201528091505092915050565b60006101808284031215613cab57600080fd5b613cb3613b6a565b823581526020830135602082015260408301356040820152606083013560608201526080830135608082015260a083013560a082015260c083013560c082015260e083013560e08201526101008084013581830152506101208084013581830152506101408084013581830152506101608084013581830152508091505092915050565b6001600160a01b03811681146110c657600080fd5b60008060008060808587031215613d6257600080fd5b8435613d6d81613d37565b93506020850135613d7d81613d37565b92506040850135613d8d81613d37565b91506060850135613d9d81613d37565b939692955090935050565b600080600060608486031215613dbd57600080fd5b83359250602084013591506040840135613dd681613d37565b809150509250925092565b600060208284031215613df357600080fd5b8135610c0781613d37565b60008060408385031215613e1157600080fd5b823591506020830135613e2381613d37565b809150509250929050565b60008060408385031215613e4157600080fd5b50508035926020909101359150565b600581106110c657600080fd5b600681106110c657600080fd5b6000806000838503610100811215613e8157600080fd5b60c0811215613e8f57600080fd5b50613e98613b8d565b84358152602085013560208201526040850135613eb481613e50565b80604083015250606085013560608201526080850135608082015260a0850135613edd81613e5d565b60a08201529560c0850135955060e0909401359392505050565b634e487b7160e01b600052602160045260246000fd5b600581106110c657634e487b7160e01b600052602160045260246000fd5b60208101613f3883613f0d565b91905290565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052601160045260246000fd5b600181815b80851115613fa5578160001904821115613f8b57613f8b613f54565b80851615613f9857918102915b93841c9390800290613f6f565b509250929050565b600082613fbc57506001611e0e565b81613fc957506000611e0e565b8160018114613fdf5760028114613fe957614005565b6001915050611e0e565b60ff841115613ffa57613ffa613f54565b50506001821b611e0e565b5060208310610133831016604e8410600b8410161715614028575081810a611e0e565b6140328383613f6a565b806000190482111561404657614046613f54565b029392505050565b6000610c078383613fad565b60008083128015600160ff1b85018412161561407857614078613f54565b6001600160ff1b038401831381161561409357614093613f54565b50500390565b600082198211156140ac576140ac613f54565b500190565b6000828210156140c3576140c3613f54565b500390565b6020808252818101527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604082015260600190565b80516001600160681b038116811461329e57600080fd5b80516001600160801b038116811461329e57600080fd5b8051801515811461329e57600080fd5b600080600080600080600080610100898b03121561415857600080fd5b885161ffff8116811461416a57600080fd5b975061417860208a016140fd565b965061418660408a016140fd565b95506060890151945061419b60808a01614114565b93506141a960a08a01614114565b925060c089015191506141be60e08a0161412b565b90509295985092959890939650565b6001600160a01b03929092168252602082015260400190565b6000602082840312156141f857600080fd5b610c078261412b565b60006020828403121561421357600080fd5b8151610c0781613d37565b6020808252600a90820152691bdb9b1e4815985d5b1d60b21b604082015260600190565b60006020828403121561425457600080fd5b5051919050565b600060001982141561426f5761426f613f54565b5060010190565b6000806040838503121561428957600080fd5b505080516020909101519092909150565b600061012082840312156142ad57600080fd5b6142b5613baf565b9050815181526020820151602082015260408201516040820152606082015160608201526080820151608082015260a082015160a082015260c082015160c082015260e082015160e082015261010080830151818301525092915050565b60006001600160401b0382111561432c5761432c613b2c565b5060051b60200190565b600060a0828403121561434857600080fd5b614350613b42565b90508151815260208083015181830152604083015160408301526143766060840161412b565b606083015260808301516001600160401b0381111561439457600080fd5b8301601f810185136143a557600080fd5b80516143b86143b382614313565b613c18565b81815260059190911b820183019083810190878311156143d757600080fd5b928401925b828410156143f5578351825292840192908401906143dc565b6080860152509295945050505050565b600080610140838503121561441957600080fd5b614423848461429a565b6101208401519092506001600160401b0381111561444057600080fd5b61444c85828601614336565b9150509250929050565b600060a082019050825182526020830151602083015260408301516040830152606083015160608301526080830151608083015292915050565b6000600160ff1b8214156144a6576144a6613f54565b5060000390565b600060a082840312156144bf57600080fd5b6144c7613b42565b82518152602083015160208201526040830151604082015260608301516060820152608083015160808201528091505092915050565b6020808252825182820181905260009190848201906040850190845b8181101561453557835183529284019291840191600101614519565b50909695505050505050565b6000602080838503121561455457600080fd5b82516001600160401b0381111561456a57600080fd5b8301601f8101851361457b57600080fd5b80516145896143b382614313565b81815260c091820283018401918482019190888411156145a857600080fd5b938501935b838510156146225780858a0312156145c55760008081fd5b6145cd613b8d565b8551815286860151878201526040808701516145e881613e50565b90820152606086810151908201526080808701519082015260a08087015161460f81613e5d565b90820152835293840193918501916145ad565b50979650505050505050565b600081600019048311821515161561464857614648613f54565b500290565b60008261466a57634e487b7160e01b600052601260045260246000fd5b500490565b60208082526024908201527f6661696c656420746f2072657475726e2066756e64732066726f6d20737472616040820152637465677960e01b606082015260800190565b6000602082840312156146c557600080fd5b81516001600160401b038111156146db57600080fd5b6146e784828501614336565b949350505050565b805161329e81613d37565b6000610160828403121561470d57600080fd5b614715613bd2565b61471e836146ef565b815261472c602084016146ef565b602082015261473d604084016146ef565b604082015261474e606084016146ef565b606082015261475f608084016146ef565b608082015261477060a084016146ef565b60a082015261478160c084016146ef565b60c082015261479260e084016146ef565b60e08201526101006147a58185016146ef565b908201526101206147b78482016146ef565b908201526101406147c98482016146ef565b908201529392505050565b600061014082840312156147e757600080fd5b6147ef613bf5565b825181526020830151602082015260408301516040820152606083015160608201526080830151608082015260a083015160a082015260c083015160c082015260e083015160e08201526101008084015181830152506101208084015181830152508091505092915050565b60a0810161486887613f0d565b95815260208101949094526040840192909252606083015260809091015290565b60006101008201905082518252602083015160208301526040830151604083015260608301516148b881613f0d565b806060840152506080830151608083015260a083015160a083015260c083015160c083015260e083015160e083015292915050565b6000606082840312156148ff57600080fd5b604051606081016001600160401b038111828210171561492157614921613b2c565b80604052508251815260208301516020820152604083015160408201528091505092915050565b6000610120828403121561495b57600080fd5b610c07838361429a565b6000610180828403121561497857600080fd5b614980613b6a565b825181526020830151602082015260408301516040820152606083015160608201526080830151608082015260a083015160a082015260c083015160c082015260e083015160e08201526101008084015181830152506101208084015181830152506101408084015181830152506101606147c981850161412b56fea2646970667358221220cb8a35dec02402203437cf46f385ae29a24c3c215368a69eeab7a9eda93c548f64736f6c63430008090033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106101b75760003560e01c806303c4d3d6146101bc578063131b2f86146101d85780632a37ad5a146101f85780632bab754b1461028757806338b74054146102a7578063478620c0146102ba57806354f1e01f146102dd57806357949815146103055780635a3c76ab146103185780635cf035491461032d578063619a84cc14610340578063621318cd14610348578063665a11ca1461035b5780637083a9041461036e578063715018a6146103815780637dd0db1b1461038957806383cea5421461039c578063870dcaeb146103a45780638da5cb5b146103b7578063a65be9ba146103bf578063a8c379c2146103d2578063aabaecd614610400578063ae74fc4d14610413578063b5ca94a014610426578063bb4a9f8814610439578063bc4e44051461044c578063cae1c5821461045f578063cdf456e114610472578063d4aaa9eb14610485578063d8fca1ac146104a5578063dffcf353146104b8578063ee9e0e6a146104cb578063f2fde38b146104de578063fbfa77cf146104f1578063fdf262b714610518578063ffcd00ac1461052b578063ffd9eedb1461053e575b600080fd5b6101c5601e5481565b6040519081526020015b60405180910390f35b6101c56101e6366004613aff565b600f6020526000908152604090205481565b601254601354601454601554601654601754601854601954601a54601b54601c54601d5461022e9b9a999897969594939291908c565b604080519c8d5260208d019b909b52998b019890985260608a0196909652608089019490945260a088019290925260c087015260e0860152610100850152610120840152610140830152610160820152610180016101cf565b60045461029a906001600160a01b031681565b6040516101cf9190613b18565b60095461029a906001600160a01b031681565b6102cd6102c8366004613c48565b610572565b60405190151581526020016101cf565b6102f06102eb366004613c48565b61065f565b604080519283526020830191909152016101cf565b600d5461029a906001600160a01b031681565b61032b610326366004613c98565b610759565b005b61032b61033b366004613d4c565b6108f1565b61032b610aca565b6102cd610356366004613aff565b610be4565b60055461029a906001600160a01b031681565b61032b61037c366004613da8565b610c0e565b61032b610f8b565b61032b610397366004613de1565b610fc6565b61032b6110c9565b60065461029a906001600160a01b031681565b61029a611121565b60075461029a906001600160a01b031681565b6103e56103e0366004613dfe565b611130565b604080519384526020840192909252908201526060016101cf565b600e5461029a906001600160a01b031681565b61032b610421366004613aff565b6113d6565b61032b610434366004613d4c565b61147e565b60035461029a906001600160a01b031681565b6101c561045a366004613aff565b6118dd565b60085461029a906001600160a01b031681565b600b5461029a906001600160a01b031681565b6101c5610493366004613aff565b60116020526000908152604090205481565b600c5461029a906001600160a01b031681565b6102f06104c6366004613e2e565b6118fe565b60015461029a906001600160a01b031681565b61032b6104ec366004613de1565b611990565b61029a7f000000000000000000000000000000000000000000000000000000000000000081565b600a5461029a906001600160a01b031681565b6101c5610539366004613e6a565b611a2d565b6105657f000000000000000000000000000000000000000000000000000000000000000081565b6040516101cf9190613f2b565b60008160200151601e541461058957506000919050565b60006105988360000151611aa6565b905060006105a582611aed565b6000815181106105b7576105b7613f3e565b6020026020010151905060006105cc83611c40565b6000815181106105de576105de613f3e565b6020026020010151905060006105f2611d71565b610611576106026012600a61404e565b61060c908361405a565b610613565b815b905060006106308260126002015461062b919061405a565b611df4565b601654909150841080159061064757506017548411155b8015610654575060155481105b979650505050505050565b601854600090819081610670611e14565b8551600090815260116020526040812054919250908190156106db5786516000908152601160205260408120546106af906106aa90611aa6565b611ee7565b6000815181106106c1576106c1613f3e565b602002602001015190508060800151915080606001519250505b600061070088604001518960200151866000015188876106fb9190614099565b61214c565b905060006107216012600b015461071b8b60400151896121b6565b906121d3565b61072b9084614099565b905061074061073a83836121f5565b846121f5565b965061074c83886140b1565b9750505050505050915091565b33610762611121565b6001600160a01b0316146107915760405162461bcd60e51b8152600401610788906140c8565b60405180910390fd5b60007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316632728f3336040518163ffffffff1660e01b81526004016101006040518083038186803b1580156107ed57600080fd5b505afa158015610801573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610825919061413b565b975050505050505050801561088e5760405162461bcd60e51b815260206004820152602960248201527f63616e6e6f74206368616e676520737472617465677920696620726f756e642060448201526869732061637469766560b81b6064820152608401610788565b508051601255602081015160135560408101516014556060810151601555608081015160165560a081015160175560c081015160185560e0810151601955610100810151601a55610120810151601b55610140810151601c556101600151601d55565b336108fa611121565b6001600160a01b0316146109205760405162461bcd60e51b8152600401610788906140c8565b61092c8484848461147e565b600a5460405163095ea7b360e01b81526001600160a01b039091169063095ea7b390610980907f000000000000000000000000000000000000000000000000000000000000000090600019906004016141cd565b602060405180830381600087803b15801561099a57600080fd5b505af11580156109ae573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109d291906141e6565b50600b5460405163095ea7b360e01b81526001600160a01b039091169063095ea7b390610a27907f000000000000000000000000000000000000000000000000000000000000000090600019906004016141cd565b602060405180830381600087803b158015610a4157600080fd5b505af1158015610a55573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a7991906141e6565b50610a8261220b565b610a9757600a546001600160a01b0316610aa4565b600b546001600160a01b03165b600e80546001600160a01b0319166001600160a01b039290921691909117905550505050565b33610ad3611121565b6001600160a01b031614610af95760405162461bcd60e51b8152600401610788906140c8565b600260009054906101000a90046001600160a01b03166001600160a01b0316633535c97b6040518163ffffffff1660e01b815260040160206040518083038186803b158015610b4757600080fd5b505afa158015610b5b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b7f9190614201565b60025460405163447fbc6360e01b81526001600160a01b039283169263447fbc6392610bb092911690600401613b18565b600060405180830381600087803b158015610bca57600080fd5b505af1158015610bde573d6000803e3d6000fd5b50505050565b600080610bf083612252565b6012549091508110801590610c0757506013548111155b9392505050565b336001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614610c565760405162461bcd60e51b81526004016107889061421e565b6000610c646106aa85611aa6565b600081518110610c7657610c76613f3e565b602002602001015190506000610c97610c928360200151611aa6565b6122a2565b600081518110610ca957610ca9613f3e565b602002602001015190508460116000846020015181526020019081526020016000205414610d0e5760405162461bcd60e51b81526020600482015260126024820152711a5b9d985b1a59081c1bdcda5d1a5bdb925960721b6044820152606401610788565b610d218282604001518360200151611a2d565b841115610d7c5760405162461bcd60e51b815260206004820152602360248201527f616d6f756e74206578636565647320616c6c6f77656420636c6f736520616d6f6044820152621d5b9d60ea1b6064820152608401610788565b6000610d9382601260050154601260060154612448565b9050610da38386600084886124a1565b610dab61220b565b15610edd57600b546040516370a0823160e01b81526000916001600160a01b0316906370a0823190610de1903090600401613b18565b60206040518083038186803b158015610df957600080fd5b505afa158015610e0d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e319190614242565b600b5460405163a9059cbb60e01b81529192506001600160a01b03169063a9059cbb90610e84907f00000000000000000000000000000000000000000000000000000000000000009085906004016141cd565b602060405180830381600087803b158015610e9e57600080fd5b505af1158015610eb2573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ed691906141e6565b5050610f83565b600a5460405163a9059cbb60e01b81526001600160a01b039091169063a9059cbb90610f2f907f00000000000000000000000000000000000000000000000000000000000000009089906004016141cd565b602060405180830381600087803b158015610f4957600080fd5b505af1158015610f5d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f8191906141e6565b505b505050505050565b33610f94611121565b6001600160a01b031614610fba5760405162461bcd60e51b8152600401610788906140c8565b610fc460006125c2565b565b336001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000161461100e5760405162461bcd60e51b81526004016107889061421e565b60005b6010548110156110bd5760006010828154811061103057611030613f3e565b90600052602060002001549050600061105e6106aa6011600085815260200190815260200160002054611aa6565b60008151811061107057611070613f3e565b6020026020010151905061108e8182606001516000600019886124a1565b506000908152601160209081526040808320839055600f909152812055806110b58161425b565b915050611011565b506110c6612612565b50565b336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146111115760405162461bcd60e51b81526004016107889061421e565b611119612612565b610fc4612900565b6000546001600160a01b031690565b60008080336001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000161461117c5760405162461bcd60e51b81526004016107889061421e565b6019546000868152600f6020526040902054429161119991614099565b11156111e65760405162461bcd60e51b815260206004820152601c60248201527b1b5a5b881d1a5b59481a5b9d195c9d985b081b9bdd081c185cdcd95960221b6044820152606401610788565b6111ef85612a26565b6112335760405162461bcd60e51b81526020600482015260156024820152741d9bdb081d985c9a585b98d948195e18d959591959605a1b6044820152606401610788565b6000611241610c9287611aa6565b60008151811061125357611253613f3e565b6020026020010151905061126681610572565b6112a35760405162461bcd60e51b815260206004820152600e60248201526d696e76616c696420737472696b6560901b6044820152606401610788565b60006112ae8261065f565b600e546040516323b872dd60e01b81526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000811660048301523060248301526044820185905293965091935091909116906323b872dd90606401602060405180830381600087803b15801561132957600080fd5b505af115801561133d573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061136191906141e6565b6113bb5760405162461bcd60e51b815260206004820152602560248201527f636f6c6c61746572616c207472616e736665722066726f6d207661756c742066604482015264185a5b195960da1b6064820152608401610788565b6113c6828288612a99565b9098909750929550919350505050565b336001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000161461141e5760405162461bcd60e51b81526004016107889061421e565b600061142982612bff565b90506114388160200151610be4565b6114745760405162461bcd60e51b815260206004820152600d60248201526c1a5b9d985b1a5908189bd85c99609a1b6044820152606401610788565b60200151601e5550565b33611487611121565b6001600160a01b0316146114ad5760405162461bcd60e51b8152600401610788906140c8565b600a546001600160a01b03161561154957600a5460035460405163095ea7b360e01b81526001600160a01b039283169263095ea7b3926114f5929116906000906004016141cd565b602060405180830381600087803b15801561150f57600080fd5b505af1158015611523573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061154791906141e6565b505b600b546001600160a01b0316156115e557600b5460035460405163095ea7b360e01b81526001600160a01b039283169263095ea7b392611591929116906000906004016141cd565b602060405180830381600087803b1580156115ab57600080fd5b505af11580156115bf573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115e391906141e6565b505b600380546001600160a01b038581166001600160a01b031992831617909255600180549287169290911682179055604051623f970360e91b81527029aca72a2422aa24ac2fa0a220a82a22a960791b6004820152637f2e06009060240160206040518083038186803b15801561165a57600080fd5b505afa15801561166e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906116929190614201565b600280546001600160a01b0319166001600160a01b03929092169190911790556116ba612cde565b600c80546001600160a01b038085166001600160a01b031992831617909255600d8054848416921691909117905560025460408051633535c97b60e01b815290519190921691633535c97b916004808301926020929190829003018186803b15801561172557600080fd5b505afa158015611739573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061175d9190614201565b60025460405163447fbc6360e01b81526001600160a01b039283169263447fbc639261178e92911690600401613b18565b600060405180830381600087803b1580156117a857600080fd5b505af11580156117bc573d6000803e3d6000fd5b5050600a5460035460405163095ea7b360e01b81526001600160a01b03928316945063095ea7b393506117f99290911690600019906004016141cd565b602060405180830381600087803b15801561181357600080fd5b505af1158015611827573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061184b91906141e6565b50600b5460035460405163095ea7b360e01b81526001600160a01b039283169263095ea7b39261188492911690600019906004016141cd565b602060405180830381600087803b15801561189e57600080fd5b505af11580156118b2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906118d691906141e6565b5050505050565b601081815481106118ed57600080fd5b600091825260209091200154905081565b60075460405163ca4ca66760e01b8152600481018490526024810183905260009182916001600160a01b039091169063ca4ca66790604401604080518083038186803b15801561194d57600080fd5b505afa158015611961573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119859190614276565b915091509250929050565b33611999611121565b6001600160a01b0316146119bf5760405162461bcd60e51b8152600401610788906140c8565b6001600160a01b038116611a245760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b6064820152608401610788565b6110c6816125c2565b600080611a38611e14565b90506000611a5485858460000151670de0b6b3a764000061214c565b9050611a6d8660600151826121d390919063ffffffff16565b866080015110611a7e576000611a9c565b6080860151611a8d9082612e18565b8660600151611a9c91906140b1565b9695505050505050565b604080516001808252818301909252606091602080830190803683370190505090508181600081518110611adc57611adc613f3e565b602002602001018181525050919050565b606081516001600160401b03811115611b0857611b08613b2c565b604051908082528060200260200182016040528015611b31578160200160208202803683370190505b50905060005b8251811015611c3a57600354835160009182916001600160a01b039091169063c4c4a0d090879086908110611b6e57611b6e613f3e565b60200260200101516040518263ffffffff1660e01b8152600401611b9491815260200190565b60006040518083038186803b158015611bac57600080fd5b505afa158015611bc0573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052611be89190810190614405565b91509150611c07826040015182604001516121d390919063ffffffff16565b848481518110611c1957611c19613f3e565b60200260200101818152505050508080611c329061425b565b915050611b37565b50919050565b606081516001600160401b03811115611c5b57611c5b613b2c565b604051908082528060200260200182016040528015611c84578160200160208202803683370190505b50905060005b8251811015611c3a576000611cb7848381518110611caa57611caa613f3e565b6020026020010151612e31565b604051634698f9d560e11b815290915073__$c0a17acec7091fec39628aa0eae1394872$__90638d31f3aa90611cf1908490600401614456565b604080518083038186803b158015611d0857600080fd5b505af4158015611d1c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d409190614276565b50838381518110611d5357611d53613f3e565b60209081029190910101525080611d698161425b565b915050611c8a565b600060047f00000000000000000000000000000000000000000000000000000000000000006004811115611da757611da7613ef7565b1480611de4575060017f00000000000000000000000000000000000000000000000000000000000000006004811115611de257611de2613ef7565b145b611dee5750600190565b50600090565b600080821215611e0c57611e0782614490565b611e0e565b815b92915050565b611e3860405180606001604052806000815260200160008152602001600081525090565b6002546003546040516333ef9fd160e21b81526000926001600160a01b039081169263cfbe7f4492611e709290911690600401613b18565b60a06040518083038186803b158015611e8857600080fd5b505afa158015611e9c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ec091906144ad565b60408051606080820183528351825283015160208201526080909201519082015292915050565b600480546040516323d3547760e01b81526060926000926001600160a01b0316916323d3547791611f1a918791016144fd565b60006040518083038186803b158015611f3257600080fd5b505afa158015611f46573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052611f6e9190810190614541565b9050600081516001600160401b03811115611f8b57611f8b613b2c565b604051908082528060200260200182016040528015611fc457816020015b611fb16139fa565b815260200190600190039081611fa95790505b50905060005b8251811015612144576040518060c00160405280848381518110611ff057611ff0613f3e565b602002602001015160000151815260200184838151811061201357612013613f3e565b602002602001015160200151815260200184838151811061203657612036613f3e565b602002602001015160400151600481111561205357612053613ef7565b600481111561206457612064613ef7565b600481111561207557612075613ef7565b815260200184838151811061208c5761208c613f3e565b60200260200101516060015181526020018483815181106120af576120af613f3e565b60200260200101516080015181526020018483815181106120d2576120d2613f3e565b602002602001015160a0015160058111156120ef576120ef613ef7565b600581111561210057612100613ef7565b600581111561211157612111613ef7565b81525082828151811061212657612126613f3e565b6020026020010181905250808061213c9061425b565b915050611fca565b509392505050565b60008061217c7f000000000000000000000000000000000000000000000000000000000000000087878787613058565b601c549091506000906121909083906121d3565b9050600061219e88866121b6565b90506121aa8282613103565b98975050505050505050565b60006121c061220b565b611c3a576121ce82846121d3565b610c07565b60006121e16012600a61404e565b6121eb838561462e565b610c07919061464d565b60008183116122045781610c07565b5090919050565b600060027f0000000000000000000000000000000000000000000000000000000000000000600481111561224157612241613ef7565b1461224c5750600090565b50600190565b6000814211156122985760405162461bcd60e51b81526020600482015260116024820152701d1a5b595cdd185b5c08195e1c1a5c9959607a1b6044820152606401610788565b611e0e42836140b1565b606081516001600160401b038111156122bd576122bd613b2c565b60405190808252806020026020018201604052801561232057816020015b61230d6040518060a0016040528060008152602001600081526020016000815260200160008152602001600081525090565b8152602001906001900390816122db5790505b50905060005b8251811015611c3a57600354835160009182916001600160a01b039091169063c4c4a0d09087908690811061235d5761235d613f3e565b60200260200101516040518263ffffffff1660e01b815260040161238391815260200190565b60006040518083038186803b15801561239b57600080fd5b505afa1580156123af573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526123d79190810190614405565b915091506040518060a0016040528083600001518152602001826020015181526020018360200151815260200183604001518152602001826040015181525084848151811061242857612428613f3e565b6020026020010181905250505080806124409061425b565b915050612326565b600080612453611e14565b90506000806124786124688860200151612252565b8785600001518a60400151613112565b91509150612484611d71565b6124975761249281866121d3565b610654565b61065482866121d3565b6000848660600151146124b85785608001516124bb565b60005b905060006040518061012001604052808860200151815260200188600001518152602001600381526020017f0000000000000000000000000000000000000000000000000000000000000000600481111561251857612518613ef7565b8152602001878152602001838152602001868152602001858152602001846001600160a01b03168152509050600061254f8261325f565b905084816020015111156125b85760405162461bcd60e51b815260206004820152602a60248201527f7072656d69756d20706169642069732061626f7665206d6178206578706563746044820152696564207072656d69756d60b01b6064820152608401610788565b5050505050505050565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b600061261c611e14565b600a546040516370a0823160e01b81529192506000916001600160a01b03909116906370a0823190612652903090600401613b18565b60206040518083038186803b15801561266a57600080fd5b505afa15801561267e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906126a29190614242565b90506126ac61220b565b1561283c57600b546040516370a0823160e01b81526000916001600160a01b0316906370a08231906126e2903090600401613b18565b60206040518083038186803b1580156126fa57600080fd5b505afa15801561270e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906127329190614242565b60408401519091506000906127649061274d6012600a61404e565b61275791906140b1565b855161071b908690612e18565b9050600061277284836132a3565b600b549091506001600160a01b031663a9059cbb7f00000000000000000000000000000000000000000000000000000000000000006127b18487614099565b6040518363ffffffff1660e01b81526004016127ce9291906141cd565b602060405180830381600087803b1580156127e857600080fd5b505af11580156127fc573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061282091906141e6565b6118d65760405162461bcd60e51b81526004016107889061466f565b600a5460405163a9059cbb60e01b81526001600160a01b039091169063a9059cbb9061288e907f00000000000000000000000000000000000000000000000000000000000000009085906004016141cd565b602060405180830381600087803b1580156128a857600080fd5b505af11580156128bc573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906128e091906141e6565b6128fc5760405162461bcd60e51b81526004016107889061466f565b5050565b60105415610fc45760005b601054811015612a195760006010828154811061292a5761292a613f3e565b9060005260206000200154905060006129586106aa6011600085815260200190815260200160002054611aa6565b60008151811061296a5761296a613f3e565b602002602001015190506001600581111561298757612987613ef7565b8160a00151600581111561299d5761299d613ef7565b14156129ea5760405162461bcd60e51b815260206004820152601c60248201527b31b0b73737ba1031b632b0b91030b1ba34bb32903837b9b4ba34b7b760211b6044820152606401610788565b506000908152601160209081526040808320839055600f90915281205580612a118161425b565b91505061290b565b50610fc460106000613a51565b600080612a3883601260090154613362565b90506000612a4d612a4885611aa6565b611aed565b600081518110612a5f57612a5f613f3e565b60200260200101519050600081831015612a8257612a7d83836140b1565b612a8c565b612a8c82846140b1565b601a541195945050505050565b6000806000612ab386601260040154601260060154612448565b90506000612b5c60405180610120016040528089600001518152602001601160008b600001518152602001908152602001600020548152602001600381526020017f00000000000000000000000000000000000000000000000000000000000000006004811115612b2657612b26613ef7565b815260200160126006015481526020018881526020018481526020016000198152602001876001600160a01b03168152506133e6565b87516000908152600f6020526040902042905587518151919250612b7f91613561565b8181602001511015612bea5760405162461bcd60e51b815260206004820152602e60248201527f7072656d69756d2072656365697665642069732062656c6f77206d696e20657860448201526d706563746564207072656d69756d60901b6064820152608401610788565b80516020909101519097909650945050505050565b612c2a6040518060800160405280600081526020016000815260200160008152602001606081525090565b60035460405163016a54f560e41b8152600481018490526000916001600160a01b0316906316a54f509060240160006040518083038186803b158015612c6f57600080fd5b505afa158015612c83573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052612cab91908101906146b3565b60408051608080820183528351825260208085015190830152828401519282019290925291015160608201529392505050565b60015460035460405163c4158a5160e01b81526000926001600160a01b039081169263c4158a5192612d169290911690600401613b18565b6101606040518083038186803b158015612d2f57600080fd5b505afa158015612d43573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612d6791906146fa565b8051600580546001600160a01b03199081166001600160a01b03938416179091556040830151600980548316918416919091179055608083015160088054831691841691909117905560a083015160048054831691841691909117905560e0830151600680548316918416919091179055610100830151600780548316918416919091179055610120830151600a8054831691841691909117905561014090920151600b8054909316911617905550565b600081612e276012600a61404e565b6121eb908561462e565b612e636040518060a0016040528060008152602001600081526020016000815260200160008152602001600081525090565b600354604051630c4c4a0d60e41b81526004810184905260009182916001600160a01b039091169063c4c4a0d09060240160006040518083038186803b158015612eac57600080fd5b505afa158015612ec0573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052612ee89190810190614405565b915091506040518060a00160405280428360200151612f0791906140b1565b8152602001612f27846040015184604001516121d390919063ffffffff16565b8152600254600354604051630fb75cc960e31b81526020909301926001600160a01b0392831692637dbae64892612f6392911690600401613b18565b60206040518083038186803b158015612f7b57600080fd5b505afa158015612f8f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612fb39190614242565b815260200183602001518152602001600960009054906101000a90046001600160a01b03166001600160a01b031663f369f2ac6040518163ffffffff1660e01b81526004016101406040518083038186803b15801561301157600080fd5b505afa158015613025573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061304991906147d4565b61012001519052949350505050565b6009546000906001600160a01b031663a57ce68287600481111561307e5761307e613ef7565b600481111561308f5761308f613ef7565b878787876040518663ffffffff1660e01b81526004016130b395949392919061485b565b60206040518083038186803b1580156130cb57600080fd5b505afa1580156130df573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a9c9190614242565b60008183106122045781610c07565b60008060006040518060a00160405280888152602001878152602001868152602001858152602001600960009054906101000a90046001600160a01b03166001600160a01b031663f369f2ac6040518163ffffffff1660e01b81526004016101406040518083038186803b15801561318957600080fd5b505afa15801561319d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906131c191906147d4565b6101200151905260405163b6e62e5960e01b815290915073__$c0a17acec7091fec39628aa0eae1394872$__9063b6e62e5990613202908490600401614456565b604080518083038186803b15801561321957600080fd5b505af415801561322d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906132519190614276565b909890975095505050505050565b613267613a6f565b8151613272906135b7565b1580156132875750815161328590613668565b155b1561329557611e0e82613700565b611e0e82613725565b919050565b60025460035460405163ae58cf0b60e01b81526000926001600160a01b039081169263ae58cf0b926132dd929091169087906004016141cd565b602060405180830381600087803b1580156132f757600080fd5b505af115801561330b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061332f9190614242565b905081811015611e0e57604051633c4976f160e21b81523060048201526024810183905260448101829052606401610788565b6007546040516339a427f160e01b815260048101849052602481018390526000916001600160a01b0316906339a427f19060440160206040518083038186803b1580156133ae57600080fd5b505afa1580156133c2573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c079190614242565b6133ee613a6f565b6003546000906001600160a01b03166237f2bc61340a85613746565b6040518263ffffffff1660e01b81526004016134269190614889565b606060405180830381600087803b15801561344057600080fd5b505af1158015613454573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061347891906148ed565b6101008401519091506001600160a01b03161561353b57600d546003546101008501516001600160a01b039283169263a4ed57819216906134b887613746565b60800151602086015160408088015190516001600160e01b031960e088901b1681526001600160a01b03958616600482015294909316602485015260448401919091526064830152608482015260a401600060405180830381600087803b15801561352257600080fd5b505af1158015613536573d6000803e3d6000fd5b505050505b604080516060810182528251815260208084015190820152918101519082015292915050565b6000828152601160205260409020546128fc576000828152601160205260408120919091556010805460018101825591527f1b6847dc741a1b0cd08d278845f9d819d87b734759afb55fe2de5cb82a9ae6720155565b6000806135c26137e2565b604080516001808252818301909252919250600091906020808301908036833701905050905083816000815181106135fc576135fc613f3e565b602002602001018181525050600061361382611c40565b60008151811061362557613625613f3e565b602002602001015190508260600151601260ff16600a613645919061404e565b61364f919061405a565b81138061365f5750826060015181125b95945050505050565b6000806136736137e2565b604080516001808252818301909252919250600091906020808301908036833701905050905083816000815181106136ad576136ad613f3e565b60200260200101818152505060006136c4826122a2565b6000815181106136d6576136d6613f3e565b6020026020010151905082608001514282602001516136f591906140b1565b111595945050505050565b613708613a6f565b6003546000906001600160a01b03166392b4632c61340a85613746565b61372d613a6f565b6003546000906001600160a01b031663e4e83e3d61340a855b61374e613a90565b6040518061010001604052808360000151815260200183602001518152602001836040015181526020018360600151600481111561378e5761378e613ef7565b600481111561379f5761379f613ef7565b60048111156137b0576137b0613ef7565b8152602001836080015181526020018360a0015181526020018360c0015181526020018360e001518152509050919050565b61381b6040518060c001604052806000815260200160008152602001600081526020016000815260200160008152602001600081525090565b6008546040805163da53763160e01b815290516000926001600160a01b03169163da53763191600480830192610120929190829003018186803b15801561386157600080fd5b505afa158015613875573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906138999190614948565b90506000600860009054906101000a90046001600160a01b03166001600160a01b031663ffae4b366040518163ffffffff1660e01b81526004016101806040518083038186803b1580156138ec57600080fd5b505afa158015613900573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906139249190614965565b90506040518060c001604052808360e0015181526020018361010001518152602001600960009054906101000a90046001600160a01b03166001600160a01b031663f369f2ac6040518163ffffffff1660e01b81526004016101406040518083038186803b15801561399557600080fd5b505afa1580156139a9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906139cd91906147d4565b61012001518152602001826000015181526020018260400151815260200182602001518152509250505090565b6040518060c00160405280600081526020016000815260200160006004811115613a2657613a26613ef7565b8152602001600081526020016000815260200160006005811115613a4c57613a4c613ef7565b905290565b50805460008255906000526020600020908101906110c69190613ae6565b60405180606001604052806000815260200160008152602001600081525090565b60405180610100016040528060008152602001600081526020016000815260200160006004811115613ac457613ac4613ef7565b8152602001600081526020016000815260200160008152602001600081525090565b5b80821115613afb5760008155600101613ae7565b5090565b600060208284031215613b1157600080fd5b5035919050565b6001600160a01b0391909116815260200190565b634e487b7160e01b600052604160045260246000fd5b60405160a081016001600160401b0381118282101715613b6457613b64613b2c565b60405290565b60405161018081016001600160401b0381118282101715613b6457613b64613b2c565b60405160c081016001600160401b0381118282101715613b6457613b64613b2c565b60405161012081016001600160401b0381118282101715613b6457613b64613b2c565b60405161016081016001600160401b0381118282101715613b6457613b64613b2c565b60405161014081016001600160401b0381118282101715613b6457613b64613b2c565b604051601f8201601f191681016001600160401b0381118282101715613c4057613c40613b2c565b604052919050565b600060a08284031215613c5a57600080fd5b613c62613b42565b82358152602083013560208201526040830135604082015260608301356060820152608083013560808201528091505092915050565b60006101808284031215613cab57600080fd5b613cb3613b6a565b823581526020830135602082015260408301356040820152606083013560608201526080830135608082015260a083013560a082015260c083013560c082015260e083013560e08201526101008084013581830152506101208084013581830152506101408084013581830152506101608084013581830152508091505092915050565b6001600160a01b03811681146110c657600080fd5b60008060008060808587031215613d6257600080fd5b8435613d6d81613d37565b93506020850135613d7d81613d37565b92506040850135613d8d81613d37565b91506060850135613d9d81613d37565b939692955090935050565b600080600060608486031215613dbd57600080fd5b83359250602084013591506040840135613dd681613d37565b809150509250925092565b600060208284031215613df357600080fd5b8135610c0781613d37565b60008060408385031215613e1157600080fd5b823591506020830135613e2381613d37565b809150509250929050565b60008060408385031215613e4157600080fd5b50508035926020909101359150565b600581106110c657600080fd5b600681106110c657600080fd5b6000806000838503610100811215613e8157600080fd5b60c0811215613e8f57600080fd5b50613e98613b8d565b84358152602085013560208201526040850135613eb481613e50565b80604083015250606085013560608201526080850135608082015260a0850135613edd81613e5d565b60a08201529560c0850135955060e0909401359392505050565b634e487b7160e01b600052602160045260246000fd5b600581106110c657634e487b7160e01b600052602160045260246000fd5b60208101613f3883613f0d565b91905290565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052601160045260246000fd5b600181815b80851115613fa5578160001904821115613f8b57613f8b613f54565b80851615613f9857918102915b93841c9390800290613f6f565b509250929050565b600082613fbc57506001611e0e565b81613fc957506000611e0e565b8160018114613fdf5760028114613fe957614005565b6001915050611e0e565b60ff841115613ffa57613ffa613f54565b50506001821b611e0e565b5060208310610133831016604e8410600b8410161715614028575081810a611e0e565b6140328383613f6a565b806000190482111561404657614046613f54565b029392505050565b6000610c078383613fad565b60008083128015600160ff1b85018412161561407857614078613f54565b6001600160ff1b038401831381161561409357614093613f54565b50500390565b600082198211156140ac576140ac613f54565b500190565b6000828210156140c3576140c3613f54565b500390565b6020808252818101527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604082015260600190565b80516001600160681b038116811461329e57600080fd5b80516001600160801b038116811461329e57600080fd5b8051801515811461329e57600080fd5b600080600080600080600080610100898b03121561415857600080fd5b885161ffff8116811461416a57600080fd5b975061417860208a016140fd565b965061418660408a016140fd565b95506060890151945061419b60808a01614114565b93506141a960a08a01614114565b925060c089015191506141be60e08a0161412b565b90509295985092959890939650565b6001600160a01b03929092168252602082015260400190565b6000602082840312156141f857600080fd5b610c078261412b565b60006020828403121561421357600080fd5b8151610c0781613d37565b6020808252600a90820152691bdb9b1e4815985d5b1d60b21b604082015260600190565b60006020828403121561425457600080fd5b5051919050565b600060001982141561426f5761426f613f54565b5060010190565b6000806040838503121561428957600080fd5b505080516020909101519092909150565b600061012082840312156142ad57600080fd5b6142b5613baf565b9050815181526020820151602082015260408201516040820152606082015160608201526080820151608082015260a082015160a082015260c082015160c082015260e082015160e082015261010080830151818301525092915050565b60006001600160401b0382111561432c5761432c613b2c565b5060051b60200190565b600060a0828403121561434857600080fd5b614350613b42565b90508151815260208083015181830152604083015160408301526143766060840161412b565b606083015260808301516001600160401b0381111561439457600080fd5b8301601f810185136143a557600080fd5b80516143b86143b382614313565b613c18565b81815260059190911b820183019083810190878311156143d757600080fd5b928401925b828410156143f5578351825292840192908401906143dc565b6080860152509295945050505050565b600080610140838503121561441957600080fd5b614423848461429a565b6101208401519092506001600160401b0381111561444057600080fd5b61444c85828601614336565b9150509250929050565b600060a082019050825182526020830151602083015260408301516040830152606083015160608301526080830151608083015292915050565b6000600160ff1b8214156144a6576144a6613f54565b5060000390565b600060a082840312156144bf57600080fd5b6144c7613b42565b82518152602083015160208201526040830151604082015260608301516060820152608083015160808201528091505092915050565b6020808252825182820181905260009190848201906040850190845b8181101561453557835183529284019291840191600101614519565b50909695505050505050565b6000602080838503121561455457600080fd5b82516001600160401b0381111561456a57600080fd5b8301601f8101851361457b57600080fd5b80516145896143b382614313565b81815260c091820283018401918482019190888411156145a857600080fd5b938501935b838510156146225780858a0312156145c55760008081fd5b6145cd613b8d565b8551815286860151878201526040808701516145e881613e50565b90820152606086810151908201526080808701519082015260a08087015161460f81613e5d565b90820152835293840193918501916145ad565b50979650505050505050565b600081600019048311821515161561464857614648613f54565b500290565b60008261466a57634e487b7160e01b600052601260045260246000fd5b500490565b60208082526024908201527f6661696c656420746f2072657475726e2066756e64732066726f6d20737472616040820152637465677960e01b606082015260800190565b6000602082840312156146c557600080fd5b81516001600160401b038111156146db57600080fd5b6146e784828501614336565b949350505050565b805161329e81613d37565b6000610160828403121561470d57600080fd5b614715613bd2565b61471e836146ef565b815261472c602084016146ef565b602082015261473d604084016146ef565b604082015261474e606084016146ef565b606082015261475f608084016146ef565b608082015261477060a084016146ef565b60a082015261478160c084016146ef565b60c082015261479260e084016146ef565b60e08201526101006147a58185016146ef565b908201526101206147b78482016146ef565b908201526101406147c98482016146ef565b908201529392505050565b600061014082840312156147e757600080fd5b6147ef613bf5565b825181526020830151602082015260408301516040820152606083015160608201526080830151608082015260a083015160a082015260c083015160c082015260e083015160e08201526101008084015181830152506101208084015181830152508091505092915050565b60a0810161486887613f0d565b95815260208101949094526040840192909252606083015260809091015290565b60006101008201905082518252602083015160208301526040830151604083015260608301516148b881613f0d565b806060840152506080830151608083015260a083015160a083015260c083015160c083015260e083015160e083015292915050565b6000606082840312156148ff57600080fd5b604051606081016001600160401b038111828210171561492157614921613b2c565b80604052508251815260208301516020820152604083015160408201528091505092915050565b6000610120828403121561495b57600080fd5b610c07838361429a565b6000610180828403121561497857600080fd5b614980613b6a565b825181526020830151602082015260408301516040820152606083015160608201526080830151608082015260a083015160a082015260c083015160c082015260e083015160e08201526101008084015181830152506101208084015181830152506101408084015181830152506101606147c981850161412b56fea2646970667358221220cb8a35dec02402203437cf46f385ae29a24c3c215368a69eeab7a9eda93c548f64736f6c63430008090033",
  "libraries": {
    "BlackScholes": "0xEAB60138D1C2160062bbcD881D153961865aA510"
  },
  "devdoc": {
    "kind": "dev",
    "methods": {
      "_isValidExpiry(uint256)": {
        "details": "check if the expiry of the board is valid according to the strategy"
      },
      "doTrade(uint256,address)": {
        "details": "the vault should pass in a strike id, and the strategy would verify if the strike is valid on-chain.",
        "params": {
          "lyraRewardRecipient": "address to receive trading reward. This need to be whitelisted",
          "strikeId": "lyra strikeId to trade"
        },
        "returns": {
          "positionId": "positionId",
          "premiumReceived": "premiumReceived"
        }
      },
      "emergencyCloseAll(address)": {
        "details": "close all outstanding positions regardless of collat and send funds back to vault"
      },
      "getAllowedCloseAmount((uint256,uint256,uint8,uint256,uint256,uint8),uint256,uint256)": {
        "details": "calculates the position amount required to stay above the buffer collateral"
      },
      "getRequiredCollateral((uint256,uint256,uint256,uint256,uint256))": {
        "details": "calculate required collateral to add in the next trade. sell size is fixed as strategyDetail.size only add collateral if the additional sell will make the position out of buffer range never remove collateral from an existing position"
      },
      "isValidStrike((uint256,uint256,uint256,uint256,uint256))": {
        "details": "verify if the strike is valid for the strategy",
        "returns": {
          "isValid": "true if vol is withint [minVol, maxVol] and delta is within targetDelta +- maxDeltaGap"
        }
      },
      "owner()": {
        "details": "Returns the address of the current owner."
      },
      "reducePosition(uint256,uint256,address)": {
        "details": "use premium in strategy to reduce position size if collateral ratio is out of range"
      },
      "renounceOwnership()": {
        "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."
      },
      "returnFundsAndClearStrikes()": {
        "details": "convert premium in quote asset into collateral asset and send it back to the vault."
      },
      "setBoard(uint256)": {
        "details": "set the board id that will be traded for the next round",
        "params": {
          "boardId": "lyra board Id."
        }
      },
      "setLyraAddresses(address,address,address,address)": {
        "details": "Assigns all lyra contracts",
        "params": {
          "_curveSwap": "Curve pool address for swapping sUSD and other stables via `exchange_with_best_rate`",
          "_feeCounter": "Fee counter addressu used to determine Lyra trading rewards",
          "_lyraRegistry": "LyraRegistry address which holds latest market and global addressess",
          "_optionMarket": "OptionMarket address"
        }
      },
      "setStrategyDetail((uint256,uint256,int256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256))": {
        "details": "update the strategy detail for the new round."
      },
      "transferOwnership(address)": {
        "details": "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "_optionPriceGWAV(uint256,uint256)": {
        "notice": "the option price GWAV for a given `strikeId` with GWAV interval `secondsAgo`"
      },
      "doTrade(uint256,address)": {
        "notice": "sell a fix aomunt of options and collect premium"
      },
      "updateDelegateApproval()": {
        "notice": "In case of an update to the synthetix contract that revokes the approval"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 48186,
        "contract": "contracts/strategies/DeltaShortStrategy.sol:DeltaShortStrategy",
        "label": "_owner",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 21683,
        "contract": "contracts/strategies/DeltaShortStrategy.sol:DeltaShortStrategy",
        "label": "lyraRegistry",
        "offset": 0,
        "slot": "1",
        "type": "t_contract(LyraRegistry)23780"
      },
      {
        "astId": 21686,
        "contract": "contracts/strategies/DeltaShortStrategy.sol:DeltaShortStrategy",
        "label": "synthetixAdapter",
        "offset": 0,
        "slot": "2",
        "type": "t_contract(SynthetixAdapter)17112"
      },
      {
        "astId": 21689,
        "contract": "contracts/strategies/DeltaShortStrategy.sol:DeltaShortStrategy",
        "label": "optionMarket",
        "offset": 0,
        "slot": "3",
        "type": "t_contract(OptionMarket)9952"
      },
      {
        "astId": 21692,
        "contract": "contracts/strategies/DeltaShortStrategy.sol:DeltaShortStrategy",
        "label": "optionToken",
        "offset": 0,
        "slot": "4",
        "type": "t_contract(OptionToken)13512"
      },
      {
        "astId": 21695,
        "contract": "contracts/strategies/DeltaShortStrategy.sol:DeltaShortStrategy",
        "label": "liquidityPool",
        "offset": 0,
        "slot": "5",
        "type": "t_contract(LiquidityPool)2849"
      },
      {
        "astId": 21698,
        "contract": "contracts/strategies/DeltaShortStrategy.sol:DeltaShortStrategy",
        "label": "shortCollateral",
        "offset": 0,
        "slot": "6",
        "type": "t_contract(ShortCollateral)14788"
      },
      {
        "astId": 21701,
        "contract": "contracts/strategies/DeltaShortStrategy.sol:DeltaShortStrategy",
        "label": "gwavOracle",
        "offset": 0,
        "slot": "7",
        "type": "t_contract(GWAVOracle)20428"
      },
      {
        "astId": 21704,
        "contract": "contracts/strategies/DeltaShortStrategy.sol:DeltaShortStrategy",
        "label": "optionPricer",
        "offset": 0,
        "slot": "8",
        "type": "t_contract(OptionMarketPricer)11329"
      },
      {
        "astId": 21707,
        "contract": "contracts/strategies/DeltaShortStrategy.sol:DeltaShortStrategy",
        "label": "greekCache",
        "offset": 0,
        "slot": "9",
        "type": "t_contract(OptionGreekCache)6508"
      },
      {
        "astId": 21710,
        "contract": "contracts/strategies/DeltaShortStrategy.sol:DeltaShortStrategy",
        "label": "quoteAsset",
        "offset": 0,
        "slot": "10",
        "type": "t_contract(IERC20)48947"
      },
      {
        "astId": 21713,
        "contract": "contracts/strategies/DeltaShortStrategy.sol:DeltaShortStrategy",
        "label": "baseAsset",
        "offset": 0,
        "slot": "11",
        "type": "t_contract(IERC20)48947"
      },
      {
        "astId": 21716,
        "contract": "contracts/strategies/DeltaShortStrategy.sol:DeltaShortStrategy",
        "label": "curveSwap",
        "offset": 0,
        "slot": "12",
        "type": "t_contract(ICurve)17307"
      },
      {
        "astId": 21719,
        "contract": "contracts/strategies/DeltaShortStrategy.sol:DeltaShortStrategy",
        "label": "feeCounter",
        "offset": 0,
        "slot": "13",
        "type": "t_contract(BasicFeeCounter)20045"
      },
      {
        "astId": 39140,
        "contract": "contracts/strategies/DeltaShortStrategy.sol:DeltaShortStrategy",
        "label": "collateralAsset",
        "offset": 0,
        "slot": "14",
        "type": "t_contract(IERC20)33957"
      },
      {
        "astId": 39144,
        "contract": "contracts/strategies/DeltaShortStrategy.sol:DeltaShortStrategy",
        "label": "lastTradeTimestamp",
        "offset": 0,
        "slot": "15",
        "type": "t_mapping(t_uint256,t_uint256)"
      },
      {
        "astId": 39147,
        "contract": "contracts/strategies/DeltaShortStrategy.sol:DeltaShortStrategy",
        "label": "activeStrikeIds",
        "offset": 0,
        "slot": "16",
        "type": "t_array(t_uint256)dyn_storage"
      },
      {
        "astId": 39151,
        "contract": "contracts/strategies/DeltaShortStrategy.sol:DeltaShortStrategy",
        "label": "strikeToPositionId",
        "offset": 0,
        "slot": "17",
        "type": "t_mapping(t_uint256,t_uint256)"
      },
      {
        "astId": 38293,
        "contract": "contracts/strategies/DeltaShortStrategy.sol:DeltaShortStrategy",
        "label": "strategyDetail",
        "offset": 0,
        "slot": "18",
        "type": "t_struct(DeltaShortStrategyDetail)38290_storage"
      },
      {
        "astId": 38295,
        "contract": "contracts/strategies/DeltaShortStrategy.sol:DeltaShortStrategy",
        "label": "activeExpiry",
        "offset": 0,
        "slot": "30",
        "type": "t_uint256"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_uint256)dyn_storage": {
        "base": "t_uint256",
        "encoding": "dynamic_array",
        "label": "uint256[]",
        "numberOfBytes": "32"
      },
      "t_contract(BasicFeeCounter)20045": {
        "encoding": "inplace",
        "label": "contract BasicFeeCounter",
        "numberOfBytes": "20"
      },
      "t_contract(GWAVOracle)20428": {
        "encoding": "inplace",
        "label": "contract GWAVOracle",
        "numberOfBytes": "20"
      },
      "t_contract(ICurve)17307": {
        "encoding": "inplace",
        "label": "contract ICurve",
        "numberOfBytes": "20"
      },
      "t_contract(IERC20)33957": {
        "encoding": "inplace",
        "label": "contract IERC20",
        "numberOfBytes": "20"
      },
      "t_contract(IERC20)48947": {
        "encoding": "inplace",
        "label": "contract IERC20",
        "numberOfBytes": "20"
      },
      "t_contract(LiquidityPool)2849": {
        "encoding": "inplace",
        "label": "contract LiquidityPool",
        "numberOfBytes": "20"
      },
      "t_contract(LyraRegistry)23780": {
        "encoding": "inplace",
        "label": "contract LyraRegistry",
        "numberOfBytes": "20"
      },
      "t_contract(OptionGreekCache)6508": {
        "encoding": "inplace",
        "label": "contract OptionGreekCache",
        "numberOfBytes": "20"
      },
      "t_contract(OptionMarket)9952": {
        "encoding": "inplace",
        "label": "contract OptionMarket",
        "numberOfBytes": "20"
      },
      "t_contract(OptionMarketPricer)11329": {
        "encoding": "inplace",
        "label": "contract OptionMarketPricer",
        "numberOfBytes": "20"
      },
      "t_contract(OptionToken)13512": {
        "encoding": "inplace",
        "label": "contract OptionToken",
        "numberOfBytes": "20"
      },
      "t_contract(ShortCollateral)14788": {
        "encoding": "inplace",
        "label": "contract ShortCollateral",
        "numberOfBytes": "20"
      },
      "t_contract(SynthetixAdapter)17112": {
        "encoding": "inplace",
        "label": "contract SynthetixAdapter",
        "numberOfBytes": "20"
      },
      "t_int256": {
        "encoding": "inplace",
        "label": "int256",
        "numberOfBytes": "32"
      },
      "t_mapping(t_uint256,t_uint256)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_struct(DeltaShortStrategyDetail)38290_storage": {
        "encoding": "inplace",
        "label": "struct DeltaShortStrategy.DeltaShortStrategyDetail",
        "members": [
          {
            "astId": 38267,
            "contract": "contracts/strategies/DeltaShortStrategy.sol:DeltaShortStrategy",
            "label": "minTimeToExpiry",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 38269,
            "contract": "contracts/strategies/DeltaShortStrategy.sol:DeltaShortStrategy",
            "label": "maxTimeToExpiry",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 38271,
            "contract": "contracts/strategies/DeltaShortStrategy.sol:DeltaShortStrategy",
            "label": "targetDelta",
            "offset": 0,
            "slot": "2",
            "type": "t_int256"
          },
          {
            "astId": 38273,
            "contract": "contracts/strategies/DeltaShortStrategy.sol:DeltaShortStrategy",
            "label": "maxDeltaGap",
            "offset": 0,
            "slot": "3",
            "type": "t_uint256"
          },
          {
            "astId": 38275,
            "contract": "contracts/strategies/DeltaShortStrategy.sol:DeltaShortStrategy",
            "label": "minVol",
            "offset": 0,
            "slot": "4",
            "type": "t_uint256"
          },
          {
            "astId": 38277,
            "contract": "contracts/strategies/DeltaShortStrategy.sol:DeltaShortStrategy",
            "label": "maxVol",
            "offset": 0,
            "slot": "5",
            "type": "t_uint256"
          },
          {
            "astId": 38279,
            "contract": "contracts/strategies/DeltaShortStrategy.sol:DeltaShortStrategy",
            "label": "size",
            "offset": 0,
            "slot": "6",
            "type": "t_uint256"
          },
          {
            "astId": 38281,
            "contract": "contracts/strategies/DeltaShortStrategy.sol:DeltaShortStrategy",
            "label": "minTradeInterval",
            "offset": 0,
            "slot": "7",
            "type": "t_uint256"
          },
          {
            "astId": 38283,
            "contract": "contracts/strategies/DeltaShortStrategy.sol:DeltaShortStrategy",
            "label": "maxVolVariance",
            "offset": 0,
            "slot": "8",
            "type": "t_uint256"
          },
          {
            "astId": 38285,
            "contract": "contracts/strategies/DeltaShortStrategy.sol:DeltaShortStrategy",
            "label": "gwavPeriod",
            "offset": 0,
            "slot": "9",
            "type": "t_uint256"
          },
          {
            "astId": 38287,
            "contract": "contracts/strategies/DeltaShortStrategy.sol:DeltaShortStrategy",
            "label": "collatBuffer",
            "offset": 0,
            "slot": "10",
            "type": "t_uint256"
          },
          {
            "astId": 38289,
            "contract": "contracts/strategies/DeltaShortStrategy.sol:DeltaShortStrategy",
            "label": "collatPercent",
            "offset": 0,
            "slot": "11",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "384"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}